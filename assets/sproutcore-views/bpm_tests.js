/* ===========================================================================
   BPM Combined Asset File
   MANIFEST: sproutcore-views (2.0.beta.3)
   This file is generated automatically by the bpm (http://www.bpmjs.org)
   =========================================================================*/

spade.register("sproutcore-views/~tests/system/application_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar view;\nvar application;\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.Application\", {\n  setup: function() {\n    $(\"#qunit-fixture\").html(\"<div id='one'><div id='one-child'>HI</div></div><div id='two'>HI</div>\");\n    application = SC.Application.create({ rootElement: '#one' });\n  },\n\n  teardown: function() {\n    application.destroy();\n  }\n});\n\ntest(\"you can make a new application in a non-overlapping element\", function() {\n  var app = SC.Application.create({ rootElement: '#two' });\n  app.destroy();\n});\n\ntest(\"you cannot make a new application that is a parent of an existing application\", function() {\n  raises(function() {\n    SC.Application.create({ rootElement: '#qunit-fixture' });\n  }, Error);\n});\n\ntest(\"you cannot make a new application that is a descendent of an existing application\", function() {\n  raises(function() {\n    SC.Application.create({ rootElement: '#one-child' });\n  }, Error);\n});\n\ntest(\"you cannot make a new application that is a duplicate of an existing application\", function() {\n  raises(function() {\n    SC.Application.create({ rootElement: '#one' });\n  }, Error);\n});\n\n\n});");spade.register("sproutcore-views/~tests/system/event_dispatcher_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar view;\nvar application;\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.EventDispatcher\", {\n  setup: function() {\n    application = SC.Application.create();\n  },\n\n  teardown: function() {\n    if (view) { view.destroy(); }\n    application.destroy();\n  }\n});\n\ntest(\"should dispatch events to views\", function() {\n  var receivedEvent;\n  var parentMouseDownCalled = 0;\n  var childKeyDownCalled = 0;\n  var parentKeyDownCalled = 0;\n\n  view = SC.ContainerView.create({\n    childViews: ['child'],\n\n    child: SC.View.extend({\n      render: function(buffer) {\n        buffer.push('<span id=\"wot\">ewot</span>');\n      },\n\n      keyDown: function(evt) {\n        childKeyDownCalled++;\n\n        return false;\n      }\n    }),\n\n    render: function(buffer) {\n      buffer.push('some <span id=\"awesome\">awesome</span> content');\n      this._super(buffer);\n    },\n\n    mouseDown: function(evt) {\n      parentMouseDownCalled++;\n      receivedEvent = evt;\n    },\n\n    keyDown: function(evt) {\n      parentKeyDownCalled++;\n    }\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  view.$().trigger('mousedown');\n\n  ok(receivedEvent, \"passes event to associated event method\");\n  receivedEvent = null;\n  parentMouseDownCalled = 0;\n\n  view.$('span#awesome').trigger('mousedown');\n  ok(receivedEvent, \"event bubbles up to nearest SC.View\");\n  equals(parentMouseDownCalled, 1, \"does not trigger the parent handlers twice because of browser bubbling\");\n  receivedEvent = null;\n\n  SC.$('#wot').trigger('mousedown');\n  ok(receivedEvent, \"event bubbles up to nearest SC.View\");\n\n  SC.$('#wot').trigger('keydown');\n  equals(childKeyDownCalled, 1, \"calls keyDown on child view\");\n  equals(parentKeyDownCalled, 0, \"does not call keyDown on parent if child handles event\");\n});\n\ntest(\"should send change events up view hierarchy if view contains form elements\", function() {\n  var receivedEvent;\n  view = SC.View.create({\n    render: function(buffer) {\n      buffer.push('<input id=\"is-done\" type=\"checkbox\">');\n    },\n\n    change: function(evt) {\n      receivedEvent = evt;\n    }\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  SC.$('#is-done').trigger('change');\n  ok(receivedEvent, \"calls change method when a child element is changed\");\n  equals(receivedEvent.target, SC.$('#is-done')[0], \"target property is the element that was clicked\");\n});\n\ntest(\"events should stop propagating if the view is destroyed\", function() {\n  var parentViewReceived, receivedEvent;\n\n  var parentView = SC.ContainerView.create({\n    change: function(evt) {\n      parentViewReceived = true;\n    }\n  });\n\n  view = parentView.createChildView(SC.View, {\n    render: function(buffer) {\n      buffer.push('<input id=\"is-done\" type=\"checkbox\">');\n    },\n\n    change: function(evt) {\n      receivedEvent = true;\n      get(this, 'parentView').destroy();\n    }\n  });\n\n  SC.get(parentView, 'childViews').pushObject(view);\n\n  SC.run(function() {\n    parentView.append();\n  });\n\n  ok(SC.$('#is-done').length, \"precond - view is in the DOM\");\n  SC.$('#is-done').trigger('change');\n  ok(!SC.$('#is-done').length, \"precond - view is not in the DOM\");\n  ok(receivedEvent, \"calls change method when a child element is changed\");\n  ok(!parentViewReceived, \"parent view does not receive the event\");\n});\n\ntest(\"should not interfere with event propagation\", function() {\n  var receivedEvent;\n  view = SC.View.create({\n    render: function(buffer) {\n      buffer.push('<div id=\"propagate-test-div\"></div>')\n    }\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  SC.$(window).bind('click', function(evt) {\n    receivedEvent = evt;\n  });\n\n  SC.$('#propagate-test-div').click();\n\n  ok(receivedEvent, \"allowed event to propagate outside SC\")\n  same(receivedEvent.target, SC.$('#propagate-test-div')[0], \"target property is the element that was clicked\");\n});\n\ntest(\"should dispatch events to nearest event manager\", function() {\n  var receivedEvent=0;\n  view = SC.ContainerView.create({\n    render: function(buffer) {\n      buffer.push('<input id=\"is-done\" type=\"checkbox\">');\n    },\n\n    eventManager: SC.Object.create({\n      mouseDown: function() {\n        receivedEvent++;\n      }\n    }),\n\n    mouseDown: function() {}\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  SC.$('#is-done').trigger('mousedown');\n  equals(receivedEvent, 1, \"event should go to manager and not view\");\n});\n\ntest(\"event manager should be able to re-dispatch events to view\", function() {\n\n  var receivedEvent=0;\n  view = SC.ContainerView.create({\n    elementId: 'containerView',\n\n    eventManager: SC.Object.create({\n      mouseDown: function(evt, view) {\n        // Re-dispatch event when you get it.\n        //\n        // The second parameter tells the dispatcher\n        // that this event has been handled. This\n        // API will clearly need to be reworked since\n        // multiple eventManagers in a single view \n        // hierarchy would break, but it shows that \n        // re-dispatching works\n        view.$().trigger('mousedown',this);\n      }\n    }),\n\n    childViews: ['child'],\n\n    child: SC.View.extend({\n      elementId: 'nestedView',\n\n      mouseDown: function(evt) {\n        receivedEvent++;\n      }\n    }),\n\n    mouseDown: function(evt) {\n      receivedEvent++;\n    }\n  });\n\n  SC.run(function() { view.append(); });\n\n  SC.$('#nestedView').trigger('mousedown');\n  equals(receivedEvent, 2, \"event should go to manager and not view\");\n});\n\n});");spade.register("sproutcore-views/~tests/system/render_buffer", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*global module test equals context ok same */\n\n\nvar set = SC.set, get = SC.get;\n\n// .......................................................\n//  render()\n//\nmodule(\"SC.RenderBuffer\");\n\ntest(\"RenderBuffers combine strings\", function() {\n  var buffer = new SC.RenderBuffer('div');\n\n  buffer.push('a');\n  buffer.push('b');\n\n  equals(\"<div>ab</div>\", buffer.string(), \"Multiple pushes should concatenate\");\n});\n\ntest(\"It is possible to remove a RenderBuffer\", function() {\n  var buffer = new SC.RenderBuffer('div');\n\n  buffer.push('a');\n\n  var second = buffer.begin('span').push('zomg');\n  second.end();\n\n  var third = buffer.begin('span').push('wotwot');\n  third.end();\n\n  buffer.push('b');\n\n  second.remove();\n\n  equals(buffer.string(), '<div>a<span>wotwot</span>b</div>', 'Removed elements are gone');\n});\n\ntest(\"It is possible to replace a RenderBuffer\", function() {\n  var buffer = new SC.RenderBuffer('div');\n\n  buffer.push('a');\n\n  var second = buffer.begin('span').push('zomg');\n  second.end();\n\n  buffer.push('b');\n\n  var third = buffer.begin('span').push('wotwot');\n  third.end();\n\n  buffer.push('c');\n\n  var replacement = second.replaceWith('aside').push('replaced!');\n  replacement.end();\n\n  equals(buffer.string(), '<div>a<aside>replaced!</aside>b<span>wotwot</span>c</div>', 'Removed elements are absent in the final output');\n});\n\ntest(\"It is possible to insert a RenderBuffer after another one\", function() {\n  var buffer = new SC.RenderBuffer('div');\n\n  buffer.push('a');\n\n  var second = buffer.begin('span').push('zomg');\n  second.end();\n\n  buffer.push('b');\n\n  var third = buffer.begin('span').push('wotwot');\n  third.end();\n\n  buffer.push('c');\n\n  var inserted = third.insertAfter('aside').push('inserted!');\n  inserted.end();\n\n  equals(buffer.string(), '<div>a<span>zomg</span>b<span>wotwot</span><aside>inserted!</aside>c</div>', 'Inserted objects are inserted in the final output');\n});\n\ntest(\"It is possible to prepend a child RenderBuffer\", function() {\n  var buffer = new SC.RenderBuffer('div');\n\n  buffer.push('a');\n\n  var second = buffer.begin('span').push('zomg');\n  second.end();\n\n  buffer.push('b');\n\n  var third = buffer.begin('span').push('wotwot');\n  third.end();\n\n  buffer.push('c');\n\n  var prepended = buffer.prepend('aside').push('prepended!');\n  prepended.end();\n\n  equals(buffer.string(), '<div><aside>prepended!</aside>a<span>zomg</span>b<span>wotwot</span>c</div>', 'Prepended buffers are prepended to the final output');\n});\n\n\n\n});");spade.register("sproutcore-views/~tests/views/collection_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\nvar view;\n\nmodule(\"SC.CollectionView\", {\n  setup: function() {\n    SC.CollectionView.CONTAINER_MAP.del = 'em';\n  },\n  teardown: function() {\n    delete SC.CollectionView.CONTAINER_MAP.del;\n    if (view) { view.destroy(); }\n  }\n});\n\ntest(\"should render a view for each item in its content array\", function() {\n  view = SC.CollectionView.create({\n    content: [1, 2, 3, 4]\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n  equals(view.$('div').length, 4);\n});\n\ntest(\"should render the emptyView if content array is empty (view class)\", function() {\n  view = SC.CollectionView.create({\n    tagName: 'del',\n    content: [],\n\n    emptyView: SC.View.extend({\n      tagName: 'kbd',\n      render: function(buf) {\n        buf.push(\"OY SORRY GUVNAH NO NEWS TODAY EH\");\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(view.$().find('kbd:contains(\"OY SORRY GUVNAH\")').length, \"displays empty view\");\n});\n\ntest(\"should render the emptyView if content array is empty (view instance)\", function() {\n  view = SC.CollectionView.create({\n    tagName: 'del',\n    content: [],\n\n    emptyView: SC.View.create({\n      tagName: 'kbd',\n      render: function(buf) {\n        buf.push(\"OY SORRY GUVNAH NO NEWS TODAY EH\");\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(view.$().find('kbd:contains(\"OY SORRY GUVNAH\")').length, \"displays empty view\");\n});\n\ntest(\"should be able to override the tag name of itemViewClass even if tag is in default mapping\", function() {\n  view = SC.CollectionView.create({\n    tagName: 'del',\n    content: ['NEWS GUVNAH'],\n\n    itemViewClass: SC.View.extend({\n      tagName: 'kbd',\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(view.$().find('kbd:contains(\"NEWS GUVNAH\")').length, \"displays the item view with proper tag name\");\n});\n\ntest(\"should allow custom item views by setting itemViewClass\", function() {\n  var passedContents = [];\n  view = SC.CollectionView.create({\n    content: ['foo', 'bar', 'baz'],\n\n    itemViewClass: SC.View.extend({\n      render: function(buf) {\n        passedContents.push(get(this, 'content'));\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  same(passedContents, ['foo', 'bar', 'baz'], \"sets the content property on each item view\");\n\n  passedContents.forEach(function(item) {\n    equals(view.$(':contains(\"'+item+'\")').length, 1);\n  });\n});\n\ntest(\"should insert a new item in DOM when an item is added to the content array\", function() {\n  var content = ['foo', 'bar', 'baz'];\n\n  view = SC.CollectionView.create({\n    content: content,\n\n    itemViewClass: SC.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  content.forEach(function(item) {\n    equals(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  SC.run(function() {\n    content.insertAt(1, 'quux');\n  });\n\n  equals(view.$(':nth-child(2)').text(), 'quux');\n});\n\ntest(\"should remove an item from DOM when an item is removed from the content array\", function() {\n  var content = ['foo', 'bar', 'baz'];\n\n  view = SC.CollectionView.create({\n    content: content,\n\n    itemViewClass: SC.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  content.forEach(function(item) {\n    equals(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  SC.run(function() {\n    content.removeAt(1);\n  });\n\n  content.forEach(function(item, idx) {\n    equals(view.$(':nth-child(%@)'.fmt(idx+1)).text(), item);\n  });\n});\n\ntest(\"should allow changes to content object before layer is created\", function() {\n  view = SC.CollectionView.create({\n    content: null\n  });\n\n  set(view, 'content', []);\n  set(view, 'content', [1, 2, 3]);\n  set(view, 'content', [1, 2]);\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(view.$().children().length);\n});\n\ntest(\"should allow changing content property to be null\", function() {\n  view = SC.CollectionView.create({\n    content: [1, 2, 3],\n\n    emptyView: SC.View.extend({\n      template: function() { return \"(empty)\"; }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  equals(view.$().children().length, 3, \"precond - creates three elements\");\n\n  SC.run(function() {\n    set(view, 'content', null);\n  });\n\n  equals(view.$().children().text(), \"(empty)\", \"should display empty view\");\n});\n\ntest(\"should allow items to access to the CollectionView's current index in the content array\", function() {\n  view = SC.CollectionView.create({\n    content: ['zero', 'one', 'two'],\n    itemViewClass: SC.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'contentIndex'));\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  same(view.$(':nth-child(1)').text(), \"0\");\n  same(view.$(':nth-child(2)').text(), \"1\");\n  same(view.$(':nth-child(3)').text(), \"2\");\n});\n\n});");spade.register("sproutcore-views/~tests/views/container_view_test", "(function(require, exports, __module, ARGV, ENV, __filename){module(\"sproutcore-views/views/container_view_test\");\n\ntest(\"should be able to insert views after the DOM representation is created\", function() {\n  var container = SC.ContainerView.create({\n    classNameBindings: ['name'],\n\n    name: 'foo'\n  });\n\n  SC.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  var view = container.createChildView(SC.View, {\n    template: function() {\n      return \"This is my moment\";\n    }\n  });\n\n  SC.run(function() {\n    container.get('childViews').pushObject(view);\n  });\n\n  equals(container.$().text(), \"This is my moment\");\n\n  container.destroy();\n});\n\n});");spade.register("sproutcore-views/~tests/views/view/append_to_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore Views\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nvar View, view, willDestroyCalled, childView;\n\nmodule(\"SC.View - append() and appendTo()\", {\n  setup: function() {\n    View = SC.View.extend({});\n  },\n\n  teardown: function() {\n    view.destroy();\n  }\n});\n\ntest(\"should be added to the specified element when calling append()\", function() {\n  jQuery(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.appendTo('#menu');\n  });\n\n  var viewElem = SC.$('#menu').children();\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\ntest(\"should be added to the document body when calling appendTo()\", function() {\n  view = View.create({\n    render: function(buffer) {\n      buffer.push(\"foo bar baz\");\n    }\n  });\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.append();\n  });\n\n  var viewElem = SC.$(document.body).find(':contains(\"foo bar baz\")');\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\ntest(\"append calls willInsertElement and didInsertElement callbacks\", function(){\n  var willInsertElementCalled = false;\n  var didInsertElementCalled = false;\n  \n  var ViewWithCallback = View.extend({\n    willInsertElement: function(){\n      willInsertElementCalled = true;\n    },\n    didInsertElement: function(){\n      didInsertElementCalled = true;\n    }\n  });\n  \n  view = ViewWithCallback.create()\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(willInsertElementCalled, \"willInsertElement called\");\n  ok(didInsertElementCalled, \"didInsertElement called\");\n});\n\ntest(\"remove removes an element from the DOM\", function() {\n  willDestroyCalled = 0;\n\n  view = View.create({\n    willDestroyElement: function() {\n      willDestroyCalled++;\n    }\n  });\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(SC.$(\"#\" + get(view, 'elementId')).length === 1, \"precond - element was inserted\");\n\n  SC.run(function() {\n    view.remove();\n  });\n\n  ok(SC.$(\"#\" + get(view, 'elementId')).length === 0, \"remove removes an element from the DOM\");\n  ok(SC.View.views[get(view, 'elementId')] === view, \"remove does not remove the view from the view hash\");\n  ok(!get(view, 'element'), \"remove nulls out the element\");\n  equals(willDestroyCalled, 1, \"the willDestroyElement hook was called once\");\n});\n\ntest(\"destroy more forcibly removes the view\", function() {\n  willDestroyCalled = 0;\n\n  view = View.create({\n    willDestroyElement: function() {\n      willDestroyCalled++;\n    }\n  });\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(SC.$(\"#\" + get(view, 'elementId')).length === 1, \"precond - element was inserted\");\n\n  SC.run(function() {\n    view.destroy();\n  });\n\n  ok(SC.$(\"#\" + get(view, 'elementId')).length === 0, \"destroy removes an element from the DOM\");\n  ok(SC.View.views[get(view, 'elementId')] === undefined, \"destroy removes a view from the global views hash\");\n  equals(get(view, 'isDestroyed'), true, \"the view is marked as destroyed\");\n  ok(!get(view, 'element'), \"the view no longer has an element\");\n  equals(willDestroyCalled, 1, \"the willDestroyElement hook was called once\");\n});\n\nmodule(\"SC.View - append() and appendTo() in a view hierarchy\", {\n  setup: function() {\n    View = SC.ContainerView.extend({\n      childViews: ['child'],\n      child: SC.View.extend({\n        elementId: 'child'\n      })\n    });\n  },\n\n  teardown: function() {\n    view.destroy();\n  }\n});\n\ntest(\"should be added to the specified element when calling appendTo()\", function() {\n  jQuery(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.appendTo('#menu');\n  });\n\n  var viewElem = SC.$('#menu #child');\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\ntest(\"should be added to the document body when calling append()\", function() {\n  jQuery(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.append();\n  });\n\n  var viewElem = SC.$('#child');\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\nmodule(\"SC.View - removing views in a view hierarchy\", {\n  setup: function() {\n    willDestroyCalled = 0;\n\n    view = SC.ContainerView.create({\n      childViews: ['child'],\n      child: SC.View.create({\n        willDestroyElement: function() {\n          willDestroyCalled++;\n        }\n      })\n    });\n\n    childView = get(view, 'child');\n  },\n\n  teardown: function() {\n    view.destroy();\n  }\n});\n\ntest(\"remove removes child elements from the DOM\", function() {\n  ok(!get(childView, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(SC.$(\"#\" + get(childView, 'elementId')).length === 1, \"precond - element was inserted\");\n\n  // remove parent view\n  SC.run(function() {\n    view.remove();\n  });\n\n  ok(SC.$(\"#\" + get(childView, 'elementId')).length === 0, \"remove removes child elements the DOM\");\n  ok(SC.View.views[get(childView, 'elementId')] === childView, \"remove does not remove child views from the view hash\");\n  ok(!get(childView, 'element'), \"remove nulls out child elements\");\n  equals(willDestroyCalled, 1, \"the willDestroyElement hook was called once\");\n});\n\ntest(\"destroy more forcibly removes child views\", function() {\n  ok(!get(childView, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(SC.$(\"#\" + get(childView, 'elementId')).length === 1, \"precond - child element was inserted\");\n\n  willDestroyCalled = 0;\n\n  SC.run(function() {\n    view.destroy();\n  });\n\n  ok(SC.$(\"#\" + get(childView, 'elementId')).length === 0, \"destroy removes child elements from the DOM\");\n  ok(SC.View.views[get(childView, 'elementId')] === undefined, \"destroy removes a child views from the global views hash\");\n  equals(get(childView, 'isDestroyed'), true, \"child views are marked as destroyed\");\n  ok(!get(childView, 'element'), \"child views no longer have an element\");\n  equals(willDestroyCalled, 1, \"the willDestroyElement hook was called once on children\");\n});\n\ntest(\"destroy removes a child view from its parent\", function() {\n  ok(!get(childView, 'element'), \"precond - should not have an element\");\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(SC.$(\"#\" + get(childView, 'elementId')).length === 1, \"precond - child element was inserted\");\n\n  SC.run(function() {\n    childView.destroy();\n  });\n\n  ok(SC.getPath(view, 'childViews.length') === 0, \"Destroyed child views should be removed from their parent\");\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/attribute_bindings_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore Views\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nrequire('sproutcore-views/views/view');\n\nmodule(\"SC.View - Attribute Bindings\");\n\ntest(\"should render and update attribute bindings\", function() {\n  var view = SC.View.create({\n    classNameBindings: ['priority', 'isUrgent', 'isClassified:classified', 'canIgnore'],\n    attributeBindings: ['type', 'exploded', 'destroyed', 'exists', 'explosions'],\n\n    type: 'reset',\n    exploded: true,\n    destroyed: true,\n    exists: false,\n    explosions: 15\n  });\n\n  view.createElement();\n  equals(view.$().attr('type'), 'reset', \"adds type attribute\");\n  ok(view.$().attr('exploded'), \"adds exploded attribute when true\");\n  ok(view.$().attr('destroyed'), \"adds destroyed attribute when true\");\n  ok(!view.$().attr('exists'), \"does not add exists attribute when false\");\n  equals(view.$().attr('explosions'), \"15\", \"adds integer attributes\");\n\n  view.set('type', 'submit');\n  view.set('exploded', false);\n  view.set('destroyed', false);\n  view.set('exists', true);\n\n  equals(view.$().attr('type'), 'submit', \"updates type attribute\");\n  ok(!view.$().attr('exploded'), \"removes exploded attribute when false\");\n  ok(!view.$().attr('destroyed'), \"removes destroyed attribute when false\");\n  ok(view.$().attr('exists'), \"adds exists attribute when true\");\n});\n\ntest(\"should allow attributes to be set in the inBuffer state\", function() {\n  var parentView, childViews;\n  SC.run(function() {\n    window.Test = SC.Namespace.create();\n    Test.controller = SC.Object.create({\n      foo: 'bar'\n    });\n\n    parentView = SC.ContainerView.create();\n\n    childViews = parentView.get('childViews');\n    childViews.pushObject(parentView.createChildView(SC.View, {\n      template: function() {\n        return \"foo\";\n      },\n\n      fooBinding: 'Test.controller.foo',\n      attributeBindings: ['foo']\n    }));\n\n    childViews.pushObject(parentView.createChildView(SC.View, {\n      template: function() {\n        Test.controller.set('foo', 'baz');\n        return \"bar\";\n      }\n    }));\n\n    childViews.pushObject(parentView.createChildView(SC.View, {\n      template: function() {\n        return \"bat\";\n      }\n    }));\n  });\n\n  SC.run(function() {\n    parentView.append();\n  });\n\n  equals(parentView.get('childViews')[0].$().attr('foo'), 'baz');\n\n  parentView.destroy();\n\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/child_views_test", "(function(require, exports, __module, ARGV, ENV, __filename){(function() {\n  var parentView, childView, childViews;\n  var get = SC.get;\n\n  module('tests/views/view/child_views_tests.js', {\n    setup: function() {\n      parentView = SC.View.create({\n        render: function(buffer) {\n          buffer.push('Sprout');\n          this.appendChild(childView);\n        }\n      });\n\n      childView = SC.View.create({\n        template: function() { return 'Core'; }\n      });\n    },\n\n    teardown: function() {\n      parentView.destroy();\n      childView.destroy();\n      childViews = null;\n    }\n  });\n\n  // no parent element, buffer, no element\n  // parent element\n\n  // no parent element, no buffer, no element\n  test(\"should render an inserted child view when the child is inserted before a DOM element is created\", function() {\n    SC.run(function() {\n      parentView.append();\n    });\n\n    equals(parentView.$().text(), 'SproutCore', 'renders the child view after the parent view');\n  });\n\n  test(\"should not duplicate childViews when rerendering in buffer\", function() {\n\n    var inner = SC.View.create({\n      template: function() { return ''; }\n    });\n\n    var middle = SC.View.create({\n      render: function(buffer) {\n        this.appendChild(inner);\n      }\n    });\n\n    var outer = SC.View.create({\n      render: function(buffer) {\n        this.appendChild(middle);\n      }\n    });\n\n    SC.run(function() {\n      outer.renderToBuffer();\n    });\n\n    equals(middle.getPath('childViews.length'), 1);\n\n    SC.run(function() {\n      middle.rerender();\n    });\n\n    equals(middle.getPath('childViews.length'), 1);\n\n  });\n\n})();\n\n});");spade.register("sproutcore-views/~tests/views/view/class_name_bindings_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore Views\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nrequire('sproutcore-views/views/view');\n\nmodule(\"SC.View - Class Name Bindings\");\n\ntest(\"should apply bound class names to the element\", function() {\n  var view = SC.View.create({\n    classNameBindings: ['priority', 'isUrgent', 'isClassified:classified', 'canIgnore'],\n\n    priority: 'high',\n    isUrgent: true,\n    isClassified: true,\n    canIgnore: false\n  });\n\n  view.createElement();\n  ok(view.$().hasClass('high'), \"adds string values as class name\");\n  ok(view.$().hasClass('is-urgent'), \"adds true Boolean values by dasherizing\");\n  ok(view.$().hasClass('classified'), \"supports customizing class name for Boolean values\");\n  ok(!view.$().hasClass('can-ignore'), \"does not add false Boolean values as class\");\n});\n\ntest(\"should add, remove, or change class names if changed after element is created\", function() {\n  var view = SC.View.create({\n    classNameBindings: ['priority', 'isUrgent', 'canIgnore'],\n\n    priority: 'high',\n    isUrgent: true,\n    canIgnore: false\n  });\n\n  view.createElement();\n\n  set(view, 'priority', 'orange');\n  set(view, 'isUrgent', false);\n  set(view, 'canIgnore', true);\n\n  ok(view.$().hasClass('orange'), \"updates string values\");\n  ok(!view.$().hasClass('high'), \"removes old string value\");\n\n  ok(!view.$().hasClass('is-urgent', \"removes dasherized class when changed from true to false\"));\n  ok(view.$().hasClass('can-ignore'), \"adds dasherized class when changed from false to true\");\n});\n\n});");spade.register("sproutcore-views/~tests/views/view/create_child_view_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore Views\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nvar view, myViewClass ;\n\nmodule(\"SC.View#createChildView\", {\n  setup: function() {\n    view = SC.View.create();\n    myViewClass = SC.View.extend({ isMyView: YES, foo: 'bar' });\n  }\n});\n\ntest(\"should create view from class with any passed attributes\", function() {\n  var attrs = { foo: \"baz\" };\n  var newView = view.createChildView(myViewClass, attrs);\n  ok(get(newView, 'isMyView'), 'newView is instance of myView');\n  equals(get(newView, 'foo'), 'baz', 'view did get custom attributes');\n  ok(!attrs.parentView, \"the original attributes hash was not mutated\");\n});\n\ntest(\"should set newView.parentView to receiver\", function() {\n  var newView = view.createChildView(myViewClass) ;\n  equals(get(newView, 'parentView'), view, 'newView.parentView == view');\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/create_element_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore Views\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.View#createElement\");\n\ntest(\"returns the receiver\", function() {\n  var view = SC.View.create();\n  equals(view.createElement(), view, 'returns receiver');\n});\n\ntest(\"calls render and turns resultant string into element\", function() {\n  var view = SC.View.create({\n    tagName: 'span',\n\n    render: function(buffer) {\n      buffer.push(\"foo\");\n    }\n  });\n\n  equals(get(view, 'element'), null, 'precondition - has no element');\n  view.createElement();\n\n  var elem = get(view, 'element');\n  ok(elem, 'has element now');\n  equals(elem.innerHTML, 'foo', 'has innerHTML from context');\n  equals(elem.tagName.toString().toLowerCase(), 'span', 'has tagName from view');\n});\n\ntest(\"generated element include HTML from child views as well\", function() {\n  var view = SC.ContainerView.create({\n    childViews: [ SC.View.create({ elementId: \"foo\" })]\n  });\n\n  view.createElement();\n  ok(view.$('#foo').length, 'has element with child elementId');\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/destroy_element_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.View#destroyElement\");\n\ntest(\"it if has no element, does nothing\", function() {\n  var callCount = 0;\n  var view = SC.View.create({\n    willDestroyElement: function() { callCount++; }\n  });\n\n  ok(!get(view, 'element'), 'precond - does NOT have element');\n\n  SC.run(function() {\n    view.destroyElement();\n  });\n\n  equals(callCount, 0, 'did not invoke callback');\n});\n\ntest(\"if it has a element, calls willDestroyElement on receiver and child views then deletes the element\", function() {\n  var parentCount = 0, childCount = 0;\n\n  var view = SC.View.create({\n    willDestroyElement: function() { parentCount++; },\n    childViews: [SC.View.extend({\n      // no willDestroyElement here... make sure no errors are thrown\n      childViews: [SC.View.extend({\n        willDestroyElement: function() { childCount++; }\n      })]\n    })]\n  });\n\n  view.createElement();\n  ok(get(view, 'element'), 'precond - view has element');\n\n  SC.run(function() {\n    view.destroyElement();\n  });\n\n  equals(parentCount, 1, 'invoked destroy element on the parent');\n  equals(childCount, 1, 'invoked destroy element on the child');\n  ok(!get(view, 'element'), 'view no longer has element');\n  ok(!get(get(view, 'childViews').objectAt(0), 'element'), 'child no longer has an element');\n});\n\ntest(\"returns receiver\", function() {\n  var view = SC.View.create().createElement();\n  equals(view.destroyElement(), view, 'returns receiver');\n});\n\ntest(\"removes element from parentNode if in DOM\", function() {\n  var view = SC.View.create();\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(get(view, 'element'), 'precond - has element');\n\n  SC.run(function() {\n    view.destroyElement();\n  });\n\n  ok(!view.$().parent().length, 'element no longer in parent node');\n});\n\n});");spade.register("sproutcore-views/~tests/views/view/element_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.View#element\");\n\ntest(\"returns null if the view has no element and no parent view\", function() {\n  var view = SC.View.create() ;\n  equals(get(view, 'parentView'), null, 'precond - has no parentView');\n  equals(get(view, 'element'), null, 'has no element');\n});\n\ntest(\"returns null if the view has no element and parent view has no element\", function() {\n  var parent = SC.View.create({\n    childViews: [ SC.View.extend() ]\n  });\n  var view = parent.childViews[0];\n\n  equals(get(view, 'parentView'), parent, 'precond - has parent view');\n  equals(get(parent, 'element'), null, 'parentView has no element');\n  equals(get(view, 'element'), null, ' has no element');\n});\n\ntest(\"returns element if you set the value\", function() {\n  var view = SC.View.create();\n  equals(get(view, 'element'), null, 'precond- has no element');\n\n  var dom = document.createElement('div');\n  set(view, 'element', dom);\n\n  equals(get(view, 'element'), dom, 'now has set element');\n});\n\nvar parent, child, parentDom, childDom ;\n\nmodule(\"SC.View#element - autodiscovery\", {\n  setup: function() {\n\n    parent = SC.ContainerView.create({\n      childViews: [ SC.View.extend({\n        elementId: 'child-view'\n      }) ]\n    });\n\n    child = parent.childViews[0];\n\n    // setup parent/child dom\n    parentDom = SC.$(\"<div><div id='child-view'></div></div>\")[0];\n\n    // set parent element...\n    set(parent, 'element', parentDom);\n  },\n\n  teardown: function() {\n    parent = child = parentDom = childDom = null ;\n  }\n});\n\ntest(\"discovers element if has no element but parent view does have element\", function() {\n  equals(get(parent, 'element'), parentDom, 'precond - parent has element');\n  ok(parentDom.firstChild, 'precond - parentDom has first child');\n\n  equals(child.$().attr('id'), 'child-view', 'view discovered child');\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/init_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.View.create\");\n\ntest(\"registers view in the global views hash using layerId for event targeted\", function() {\n  var v = SC.View.create();\n  equals(SC.View.views[get(v, 'elementId')], v, 'registers view');\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/jquery_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore Views\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nvar view ;\nmodule(\"SC.View#$\", {\n  setup: function() {\n    view = SC.View.extend({\n      render: function(context, firstTime) {\n        context.push('<span></span>');\n      }\n    }).create();\n\n    SC.run(function() {\n      view.append();\n    });\n  },\n\n  teardown: function() {\n    view.destroy();\n  }\n});\n\ntest(\"returns an empty jQuery object if no element\", function() {\n  var view = SC.View.create();\n  ok(!get(view, 'element'), 'precond - should have no element');\n  equals(view.$().length, 0, 'should return empty jQuery object');\n  equals(view.$('span').length, 0, 'should return empty jQuery object even if filter passed');\n});\n\ntest(\"returns jQuery object selecting element if provided\", function() {\n  ok(get(view, 'element'), 'precond - should have element');\n\n  var jquery = view.$();\n  equals(jquery.length, 1, 'view.$() should have one element');\n  equals(jquery[0], get(view, 'element'), 'element should be element');\n});\n\ntest(\"returns jQuery object selecting element inside element if provided\", function() {\n  ok(get(view, 'element'), 'precond - should have element');\n\n  var jquery = view.$('span');\n  equals(jquery.length, 1, 'view.$() should have one element');\n  equals(jquery[0].parentNode, get(view, 'element'), 'element should be in element');\n});\n\ntest(\"returns empty jQuery object if filter passed that does not match item in parent\", function() {\n  ok(get(view, 'element'), 'precond - should have element');\n\n  var jquery = view.$('body'); // would normally work if not scoped to view\n  equals(jquery.length, 0, 'view.$(body) should have no elements');\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/nearest_view_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.View nearest view helpers\");\n\ntest(\"collectionView should return the nearest collection view\", function() {\n  var itemViewChild;\n\n  var view = SC.CollectionView.create({\n    content: [1, 2, 3],\n    isARealCollection: true,\n\n    itemViewClass: SC.View.extend({\n      render: function(buffer) {\n        this.appendChild(SC.View.create());\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  itemViewChild = view.get('childViews')[0].get('childViews')[0];\n  equals(itemViewChild.getPath('collectionView.isARealCollection'), true, \"finds collection view in the hierarchy\");\n});\n\ntest(\"itemView should return the nearest child of a collection view\", function() {\n  var itemViewChild;\n\n  var view = SC.CollectionView.create({\n    content: [1, 2, 3],\n\n    itemViewClass: SC.View.extend({\n      isAnItemView: true,\n\n      render: function(buffer) {\n        this.appendChild(SC.View.create());\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  itemViewChild = view.get('childViews')[0].get('childViews')[0];\n  equals(itemViewChild.getPath('itemView.isAnItemView'), true, \"finds item view in the hierarchy\");\n});\n\ntest(\"itemView should return the nearest child of a collection view\", function() {\n  var itemViewChild;\n\n  var view = SC.CollectionView.create({\n    content: [1, 2, 3],\n\n    itemViewClass: SC.View.extend({\n      isAnItemView: true,\n\n      render: function(buffer) {\n        this.appendChild(SC.View.create());\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  itemViewChild = view.get('childViews')[0].get('childViews')[0];\n  equals(itemViewChild.getPath('contentView.isAnItemView'), true, \"finds a view with a content property in the hierarchy\");\n});\n\n\n});");spade.register("sproutcore-views/~tests/views/view/remove_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\n// .......................................................\n// removeChild()\n//\n\nvar parent, child;\nmodule(\"SC.View#removeChild\", {\n  setup: function() {\n    parent = SC.View.create({ childViews: [SC.View] });\n    child = parent.childViews[0];\n  }\n});\n\ntest(\"returns receiver\", function() {\n  equals(parent.removeChild(child), parent, 'receiver');\n});\n\ntest(\"removes child from parent.childViews array\", function() {\n  ok(parent.childViews.indexOf(child)>=0, 'precond - has child in childViews array before remove');\n  parent.removeChild(child);\n  ok(parent.childViews.indexOf(child)<0, 'removed child');\n});\n\ntest(\"sets parentView property to null\", function() {\n  ok(get(child, 'parentView'), 'precond - has parentView');\n  parent.removeChild(child);\n  ok(!get(child, 'parentView'), 'parentView is now null');\n});\n\n// .......................................................\n// removeAllChildren()\n//\nvar view;\nmodule(\"SC.View#removeAllChildren\", {\n setup: function() {\n  view = SC.View.create({\n    childViews: [SC.View, SC.View, SC.View]\n  });\n }\n});\n\ntest(\"removes all child views\", function() {\n  equals(view.childViews.length, 3, 'precond - has child views');\n\n  view.removeAllChildren();\n  equals(view.childViews.length, 0, 'removed all children');\n});\n\ntest(\"returns receiver\", function() {\n  equals(view.removeAllChildren(), view, 'receiver');\n});\n\n// .......................................................\n// removeFromParent()\n//\nmodule(\"SC.View#removeFromParent\");\n\ntest(\"removes view from parent view\", function() {\n  var parent = SC.ContainerView.create({ childViews: [SC.View] });\n  var child = parent.childViews[0];\n  ok(get(child, 'parentView'), 'precond - has parentView');\n\n  parent.createElement();\n\n  ok(parent.$('div').length, \"precond - has a child DOM element\");\n\n  child.removeFromParent();\n  ok(!get(child, 'parentView'), 'no longer has parentView');\n  ok(parent.childViews.indexOf(child)<0, 'no longer in parent childViews');\n  equals(parent.$('div').length, 0, \"removes DOM element from parent\");\n});\n\ntest(\"returns receiver\", function() {\n  equals(child.removeFromParent(), child, 'receiver');\n});\n\ntest(\"does nothing if not in parentView\", function() {\n  var callCount = 0;\n  var child = SC.View.create();\n\n  // monkey patch for testing...\n  ok(!get(child, 'parentView'), 'precond - has no parent');\n\n  child.removeFromParent();\n});\n\n\n\n\n\n});");spade.register("sproutcore-views/~tests/views/view/render_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*global module test equals context ok same */\n\n\nvar set = SC.set, get = SC.get;\n\n// .......................................................\n//  render()\n//\nmodule(\"SC.View#render\");\n\ntest(\"default implementation does not render child views\", function() {\n\n  var rendered = 0, updated = 0, parentRendered = 0, parentUpdated = 0 ;\n  var view = SC.ContainerView.create({\n    childViews: [\"child\"],\n\n    render: function(buffer) {\n      parentRendered++;\n      this._super(buffer);\n    },\n\n    child: SC.View.create({\n      render: function(buffer) {\n        rendered++;\n        this._super(buffer);\n      }\n    })\n  });\n\n  view.createElement();\n  equals(rendered, 1, 'rendered the child once');\n  equals(parentRendered, 1);\n  equals(view.$('div').length, 1);\n\n});\n\ntest(\"should invoke renderChildViews if layer is destroyed then re-rendered\", function() {\n\n  var rendered = 0, parentRendered = 0, parentUpdated = 0 ;\n  var view = SC.ContainerView.create({\n    childViews: [\"child\"],\n\n    render: function(buffer) {\n      parentRendered++;\n      this._super(buffer);\n    },\n\n    child: SC.View.create({\n      render: function(buffer) {\n        rendered++;\n        this._super(buffer);\n      }\n    })\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  equals(rendered, 1, 'rendered the child once');\n  equals(parentRendered, 1);\n  equals(view.$('div').length, 1);\n\n  SC.run(function() {\n    view.rerender();\n  });\n\n  equals(rendered, 2, 'rendered the child twice');\n  equals(parentRendered, 2);\n  equals(view.$('div').length, 1);\n\n  view.destroy();\n});\n\ntest(\"should render child views with a different tagName\", function() {\n  var rendered = 0, parentRendered = 0, parentUpdated = 0 ;\n\n  var view = SC.ContainerView.create({\n    childViews: [\"child\"],\n\n    child: SC.View.create({\n      tagName: 'aside'\n    })\n  });\n\n  view.createElement();\n  equals(view.$('aside').length, 1);\n});\n\ntest(\"should hide views when isVisible is false\", function() {\n  var view = SC.View.create({\n    isVisible: false\n  });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':hidden'), \"the view is hidden\");\n\n  set(view, 'isVisible', true);\n  ok(view.$().is(':visible'), \"the view is visible\");\n  view.remove();\n});\n\ntest(\"should hide element if isVisible is false before element is created\", function() {\n  var view = SC.View.create({\n    isVisible: false\n  });\n\n  ok(!get(view, 'isVisible'), \"precond - view is not visible\");\n\n  set(view, 'template', function() { return \"foo\"; });\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':hidden'), \"should be hidden\");\n\n  view.remove();\n  set(view, 'isVisible', true);\n\n  SC.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':visible'), \"view should be visible\");\n\n  SC.run(function() {\n    view.remove();\n  });\n});\n\ntest(\"should add sc-view to views\", function() {\n  var view = SC.View.create();\n\n  view.createElement();\n  ok(view.$().hasClass('sc-view'), \"the view has sc-view\");\n});\n\ntest(\"should not add role attribute unless one is specified\", function() {\n  var view = SC.View.create();\n\n  view.createElement();\n  ok(view.$().attr('role') === undefined, \"does not have a role attribute\");\n});\n\n});");spade.register("sproutcore-views/~tests/views/view/template_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:   SproutCore - JavaScript Application Framework\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar set = SC.set, get = SC.get;\n\nmodule(\"SC.View - Template Functionality\");\n\ntest(\"should call the function of the associated template\", function() {\n  var view;\n\n  view = SC.View.create({\n    templateName: 'test_template',\n\n    templates: SC.Object.create({\n      test_template: function(dataSource) {\n        return \"<h1 id='twas-called'>template was called</h1>\";\n      }\n    })\n  });\n\n  view.createElement();\n\n  ok(view.$('#twas-called').length, \"the named template was called\");\n});\n\ntest(\"should call the function of the associated template with itself as the context\", function() {\n  var view;\n\n  view = SC.View.create({\n    templateName: 'test_template',\n\n    personName: \"Tom DAAAALE\",\n\n    templates: SC.Object.create({\n      test_template: function(dataSource) {\n        return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\";\n      }\n    })\n  });\n\n  view.createElement();\n\n  equals(\"template was called for Tom DAAAALE\", view.$('#twas-called').text(), \"the named template was called with the view as the data source\");\n});\n\ntest(\"should fall back to defaultTemplate if neither template nor templateName are provided\", function() {\n  var View, view;\n\n  View = SC.View.extend({\n    defaultTemplate: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create({\n    personName: \"Tom DAAAALE\"\n  });\n\n  view.createElement();\n\n  equals(\"template was called for Tom DAAAALE\", view.$('#twas-called').text(), \"the named template was called with the view as the data source\");\n});\n\ntest(\"should not use defaultTemplate if template is provided\", function() {\n  var View, view;\n\n  View = SC.View.extend({\n    template:  function() { return \"foo\"; },\n    defaultTemplate: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create();\n  view.createElement();\n\n  equals(\"foo\", view.$().text(), \"default template was not printed\");\n});\n\ntest(\"should not use defaultTemplate if template is provided\", function() {\n  var View, view;\n\n  View = SC.View.extend({\n    templateName: 'foobar',\n    templates: SC.Object.create({\n      foobar: function() { return \"foo\"; }\n    }),\n    defaultTemplate: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create();\n  view.createElement();\n\n  equals(\"foo\", view.$().text(), \"default template was not printed\");\n});\n\n\ntest(\"should render an empty element if no template is specified\", function() {\n  var view;\n  view = SC.View.create();\n  view.createElement();\n\n  equals(view.$().html(), '', \"view div should be empty\");\n});\n\n});");spade.register("sproutcore-views/~tests/views/view/view_lifecycle_test", "(function(require, exports, __module, ARGV, ENV, __filename){var view;\n\nmodule(\"views/view/view_lifecycle_test - pre-render\", {\n  setup: function() {\n\n  },\n\n  teardown: function() {\n    if (view) { view.destroy(); }\n  }\n});\n\nfunction tmpl(str) {\n  return function(context, options) {\n    options.data.buffer.push(str);\n  }\n}\n\ntest(\"should create and append a DOM element after bindings have synced\", function() {\n  window.ViewTest = {};\n\n  SC.run(function() {\n    ViewTest.fakeController = SC.Object.create({\n      fakeThing: 'controllerPropertyValue'\n    });\n\n    view = SC.View.create({\n      fooBinding: 'ViewTest.fakeController.fakeThing',\n\n      render: function(buffer) {\n        buffer.push(this.get('foo'));\n      }\n    });\n\n    ok(!view.get('element'), \"precond - does not have an element before appending\");\n\n    view.append();\n  });\n\n  equals(view.$().text(), 'controllerPropertyValue', \"renders and appends after bindings have synced\");\n  window.ViewTest = undefined;\n});\n\ntest(\"should throw an exception if trying to append a child before rendering has begun\", function() {\n  SC.run(function() {\n    view = SC.View.create();\n  });\n\n  raises(function() {\n    view.appendChild(SC.View, {});\n  }, null, \"throws an error when calling appendChild()\");\n});\n\ntest(\"should not affect rendering if rerender is called before initial render happens\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl(\"Rerender me!\")\n    });\n\n    view.rerender();\n    view.append();\n  });\n\n  equals(view.$().text(), \"Rerender me!\", \"renders correctly if rerender is called first\");\n});\n\ntest(\"should not affect rendering if destroyElement is called before initial render happens\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl(\"Don't destroy me!\")\n    });\n\n    view.destroyElement();\n    view.append();\n  });\n\n  equals(view.$().text(), \"Don't destroy me!\", \"renders correctly if destroyElement is called first\");\n});\n\nmodule(\"views/view/view_lifecycle_test - in render\", {\n  setup: function() {\n\n  },\n\n  teardown: function() {\n    if (view) { view.destroy(); }\n  }\n});\n\ntest(\"appendChild should work inside a template\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: function(context, options) {\n        var buffer = options.data.buffer;\n\n        buffer.push(\"<h1>Hi!</h1>\");\n\n        options.data.view.appendChild(SC.View, {\n          template: tmpl(\"Inception reached\")\n        });\n\n        buffer.push(\"<div class='footer'>Wait for the kick</div>\");\n      }\n    });\n\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  ok(view.$('h1').length == 1 && view.$('div').length == 2,\n     \"The appended child is visible\");\n});\n\ntest(\"rerender should work inside a template\", function() {\n  SC.run(function() {\n    var renderCount = 0;\n    view = SC.View.create({\n      template: function(context, options) {\n        var view = options.data.view;\n\n        var child1 = view.appendChild(SC.View, {\n          template: function(context, options) {\n            renderCount++;\n            options.data.buffer.push(String(renderCount));\n          }\n        });\n\n        var child2 = view.appendChild(SC.View, {\n          template: function(context, options) {\n            options.data.buffer.push(\"Inside child2\");\n            child1.rerender();\n          }\n        });\n      }\n    });\n\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  ok(view.$('div:contains(2), div:contains(Inside child2').length == 2,\n     \"Rerendering a view causes it to rerender\");\n});\n\nmodule(\"views/view/view_lifecycle_test - in DOM\", {\n  teardown: function() {\n    if (view) { view.destroy(); }\n  }\n});\n\ntest(\"should throw an exception when calling appendChild when DOM element exists\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl(\"Wait for the kick\")\n    });\n\n    view.append();\n  });\n\n  raises(function() {\n    view.appendChild(SC.View, {\n      template: tmpl(\"Ah ah ah! You didn't say the magic word!\")\n    });\n  }, null, \"throws an exception when calling appendChild after element is created\");\n});\n\ntest(\"should replace DOM representation if rerender() is called after element is created\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: function(context, options) {\n        var buffer = options.data.buffer;\n        var value = context.get('shape');\n\n        buffer.push(\"Do not taunt happy fun \"+value);\n      },\n\n      shape: 'sphere'\n    });\n\n    view.append();\n  });\n\n  equals(view.$().text(), \"Do not taunt happy fun sphere\", \"precond - creates DOM element\");\n\n  view.set('shape', 'ball');\n  SC.run(function() {\n    view.rerender();\n  });\n\n  equals(view.$().text(), \"Do not taunt happy fun ball\", \"rerenders DOM element when rerender() is called\");\n});\n\ntest(\"should destroy DOM representation when destroyElement is called\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl(\"Don't fear the reaper\")\n    });\n\n    view.append();\n  });\n\n  ok(view.get('element'), \"precond - generates a DOM element\");\n\n  SC.run(function() {\n    view.destroyElement();\n  });\n\n  ok(!view.get('element'), \"destroys view when destroyElement() is called\");\n});\n\ntest(\"should destroy DOM representation when destroy is called\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl(\"<div id='warning'>Don't fear the reaper</div>\")\n    });\n\n    view.append();\n  });\n\n  ok(view.get('element'), \"precond - generates a DOM element\");\n\n  SC.run(function() {\n    view.destroy();\n  });\n\n  ok(SC.$('#warning').length === 0, \"destroys element when destroy() is called\");\n});\n\ntest(\"should throw an exception if trying to append an element that is already in DOM\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl('Broseidon, King of the Brocean')\n    });\n\n    view.append();\n  });\n\n  ok(view.get('element'), \"precond - creates DOM element\");\n\n  raises(function() {\n    SC.run(function() {\n      view.append();\n    });\n  }, null, \"raises an exception on second append\");\n});\n\nmodule(\"views/view/view_lifecycle_test - destroyed\");\n\ntest(\"should throw an exception when calling appendChild after view is destroyed\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl(\"Wait for the kick\")\n    });\n\n    view.append();\n  });\n\n  SC.run(function() {\n    view.destroy();\n  });\n\n  raises(function() {\n    view.appendChild(SC.View, {\n      template: tmpl(\"Ah ah ah! You didn't say the magic word!\")\n    });\n  }, null, \"throws an exception when calling appendChild\");\n});\n\ntest(\"should throw an exception when rerender is called after view is destroyed\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl('foo')\n    });\n\n    view.append();\n  });\n\n  SC.run(function() {\n    view.destroy();\n  });\n\n  raises(function() {\n    view.rerender();\n  }, null, \"throws an exception when calling appendChild\");\n});\n\ntest(\"should throw an exception when rerender is called after view is destroyed\", function() {\n  SC.run(function() {\n    view = SC.View.create({\n      template: tmpl('foo')\n    });\n\n    view.append();\n  });\n\n  SC.run(function() {\n    view.destroy();\n  });\n\n  raises(function() {\n    view.destroyElement();\n  }, null, \"throws an exception when calling appendChild\");\n});\n\n\n});");