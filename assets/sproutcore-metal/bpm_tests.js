/* ===========================================================================
   BPM Combined Asset File
   MANIFEST: sproutcore-metal (2.0.beta.3)
   This file is generated automatically by the bpm (http://www.bpmjs.org)
   =========================================================================*/

spade.register("sproutcore-metal/~tests/accessors/getPath_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Foo raises $foo */\n\n\nvar obj;\nmodule('SC.getPath', {\n  setup: function() {\n    obj = { \n      foo: { \n        bar: { \n          baz: { biff: 'BIFF' } \n        }\n      }\n      \n    };\n    \n    Foo = {\n      bar: {\n        baz: { biff: 'FooBiff' }\n      }\n    };\n    \n    $foo = {\n      bar: {\n        baz: { biff: '$FOOBIFF' }\n      }\n    };\n  }, \n  \n  teardown: function() {\n    obj = null;\n    Foo = null;\n    $foo = null;\n  }\n});\n\n// ..........................................................\n// LOCAL PATHS\n// \n\ntest('[obj, foo] -> obj.foo', function() {\n  same(SC.getPath(obj, 'foo'), obj.foo);\n});\n\ntest('[obj, *] -> obj', function() {\n  same(SC.getPath(obj, '*'), obj);\n});\n\ntest('[obj, foo.bar] -> obj.foo.bar', function() {\n  same(SC.getPath(obj, 'foo.bar'), obj.foo.bar);\n});\n\ntest('[obj, foo.*] -> obj.foo', function() {\n  same(SC.getPath(obj, 'foo.*'), obj.foo);\n});\n\ntest('[obj, foo.*.baz] -> obj.foo.baz', function() {\n  same(SC.getPath(obj, 'foo.*.baz'), obj.foo.baz);\n});\n\n\ntest('[obj, foo*bar] -> obj.foo.bar', function() {\n  same(SC.getPath(obj, 'foo*bar'), obj.foo.bar);\n});\n\ntest('[obj, foo*bar.*] -> obj.foo.bar', function() {\n  same(SC.getPath(obj, 'foo*bar.*'), obj.foo.bar);\n});\n\ntest('[obj, foo.bar*baz.biff] -> obj.foo.bar.baz.biff', function() {\n  same(SC.getPath(obj, 'foo.bar*baz.biff'), obj.foo.bar.baz.biff);\n});\n\ntest('[obj, foo.bar*baz.biff] -> obj.foo.bar.baz.biff', function() {\n  same(SC.getPath(obj, 'foo.bar*baz.biff'), obj.foo.bar.baz.biff);\n});\n\n\ntest('[obj, this.foo] -> obj.foo', function() {\n  same(SC.getPath(obj, 'this.foo'), obj.foo);\n});\n\ntest('[obj, this.foo.bar] -> obj.foo.bar', function() {\n  same(SC.getPath(obj, 'this.foo.bar'), obj.foo.bar);\n});\n\ntest('[obj, .foo.bar] -> obj.foo.bar', function() {\n  same(SC.getPath(obj, 'this.foo.bar'), obj.foo.bar);\n});\n\ntest('[obj, *foo.bar] -> obj.foo.bar', function() {\n  same(SC.getPath(obj, 'this.foo.bar'), obj.foo.bar);\n});\n\ntest('[obj, this.foo*bar] -> obj.foo.bar', function() {\n  same(SC.getPath(obj, 'this.foo*bar'), obj.foo.bar);\n});\n\ntest('[obj, this.foo.bar*baz.biff] -> obj.foo.bar.baz.biff', function() {\n  same(SC.getPath(obj, 'this.foo.bar*baz.biff'), obj.foo.bar.baz.biff);\n});\n\ntest('[obj, this.foo.bar*baz.biff] -> obj.foo.bar.baz.biff', function() {\n  same(SC.getPath(obj, 'foo.bar*baz.biff'), obj.foo.bar.baz.biff);\n});\n\ntest('[obj, this.Foo.bar] -> (null)', function() {\n  same(SC.getPath(obj, 'this.Foo.bar'), undefined);\n});\n\n// ..........................................................\n// GLOBAL PATHS\n// \n\ntest('[obj, Foo] -> undefined', function() {\n  same(SC.getPath(obj, 'Foo'), undefined);\n});\n\ntest('[obj, Foo.bar] -> Foo.bar', function() {\n  same(SC.getPath(obj, 'Foo.bar'), Foo.bar);\n});\n\ntest('[obj, Foo*bar] -> Foo.bar', function() {\n  same(SC.getPath(obj, 'Foo*bar'), Foo.bar);\n});\n\ntest('[obj, Foo.bar*baz.biff] -> Foo.bar.baz.biff', function() {\n  same(SC.getPath(obj, 'Foo.bar*baz.biff'), Foo.bar.baz.biff);\n});\n\ntest('[obj, Foo.bar.baz*biff] -> Foo.bar.baz.biff', function() {\n  same(SC.getPath(obj, 'Foo.bar.baz*biff'), Foo.bar.baz.biff);\n});\n\ntest('[obj, $foo.bar.baz] -> $foo.bar.baz', function() {\n  same(SC.getPath(obj, '$foo.bar.baz'), $foo.bar.baz);\n});\n\n// ..........................................................\n// NO TARGET\n// \n\ntest('[null, Foo] -> Foo', function() {\n  same(SC.getPath('Foo'), Foo);\n});\n\ntest('[null, Foo.bar] -> Foo.bar', function() {\n  same(SC.getPath('Foo.bar'), Foo.bar);\n});\n\ntest('[null, Foo*bar] -> Foo.bar', function() {\n  same(SC.getPath('Foo*bar'), Foo.bar);\n});\n\ntest('[null, Foo.bar*baz.biff] -> Foo.bar.baz.biff', function() {\n  same(SC.getPath('Foo.bar*baz.biff'), Foo.bar.baz.biff);\n});\n\ntest('[null, Foo.bar.baz*biff] -> Foo.bar.baz.biff', function() {\n  same(SC.getPath('Foo.bar.baz*biff'), Foo.bar.baz.biff);\n});\n\n});");spade.register("sproutcore-metal/~tests/accessors/get_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-metal/~tests/props_helper');\n\nmodule('SC.get');\n\ntest('should get arbitrary properties on an object', function() {\n  var obj = {\n    string: 'string',\n    number: 23,\n    boolTrue: true,\n    boolFalse: false,\n    nullValue: null\n  };\n  \n  for(var key in obj) {\n    if (!obj.hasOwnProperty(key)) continue;\n    equals(SC.get(obj, key), obj[key], key);\n  }\n  \n});\n\ntest('should call unknownProperty if defined and value is undefined', function() {\n\n  var obj = {\n    count: 0,\n    unknownProperty: function(key) {\n      equals(key, 'foo', 'should pass key');\n      this.count++;\n      return 'FOO';\n    }\n  };\n\n  equals(SC.get(obj, 'foo'), 'FOO', 'should return value from unknown');\n  equals(obj.count, 1, 'should have invoked');\n});\n\ntestBoth(\"should call unknownProperty on watched values if the value is undefined\", function(get, set) {\n  var obj = {\n    count: 0,\n    unknownProperty: function(key) {\n      equals(key, 'foo', \"should pass key\");\n      this.count++;\n      return \"FOO\";\n    }\n  };\n\n  var count = 0;\n  SC.addObserver(obj, 'foo', function() {\n    count++;\n  });\n\n  equals(get(obj, 'foo'), 'FOO', 'should return value from unknown');\n});\n\n// ..........................................................\n// BUGS\n// \n\ntest('(regression) watched properties on unmodified inherited objects should still return their original value', function() {\n\n  var MyMixin = SC.Mixin.create({\n    someProperty: 'foo',\n    propertyDidChange: SC.observer(function() {\n      // NOTHING TO DO\n    }, 'someProperty')\n  });\n\n  var baseObject = MyMixin.apply({});\n  var theRealObject = SC.create(baseObject);\n  \n  equals(SC.get(theRealObject, 'someProperty'), 'foo', 'should return the set value, not false');  \n});\n\n\n});");spade.register("sproutcore-metal/~tests/accessors/normalizePath_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.normalizePath');\n\ntest('foo -> foo', function() {\n  equals(SC.normalizePath('foo'), 'foo');\n});\n\ntest('foo.bar -> foo.bar', function() {\n  equals(SC.normalizePath('foo.bar'), 'foo.bar');\n});\n\ntest('this.foo.bar -> this.foo.bar', function() {\n  equals(SC.normalizePath('this.foo.bar'), 'this.foo.bar');\n});\n\ntest('.foo.bar -> this.foo.bar', function() {\n  equals(SC.normalizePath('.foo.bar'), 'this.foo.bar');\n});\n\ntest('*foo.bar -> this.foo.bar', function() {\n  equals(SC.normalizePath('*foo.bar'), 'this.foo.bar');\n});\n\n\n});");spade.register("sproutcore-metal/~tests/accessors/normalizeTuple_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Foo raises $foo */\n\n\nvar obj;\nmodule('SC.normalizeTuple', {\n  setup: function() {\n    obj = { \n      foo: { \n        bar: { \n          baz: {} \n        }\n      }\n    };\n    \n    Foo = {\n      bar: {\n        baz: {}\n      }\n    };\n    \n    $foo = {\n      bar: {\n        baz: {}\n      }\n    };\n  }, \n  \n  teardown: function() {\n    obj = null;\n    Foo = null;\n  }\n});\n\n// ..........................................................\n// LOCAL PATHS\n// \n\ntest('[obj, foo] -> [obj, foo]', function() {\n  same(SC.normalizeTuple(obj, 'foo'), [obj, 'foo']);\n});\n\ntest('[obj, *] -> [obj, *]', function() {\n  same(SC.normalizeTuple(obj, '*'), [obj, '*']);\n});\n\ntest('[obj, foo.bar] -> [obj, foo.bar]', function() {\n  same(SC.normalizeTuple(obj, 'foo.bar'), [obj, 'foo.bar']);\n});\n\ntest('[obj, foo.*] -> [obj, foo.*]', function() {\n  same(SC.normalizeTuple(obj, 'foo.*'), [obj, 'foo.*']);\n});\n\ntest('[obj, foo.*.baz] -> [obj, foo.*.baz]', function() {\n  same(SC.normalizeTuple(obj, 'foo.*.baz'), [obj, 'foo.*.baz']);\n});\n\n\ntest('[obj, foo*bar] -> [obj.foo, bar]', function() {\n  same(SC.normalizeTuple(obj, 'foo*bar'), [obj.foo, 'bar']);\n});\n\ntest('[obj, foo*bar.*] -> [obj.foo, bar.*]', function() {\n  same(SC.normalizeTuple(obj, 'foo*bar.*'), [obj.foo, 'bar.*']);\n});\n\ntest('[obj, foo.bar*baz.biff] -> [obj.foo.bar, baz.biff]', function() {\n  same(SC.normalizeTuple(obj, 'foo.bar*baz.biff'), [obj.foo.bar, 'baz.biff']);\n});\n\ntest('[obj, foo.bar*baz.biff] -> [obj.foo.bar, baz.biff]', function() {\n  same(SC.normalizeTuple(obj, 'foo.bar*baz.biff'), [obj.foo.bar, 'baz.biff']);\n});\n\n\ntest('[obj, this.foo] -> [obj, foo]', function() {\n  same(SC.normalizeTuple(obj, 'this.foo'), [obj, 'foo']);\n});\n\ntest('[obj, this.foo.bar] -> [obj, foo.bar]', function() {\n  same(SC.normalizeTuple(obj, 'this.foo.bar'), [obj, 'foo.bar']);\n});\n\ntest('[obj, .foo.bar] -> [obj, foo.bar]', function() {\n  same(SC.normalizeTuple(obj, 'this.foo.bar'), [obj, 'foo.bar']);\n});\n\ntest('[obj, *foo.bar] -> [obj, foo.bar]', function() {\n  same(SC.normalizeTuple(obj, 'this.foo.bar'), [obj, 'foo.bar']);\n});\n\ntest('[obj, this.foo*bar] -> [obj.foo, bar]', function() {\n  same(SC.normalizeTuple(obj, 'this.foo*bar'), [obj.foo, 'bar']);\n});\n\ntest('[obj, this.foo.bar*baz.biff] -> [obj.foo.bar, baz.biff]', function() {\n  same(SC.normalizeTuple(obj, 'this.foo.bar*baz.biff'), [obj.foo.bar, 'baz.biff']);\n});\n\ntest('[obj, this.foo.bar*baz.biff] -> [obj.foo.bar, baz.biff]', function() {\n  same(SC.normalizeTuple(obj, 'foo.bar*baz.biff'), [obj.foo.bar, 'baz.biff']);\n});\n\ntest('[obj, this.Foo.bar] -> [obj, Foo.bar]', function() {\n  same(SC.normalizeTuple(obj, 'this.Foo.bar'), [obj, 'Foo.bar']);\n});\n\n// ..........................................................\n// GLOBAL PATHS\n// \n\ntest('[obj, Foo] -> [obj, Foo]', function() {\n  same(SC.normalizeTuple(obj, 'Foo'), [obj, 'Foo']);\n});\n\ntest('[obj, Foo.bar] -> [Foo, bar]', function() {\n  same(SC.normalizeTuple(obj, 'Foo.bar'), [Foo, 'bar']);\n});\n\ntest('[obj, Foo*bar] -> [Foo, bar]', function() {\n  same(SC.normalizeTuple(obj, 'Foo*bar'), [Foo, 'bar']);\n});\n\ntest('[obj, Foo.bar*baz.biff] -> [Foo.bar, baz.biff]', function() {\n  same(SC.normalizeTuple(obj, 'Foo.bar*baz.biff'), [Foo.bar, 'baz.biff']);\n});\n\ntest('[obj, Foo.bar.baz*biff] -> [Foo.bar.baz, biff]', function() {\n  same(SC.normalizeTuple(obj, 'Foo.bar.baz*biff'), [Foo.bar.baz, 'biff']);\n});\n\ntest('[obj, $foo.bar.baz] -> [$foo, bar.baz]', function() {\n  same(SC.normalizeTuple(obj, '$foo.bar.baz'), [$foo, 'bar.baz']);\n});\n\n// ..........................................................\n// NO TARGET\n// \n\ntest('[null, Foo] -> EXCEPTION', function() {\n  raises(function() {\n    SC.normalizeTuple(null, 'Foo');\n  }, Error);\n});\n\ntest('[null, Foo.bar] -> [Foo, bar]', function() {\n  same(SC.normalizeTuple(null, 'Foo.bar'), [Foo, 'bar']);\n});\n\ntest('[null, Foo*bar] -> [Foo, bar]', function() {\n  same(SC.normalizeTuple(null, 'Foo*bar'), [Foo, 'bar']);\n});\n\ntest('[null, Foo.bar*baz.biff] -> [Foo.bar, baz.biff]', function() {\n  same(SC.normalizeTuple(null, 'Foo.bar*baz.biff'), [Foo.bar, 'baz.biff']);\n});\n\ntest('[null, Foo.bar.baz*biff] -> [Foo.bar.baz, biff]', function() {\n  same(SC.normalizeTuple(null, 'Foo.bar.baz*biff'), [Foo.bar.baz, 'biff']);\n});\n\n});");spade.register("sproutcore-metal/~tests/accessors/setPath_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals Foo raises $foo */\n\n\nvar obj;\nmodule('SC.setPath', {\n  setup: function() {\n    obj = { \n      foo: { \n        bar: { \n          baz: { biff: 'BIFF' } \n        }\n      }\n      \n    };\n    \n    Foo = {\n      bar: {\n        baz: { biff: 'FooBiff' }\n      }\n    };\n    \n    $foo = {\n      bar: {\n        baz: { biff: '$FOOBIFF' }\n      }\n    };\n  }, \n  \n  teardown: function() {\n    obj = null;\n    Foo = null;\n    $foo = null;\n  }\n});\n\n// ..........................................................\n// LOCAL PATHS\n// \n\ntest('[obj, foo] -> obj.foo', function() {\n  SC.setPath(obj, 'foo', \"BAM\");\n  equals(SC.getPath(obj, 'foo'), \"BAM\");\n});\n\ntest('[obj, *] -> EXCEPTION [cannot set *]', function() {\n  raises(function() {\n    SC.setPath(obj, '*', \"BAM\");\n  }, Error);\n});\n\ntest('[obj, foo.bar] -> obj.foo.bar', function() {\n  SC.setPath(obj, 'foo.bar', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar'), \"BAM\");\n});\n\ntest('[obj, foo.*] -> EXCEPTION', function() {\n  raises(function() {\n    SC.setPath(obj, 'foo.*', \"BAM\");\n  }, Error);\n});\n\ntest('[obj, foo.*.baz] -> obj.foo.baz', function() {\n  SC.setPath(obj, 'foo.*.baz', \"BAM\");\n  equals(SC.getPath(obj, 'foo.baz'), \"BAM\");\n});\n\n\ntest('[obj, foo*bar] -> obj.foo.bar', function() {\n  SC.setPath(obj, 'foo*bar', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar'), \"BAM\");\n});\n\ntest('[obj, foo*bar.*] -> EXCEPTION', function() {\n  raises(function() {\n    SC.setPath(obj, 'foo.*.baz.*', \"BAM\");\n  }, Error);\n});\n\ntest('[obj, foo.bar*baz.biff] -> obj.foo.bar.baz.biff', function() {\n  SC.setPath(obj, 'foo.bar*baz.biff', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar.baz.biff'), \"BAM\");\n});\n\ntest('[obj, this.foo] -> obj.foo', function() {\n  SC.setPath(obj, 'this.foo', \"BAM\");\n  equals(SC.getPath(obj, 'foo'), \"BAM\");\n});\n\ntest('[obj, this.foo.bar] -> obj.foo.bar', function() {\n  SC.setPath(obj, 'this.foo.bar', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar'), \"BAM\");\n});\n\ntest('[obj, .foo.bar] -> obj.foo.bar', function() {\n  SC.setPath(obj, '.foo.bar', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar'), \"BAM\");\n});\n\ntest('[obj, *foo.bar] -> obj.foo.bar', function() {\n  SC.setPath(obj, '*foo.bar', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar'), \"BAM\");\n});\n\ntest('[obj, this.foo*bar] -> obj.foo.bar', function() {\n  SC.setPath(obj, 'this.foo*bar', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar'), \"BAM\");\n});\n\ntest('[obj, this.foo.bar*baz.biff] -> obj.foo.bar.baz.biff', function() {\n  SC.setPath(obj, 'this.foo.bar*baz.biff', \"BAM\");\n  equals(SC.getPath(obj, 'foo.bar.baz.biff'), \"BAM\");\n});\n\n// ..........................................................\n// GLOBAL PATHS\n// \n\ntest('[obj, Foo] -> EXCEPTION', function() {\n  raises(function() {\n    SC.setPath(obj, 'Foo', \"BAM\");\n  }, Error);\n});\n\ntest('[obj, foo.baz.bat] -> EXCEPTION', function() {\n  raises(function() {\n    SC.setPath(obj, 'foo.baz.bat', \"BAM\");\n  }, Error);\n});\n\ntest('[obj, foo.baz.bat] -> EXCEPTION', function() {\n  SC.trySetPath(obj, 'foo.baz.bat', \"BAM\");\n  // does not raise\n});\n\ntest('[obj, Foo.bar] -> Foo.bar', function() {\n  SC.setPath(obj, 'Foo.bar', \"BAM\");\n  equals(SC.getPath(Foo, 'bar'), \"BAM\");\n});\n\ntest('[obj, Foo*bar] -> Foo.bar', function() {\n  SC.setPath(obj, 'Foo*bar', \"BAM\");\n  equals(SC.getPath(Foo, 'bar'), \"BAM\");\n});\n\ntest('[obj, Foo.bar*baz.biff] -> Foo.bar.baz.biff', function() {\n  SC.setPath(obj, 'Foo.bar*baz.biff', \"BAM\");\n  equals(SC.getPath(Foo, 'bar.baz.biff'), \"BAM\");\n});\n\ntest('[obj, Foo.bar.baz*biff] -> Foo.bar.baz.biff', function() {\n  SC.setPath(obj, 'Foo.bar.baz*biff', \"BAM\");\n  equals(SC.getPath(Foo, 'bar.baz.biff'), \"BAM\");\n});\n\ntest('[obj, $foo.bar.baz] -> $foo.bar.baz', function() {\n  SC.setPath(obj, '$foo.bar.baz', \"BAM\");\n  equals(SC.getPath($foo, 'bar.baz'), \"BAM\");\n});\n\n\n\n// ..........................................................\n// NO TARGET\n// \n\ntest('[null, Foo.bar] -> Foo.bar', function() {\n  SC.setPath(null, 'Foo.bar', \"BAM\");\n  equals(SC.getPath(Foo, 'bar'), \"BAM\");\n});\n\ntest('[null, Foo*bar] -> Foo.bar', function() {\n  SC.setPath(null, 'Foo*bar', \"BAM\");\n  equals(SC.getPath(Foo, 'bar'), \"BAM\");\n});\n\ntest('[null, Foo.bar*baz.biff] -> Foo.bar.baz.biff', function() {\n  SC.setPath(null, 'Foo.bar*baz.biff', \"BAM\");\n  equals(SC.getPath(Foo, 'bar.baz.biff'), \"BAM\");\n});\n\ntest('[null, Foo.bar.baz*biff] -> Foo.bar.baz.biff', function() {\n  SC.setPath(null, 'Foo.bar.baz*biff', \"BAM\");\n  equals(SC.getPath(Foo, 'bar.baz.biff'), \"BAM\");\n});\n\n});");spade.register("sproutcore-metal/~tests/accessors/set_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n\nmodule('SC.set');\n\ntest('should set arbitrary properties on an object', function() {\n  var obj = {\n    string: 'string',\n    number: 23,\n    boolTrue: true,\n    boolFalse: false,\n    nullValue: null\n  };\n  \n  var newObj = {};\n  \n  for(var key in obj) {\n    if (!obj.hasOwnProperty(key)) continue;\n    equals(SC.set(newObj, key, obj[key]), obj[key], 'should return value');\n    equals(SC.get(newObj, key), obj[key], 'should set value');\n  }\n  \n});\n\ntest('should call unknownProperty if defined and value is undefined', function() {\n  \n  var obj = {\n    count: 0,\n    unknownProperty: function(key, value) {\n      equals(key, 'foo', 'should pass key');\n      equals(value, 'BAR', 'should pass key');\n      this.count++;\n      return 'FOO';\n    }\n  };\n  \n  equals(SC.set(obj, 'foo', \"BAR\"), 'BAR', 'should return set value');\n  equals(obj.count, 1, 'should have invoked');\n});\n\ntest('should call setUnknownProperty if defined and value is undefined', function() {\n  \n  var obj = {\n    count: 0,\n    \n    unknownProperty: function(key, value) {\n      ok(false, 'should not invoke unknownProperty is setUnknownProperty is defined');\n    },\n    \n    setUnknownProperty: function(key, value) {\n      equals(key, 'foo', 'should pass key');\n      equals(value, 'BAR', 'should pass key');\n      this.count++;\n      return 'FOO';\n    }\n  };\n  \n  equals(SC.set(obj, 'foo', \"BAR\"), 'BAR', 'should return set value');\n  equals(obj.count, 1, 'should have invoked');\n});\n\n\n});");spade.register("sproutcore-metal/~tests/computed_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth Global */\n\n\nrequire('sproutcore-metal/~tests/props_helper');\n\nvar obj, count;\n\nmodule('SC.computed');\n\ntest('computed property should be an instance of descriptor', function() {\n  ok(SC.computed(function() {}) instanceof SC.Descriptor);\n});\n\ntest('defining computed property should invoke property on get', function() {\n\n  var obj = {};\n  var count = 0;\n  SC.defineProperty(obj, 'foo', SC.computed(function(key) {\n    count++;\n    return 'computed '+key;\n  }));\n\n  equals(SC.get(obj, 'foo'), 'computed foo', 'should return value');\n  equals(count, 1, 'should have invoked computed property');\n\n  if (SC.USES_ACCESSORS) {\n    count = 0;\n    equals(SC.get(obj, 'foo'), 'computed foo', 'should return value');\n    equals(count, 1, 'should have invoked computed property');\n  }\n});\n\ntest('defining computed property should invoke property on set', function() {\n\n  var obj = {};\n  var count = 0;\n  SC.defineProperty(obj, 'foo', SC.computed(function(key, value) {\n    if (value !== undefined) {\n      count++;\n      this['__'+key] = 'computed '+value;\n    }\n    return this['__'+key];\n  }));\n  \n  equals(SC.set(obj, 'foo', 'bar'), 'bar', 'should return set value');\n  equals(count, 1, 'should have invoked computed property');\n  equals(SC.get(obj, 'foo'), 'computed bar', 'should return new value');\n  \n  if (SC.USES_ACCESSORS) {\n    count = 0;\n    equals(obj.foo = 'bar', 'bar', 'shoudl return set value');\n    equals(count, 1, 'should have invoked computed property');\n    equals(SC.get(obj, 'foo'), 'computed bar', 'should return value');\n  }\n});\n\nvar objA, objB;\nmodule('SC.computed should inherit through prototype', {\n  setup: function() {\n    objA = { __foo: 'FOO' } ;\n    SC.defineProperty(objA, 'foo', SC.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'computed '+value;\n      }\n      return this['__'+key];\n    }));\n\n    objB = SC.create(objA);\n    objB.__foo = 'FOO'; // make a copy;\n  },\n  \n  teardown: function() {\n    objA = objB = null;\n  }\n});\n\ntestBoth('using get() and set()', function(get, set) {\n  equals(get(objA, 'foo'), 'FOO', 'should get FOO from A');  \n  equals(get(objB, 'foo'), 'FOO', 'should get FOO from B');\n\n  set(objA, 'foo', 'BIFF');\n  equals(get(objA, 'foo'), 'computed BIFF', 'should change A');\n  equals(get(objB, 'foo'), 'FOO', 'should NOT change B');\n  \n  set(objB, 'foo', 'bar');\n  equals(get(objB, 'foo'), 'computed bar', 'should change B');\n  equals(get(objA, 'foo'), 'computed BIFF', 'should NOT change A');\n\n  set(objA, 'foo', 'BAZ');\n  equals(get(objA, 'foo'), 'computed BAZ', 'should change A');\n  equals(get(objB, 'foo'), 'computed bar', 'should NOT change B');\n});\n\nmodule('redefining computed property to normal', {\n  setup: function() {\n    objA = { __foo: 'FOO' } ;\n    SC.defineProperty(objA, 'foo', SC.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'computed '+value;\n      }\n      return this['__'+key];\n    }));\n\n    objB = SC.create(objA);\n    SC.defineProperty(objB, 'foo'); // make this just a normal property.\n  },\n  \n  teardown: function() {\n    objA = objB = null;\n  }\n});\n\ntestBoth('using get() and set()', function(get, set) {\n  equals(get(objA, 'foo'), 'FOO', 'should get FOO from A');  \n  equals(get(objB, 'foo'), undefined, 'should get undefined from B');\n\n  set(objA, 'foo', 'BIFF');\n  equals(get(objA, 'foo'), 'computed BIFF', 'should change A');\n  equals(get(objB, 'foo'), undefined, 'should NOT change B');\n  \n  set(objB, 'foo', 'bar');\n  equals(get(objB, 'foo'), 'bar', 'should change B');\n  equals(get(objA, 'foo'), 'computed BIFF', 'should NOT change A');\n\n  set(objA, 'foo', 'BAZ');\n  equals(get(objA, 'foo'), 'computed BAZ', 'should change A');\n  equals(get(objB, 'foo'), 'bar', 'should NOT change B');\n});\n\nmodule('redefining computed property to another property', {\n  setup: function() {\n    objA = { __foo: 'FOO' } ;\n    SC.defineProperty(objA, 'foo', SC.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'A '+value;\n      }\n      return this['__'+key];\n    }));\n\n    objB = SC.create(objA);\n    objB.__foo = 'FOO';\n    SC.defineProperty(objB, 'foo', SC.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'B '+value;\n      }\n      return this['__'+key];\n    }));\n  },\n  \n  teardown: function() {\n    objA = objB = null;\n  }\n});\n\ntestBoth('using get() and set()', function(get, set) {\n  equals(get(objA, 'foo'), 'FOO', 'should get FOO from A');  \n  equals(get(objB, 'foo'), 'FOO', 'should get FOO from B');\n\n  set(objA, 'foo', 'BIFF');\n  equals(get(objA, 'foo'), 'A BIFF', 'should change A');\n  equals(get(objB, 'foo'), 'FOO', 'should NOT change B');\n  \n  set(objB, 'foo', 'bar');\n  equals(get(objB, 'foo'), 'B bar', 'should change B');\n  equals(get(objA, 'foo'), 'A BIFF', 'should NOT change A');\n\n  set(objA, 'foo', 'BAZ');\n  equals(get(objA, 'foo'), 'A BAZ', 'should change A');\n  equals(get(objB, 'foo'), 'B bar', 'should NOT change B');\n});\n\n\n// ..........................................................\n// CACHEABLE\n// \n\nmodule('SC.computed - cacheable', {\n  setup: function() {\n    obj = {};\n    count = 0;\n    SC.defineProperty(obj, 'foo', SC.computed(function() {\n      count++;\n      return 'bar '+count;    \n    }).cacheable());\n  },\n  \n  teardown: function() {\n    obj = count = null;\n  }\n});\n\ntestBoth('cacheable should cache', function(get, set) {\n  equals(get(obj, 'foo'), 'bar 1', 'first get');\n  equals(get(obj, 'foo'), 'bar 1', 'second get');\n  equals(count, 1, 'should only invoke once');\n});\n\ntestBoth('modifying a cacheable property should update cache', function(get, set) {\n  equals(get(obj, 'foo'), 'bar 1', 'first get');\n  equals(get(obj, 'foo'), 'bar 1', 'second get');\n\n  equals(set(obj, 'foo', 'baz'), 'baz', 'setting');\n  equals(get(obj, 'foo'), 'bar 2', 'third get');\n  equals(count, 2, 'should not invoke again');\n});\n\ntestBoth('inherited property should not pick up cache', function(get, set) {\n  var objB = SC.create(obj);\n\n  equals(get(obj, 'foo'), 'bar 1', 'obj first get');\n  equals(get(objB, 'foo'), 'bar 2', 'objB first get');\n\n  equals(get(obj, 'foo'), 'bar 1', 'obj second get');\n  equals(get(objB, 'foo'), 'bar 2', 'objB second get');\n  \n  set(obj, 'foo', 'baz'); // modify A\n  equals(get(obj, 'foo'), 'bar 3', 'obj third get');\n  equals(get(objB, 'foo'), 'bar 2', 'objB third get');\n});\n\n// ..........................................................\n// DEPENDENT KEYS\n// \n\nSC.STOP = true;\n\nmodule('SC.computed - dependentkey', {\n  setup: function() {\n    obj = { bar: 'baz' };\n    count = 0;\n    SC.defineProperty(obj, 'foo', SC.computed(function() {\n      count++;\n      return 'bar '+count;    \n    }).property('bar').cacheable());\n  },\n  \n  teardown: function() {\n    obj = count = null;\n  }\n});\n\ntestBoth('local dependent key should invalidate cache', function(get, set) {\n  equals(get(obj, 'foo'), 'bar 1', 'get once');\n  equals(get(obj, 'foo'), 'bar 1', 'cached retrieve');\n\n  set(obj, 'bar', 'BIFF'); // should invalidate foo\n\n  equals(get(obj, 'foo'), 'bar 2', 'should recache');\n  equals(get(obj, 'foo'), 'bar 2', 'cached retrieve');\n});\n\ntestBoth('should invalidate multiple nested dependent keys', function(get, set) {\n  \n  SC.defineProperty(obj, 'bar', SC.computed(function() {\n    count++;\n    return 'baz '+count;\n  }).property('baz').cacheable());\n  \n  equals(get(obj, 'foo'), 'bar 1', 'get once');\n  equals(get(obj, 'foo'), 'bar 1', 'cached retrieve');\n\n  set(obj, 'baz', 'BIFF'); // should invalidate bar -> foo\n\n  equals(get(obj, 'foo'), 'bar 2', 'should recache');\n  equals(get(obj, 'foo'), 'bar 2', 'cached retrieve');\n});\n\ntestBoth('circular keys should not blow up', function(get, set) {\n  \n  SC.defineProperty(obj, 'bar', SC.computed(function() {\n    count++;\n    return 'bar '+count;\n  }).property('foo').cacheable());\n\n  SC.defineProperty(obj, 'foo', SC.computed(function() {\n    count++;\n    return 'foo '+count;\n  }).property('bar').cacheable());\n  \n  equals(get(obj, 'foo'), 'foo 1', 'get once');\n  equals(get(obj, 'foo'), 'foo 1', 'cached retrieve');\n\n  set(obj, 'bar', 'BIFF'); // should invalidate bar -> foo -> bar\n\n  equals(get(obj, 'foo'), 'foo 3', 'should recache');\n  equals(get(obj, 'foo'), 'foo 3', 'cached retrieve');\n});\n\ntestBoth('redefining a property should undo old depenent keys', function(get ,set) {\n\n  equals(get(obj, 'foo'), 'bar 1');\n\n  SC.defineProperty(obj, 'foo', SC.computed(function() {\n    count++;\n    return 'baz '+count;\n  }).property('baz').cacheable());\n\n  equals(get(obj, 'foo'), 'baz 2');\n  \n  set(obj, 'bar', 'BIFF'); // should not kill cache\n  equals(get(obj, 'foo'), 'baz 2');\n  \n  set(obj, 'baz', 'BOP');\n  equals(get(obj, 'foo'), 'baz 3');\n});\n\n// ..........................................................\n// CHAINED DEPENDENT KEYS\n// \n\nvar func;\n\nmodule('SC.computed - dependentkey with chained properties', {\n  setup: function() {\n    obj = { \n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }  \n    };\n\n    Global = { \n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }  \n    };\n    \n    count = 0;\n    func = function() {\n      count++;\n      return SC.getPath(obj, 'foo.bar.baz.biff')+' '+count;    \n    };\n  },\n  \n  teardown: function() {\n    obj = count = func = Global = null;\n  }\n});\n\ntestBoth('depending on simple chain', function(get, set) {\n\n  // assign computed property\n  SC.defineProperty(obj, 'prop', \n    SC.computed(func).property('foo.bar.baz.biff').cacheable());\n\n  equals(get(obj, 'prop'), 'BIFF 1');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  \n  set(SC.getPath(obj, 'foo.bar'),  'baz', { biff: 'BLOB' });\n  equals(get(obj, 'prop'), 'BLOB 3');\n  equals(get(obj, 'prop'), 'BLOB 3');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(SC.get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equals(get(obj, 'prop'), 'BOOM 5');\n  equals(get(obj, 'prop'), 'BOOM 5');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 6');\n  equals(get(obj, 'prop'), 'BUZZ 6');\n  \n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'BLARG 7');\n  equals(get(obj, 'prop'), 'BLARG 7');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 8');\n  equals(get(obj, 'prop'), 'BUZZ 8');\n  \n  SC.defineProperty(obj, 'prop');\n  set(obj, 'prop', 'NONE');\n  equals(get(obj, 'prop'), 'NONE');\n\n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'NONE'); // should do nothing\n  equals(count, 8, 'should be not have invoked computed again');\n\n});\n\ntestBoth('depending on complex chain', function(get, set) {\n\n  // assign computed property\n  SC.defineProperty(obj, 'prop', \n    SC.computed(func).property('foo.bar*baz.biff').cacheable());\n\n  equals(get(obj, 'prop'), 'BIFF 1');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  \n  set(SC.getPath(obj, 'foo.bar'),  'baz', { biff: 'BLOB' });\n  equals(get(obj, 'prop'), 'BLOB 3');\n  equals(get(obj, 'prop'), 'BLOB 3');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n\n  // NOTHING SHOULD CHANGE AFTER THIS POINT BECAUSE OF THE CHAINED *\n  \n  set(SC.get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  SC.defineProperty(obj, 'prop');\n  set(obj, 'prop', 'NONE');\n  equals(get(obj, 'prop'), 'NONE');\n\n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'NONE'); // should do nothing\n  equals(count, 4, 'should be not have invoked computed again');\n\n});\n\ntestBoth('depending on Global chain', function(get, set) {\n\n  // assign computed property\n  SC.defineProperty(obj, 'prop', SC.computed(function() {\n    count++;\n    return SC.getPath('Global.foo.bar.baz.biff')+' '+count;    \n  }).property('Global.foo.bar.baz.biff').cacheable());\n\n  equals(get(obj, 'prop'), 'BIFF 1');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  \n  set(SC.getPath(Global, 'foo.bar'), 'baz', { biff: 'BLOB' });\n  equals(get(obj, 'prop'), 'BLOB 3');\n  equals(get(obj, 'prop'), 'BLOB 3');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(SC.get(Global, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equals(get(obj, 'prop'), 'BOOM 5');\n  equals(get(obj, 'prop'), 'BOOM 5');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 6');\n  equals(get(obj, 'prop'), 'BUZZ 6');\n  \n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'BLARG 7');\n  equals(get(obj, 'prop'), 'BLARG 7');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 8');\n  equals(get(obj, 'prop'), 'BUZZ 8');\n  \n  SC.defineProperty(obj, 'prop');\n  set(obj, 'prop', 'NONE');\n  equals(get(obj, 'prop'), 'NONE');\n\n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'NONE'); // should do nothing\n  equals(count, 8, 'should be not have invoked computed again');\n\n});\n\ntestBoth('depending on complex Global chain', function(get, set) {\n\n  // assign computed property\n  SC.defineProperty(obj, 'prop', SC.computed(function() {\n    count++;\n    return SC.getPath('Global.foo.bar.baz.biff')+' '+count;    \n  }).property('Global.foo.bar*baz.biff').cacheable());\n\n  equals(get(obj, 'prop'), 'BIFF 1');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  equals(get(obj, 'prop'), 'BUZZ 2');\n  \n  set(SC.getPath(Global, 'foo.bar'), 'baz', { biff: 'BLOB' });\n  equals(get(obj, 'prop'), 'BLOB 3');\n  equals(get(obj, 'prop'), 'BLOB 3');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n\n  // NOTHING SHOULD CHANGE AFTER THIS POINT BECAUSE OF THE CHAINED *\n  \n  set(SC.get(Global, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  set(SC.getPath(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  equals(get(obj, 'prop'), 'BUZZ 4');\n  \n  SC.defineProperty(obj, 'prop');\n  set(obj, 'prop', 'NONE');\n  equals(get(obj, 'prop'), 'NONE');\n\n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(get(obj, 'prop'), 'NONE'); // should do nothing\n  equals(count, 4, 'should be not have invoked computed again');\n\n});\n\n// ..........................................................\n// BUGS\n// \n\nmodule('computed edge cases');\n\ntest('adding a computed property should show up in key iteration',function() {\n\n  var obj = {};\n  SC.defineProperty(obj, 'foo', SC.computed(function() {}));\n  \n  var found = [];\n  for(var key in obj) found.push(key);\n  ok(found.indexOf('foo')>=0, 'should find computed property in iteration found='+found);\n  ok('foo' in obj, 'foo in obj should pass');\n});\n\n\n});");spade.register("sproutcore-metal/~tests/events_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/props/events_test');\n\ntest('listener should receive event - removing should remove', function() {\n  var obj = {}, count = 0;\n  var F = function() { count++; };\n  \n  SC.addListener(obj, 'event!', F);\n  equals(count, 0, 'nothing yet');\n  \n  SC.sendEvent(obj, 'event!');\n  equals(count, 1, 'received event');\n  \n  SC.removeListener(obj, 'event!', F);\n\n  count = 0;\n  SC.sendEvent(obj, 'event!');\n  equals(count, 0, 'received event');\n});\n\ntest('listeners should be inherited', function() {\n  var obj = {}, count = 0;\n  var F = function() { count++; };\n\n  SC.addListener(obj, 'event!', F);\n  \n  var obj2 = SC.create(obj);\n  \n  equals(count, 0, 'nothing yet');\n  \n  SC.sendEvent(obj2, 'event!');\n  equals(count, 1, 'received event');\n\n  SC.removeListener(obj2, 'event!', F);\n\n  count = 0;\n  SC.sendEvent(obj2, 'event!');\n  equals(count, 0, 'did not receive event');\n  \n  SC.sendEvent(obj, 'event!');\n  equals(count, 1, 'should still invoke on parent');\n  \n});\n\n\ntest('adding a listener more than once should only invoke once', function() {\n  \n  var obj = {}, count = 0;\n  var F = function() { count++; };\n  SC.addListener(obj, 'event!', F);\n  SC.addListener(obj, 'event!', F);\n\n  SC.sendEvent(obj, 'event!');\n  equals(count, 1, 'should only invoke once');\n});\n\ntest('adding a listener with a target should invoke with target', function() {\n  var obj = {}, target;\n  \n  target = {\n    count: 0,\n    method: function() { this.count++; }\n  };\n  \n  SC.addListener(obj, 'event!', target, target.method);\n  SC.sendEvent(obj, 'event!');\n  equals(target.count, 1, 'should invoke');  \n});\n\ntest('adding a listener with string method should lookup method on event delivery', function() {\n  var obj = {}, target;\n  \n  target = {\n    count: 0,\n    method: function() {}\n  };\n  \n  SC.addListener(obj, 'event!', target, 'method');\n  SC.sendEvent(obj, 'event!');\n  equals(target.count, 0, 'should invoke but do nothing');  \n  \n  target.method = function() { this.count++; };\n  SC.sendEvent(obj, 'event!');\n  equals(target.count, 1, 'should invoke now');  \n});\n\ntest('calling sendEvent with extra params should be passed to listeners', function() {\n\n  var obj = {}, params = null;\n  SC.addListener(obj, 'event!', function() { \n    params = Array.prototype.slice.call(arguments);\n  });\n  \n  SC.sendEvent(obj, 'event!', 'foo', 'bar');\n  same(params, [obj, 'event!', 'foo', 'bar'], 'params should be saved');  \n});\n\ntest('implementing sendEvent on object should invoke', function() {\n  var obj = {\n    sendEvent: function(eventName, param1, param2) {\n      equals(eventName, 'event!', 'eventName');\n      equals(param1, 'foo', 'param1');\n      equals(param2, 'bar', 'param2');\n      this.count++;\n    },\n    \n    count: 0\n  };\n  \n  SC.addListener(obj, 'event!', obj, function() { this.count++; });\n  \n  SC.sendEvent(obj, 'event!', 'foo', 'bar');\n  equals(obj.count, 2, 'should have invoked method & listener');\n});\n\ntest('hasListeners tells you if there are listeners for a given event', function() {\n\n  var obj = {}, F = function() {}, F2 = function() {};\n  \n  equals(SC.hasListeners(obj, 'event!'), false, 'no listeners at first');\n  \n  SC.addListener(obj, 'event!', F);\n  SC.addListener(obj, 'event!', F2);\n\n  equals(SC.hasListeners(obj, 'event!'), true, 'has listeners');\n\n  SC.removeListener(obj, 'event!', F);\n  equals(SC.hasListeners(obj, 'event!'), true, 'has listeners');\n\n  SC.removeListener(obj, 'event!', F2);\n  equals(SC.hasListeners(obj, 'event!'), false, 'has no more listeners');\n\n  SC.addListener(obj, 'event!', F);\n  equals(SC.hasListeners(obj, 'event!'), true, 'has listeners');\n});\n\n\n});");spade.register("sproutcore-metal/~tests/mixin/alias_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.alias');\n\nfunction validateAlias(obj) {\n  var get = SC.get;\n  equals(get(obj, 'foo'), 'foo', 'obj.foo');\n  equals(get(obj, 'bar'), 'foo', 'obj.bar should be a copy of foo');\n\n  equals(get(obj, 'computedFoo'), 'cfoo', 'obj.computedFoo');\n  equals(get(obj, 'computedBar'), 'cfoo', 'obj.computedBar should be a copy of computedFoo');\n\n  equals(obj.fooMethod(), 'FOO', 'obj.fooMethod()');\n  equals(obj.barMethod(), 'FOO', 'obj.barMethod should be a copy of foo');\n}\n\ntest('copies the property values from another key when the mixin is applied', function() {\n\n  var MyMixin = SC.Mixin.create({\n    foo: 'foo',\n    bar: SC.alias('foo'),\n\n    computedFoo: SC.computed(function() {\n      return 'cfoo';\n    }),\n\n    computedBar: SC.alias('computedFoo'),\n    \n    fooMethod: function() { return 'FOO'; },\n    barMethod: SC.alias('fooMethod')\n  });\n  \n  var obj = MyMixin.apply({});\n  validateAlias(obj);\n});\n\ntest('should follow aliases all the way down', function() {\n  var MyMixin = SC.Mixin.create({\n    bar: SC.alias('foo'), // put first to break ordered iteration\n    baz: 'baz',\n    foo: SC.alias('baz')\n  });\n  \n  var obj = MyMixin.apply({});\n  equals(SC.get(obj, 'bar'), 'baz', 'should have followed aliases');\n});\n\ntest('should copy from other dependent mixins', function() {\n\n  var BaseMixin = SC.Mixin.create({\n    foo: 'foo',\n\n    computedFoo: SC.computed(function() {\n      return 'cfoo';\n    }),\n\n    fooMethod: function() { return 'FOO'; }\n  });\n  \n  var MyMixin = SC.Mixin.create(BaseMixin, {\n    bar: SC.alias('foo'),\n    computedBar: SC.alias('computedFoo'),\n    barMethod: SC.alias('fooMethod')\n  });\n  \n  var obj = MyMixin.apply({});\n  validateAlias(obj);\n});\n\ntest('should copy from other mixins applied at same time', function() {\n\n  var BaseMixin = SC.Mixin.create({\n    foo: 'foo',\n\n    computedFoo: SC.computed(function() {\n      return 'cfoo';\n    }),\n\n    fooMethod: function() { return 'FOO'; }\n  });\n  \n  var MyMixin = SC.Mixin.create({\n    bar: SC.alias('foo'),\n    computedBar: SC.alias('computedFoo'),\n    barMethod: SC.alias('fooMethod')\n  });\n  \n  var obj = SC.mixin({}, BaseMixin, MyMixin);\n  validateAlias(obj);\n});\n\ntest('should copy from properties already applied on object', function() {\n\n  var BaseMixin = SC.Mixin.create({\n    foo: 'foo',\n    \n    computedFoo: SC.computed(function() {\n      return 'cfoo';\n    })\n    \n  });\n  \n  var MyMixin = SC.Mixin.create({\n    bar: SC.alias('foo'),\n    computedBar: SC.alias('computedFoo'),\n    barMethod: SC.alias('fooMethod')\n  });\n\n  var obj = {\n    fooMethod: function() { return 'FOO'; }\n  };\n  \n  BaseMixin.apply(obj);\n  MyMixin.apply(obj);\n  \n  validateAlias(obj);\n});\n\n});");spade.register("sproutcore-metal/~tests/mixin/apply_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals raises */\n\n\nmodule('SC.Mixin.apply');\n\nfunction K() {}\n\ntest('using apply() should apply properties', function() {\n  var MixinA = SC.Mixin.create({ foo: 'FOO', baz: K });\n  var obj = {};\n  SC.mixin(obj, MixinA);\n\n  equals(SC.get(obj, 'foo'), \"FOO\", 'should apply foo');\n  equals(SC.get(obj, 'baz'), K, 'should apply foo');\n});\n\ntest('applying anonymous properties', function() {\n  var obj = {};\n  SC.mixin(obj, {\n    foo: 'FOO',\n    baz: K\n  });\n\n  equals(SC.get(obj, 'foo'), \"FOO\", 'should apply foo');\n  equals(SC.get(obj, 'baz'), K, 'should apply foo');\n});\n\ntest('applying null values', function() {\n  raises(function() {\n    SC.mixin({}, null);\n  }, Error);\n});\n\n});");spade.register("sproutcore-metal/~tests/mixin/concatenatedProperties_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals setup */\n\n\nmodule('SC.Mixin concatenatedProperties');\n\ntest('defining concatenated properties should concat future version', function() {\n\n  var MixinA = SC.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: ['a', 'b', 'c']\n  });\n  \n  var MixinB = SC.Mixin.create({\n    foo: ['d', 'e', 'f']\n  });\n  \n  var obj = SC.mixin({}, MixinA, MixinB);\n  same(SC.get(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f']);\n});\n\ntest('concatenatedProperties should be concatenated', function() {\n\n  var MixinA = SC.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: ['a', 'b', 'c']\n  });\n  \n  var MixinB = SC.Mixin.create({\n    concatenatedProperties: 'bar',\n    foo: ['d', 'e', 'f'],\n    bar: [1,2,3]\n  });\n  \n  var MixinC = SC.Mixin.create({\n    bar: [4,5,6]\n  });\n  \n  var obj = SC.mixin({}, MixinA, MixinB, MixinC);\n  same(SC.get(obj, 'concatenatedProperties'), ['foo', 'bar'], 'get concatenatedProperties');\n  same(SC.get(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f'], 'get foo');\n  same(SC.get(obj, 'bar'), [1,2,3,4,5,6], 'get bar');\n});\n\ntest('adding a prop that is not an array should make array', function() {\n\n  var MixinA = SC.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: [1,2,3]\n  });\n\n  var MixinB = SC.Mixin.create({\n    foo: 4\n  });\n\n  var obj = SC.mixin({}, MixinA, MixinB);\n  same(SC.get(obj, 'foo'), [1,2,3,4]);\n});\n\ntest('adding a prop that is not an array should make array', function() {\n\n  var MixinA = SC.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: 'bar'\n  });\n\n  var obj = SC.mixin({}, MixinA);\n  same(SC.get(obj, 'foo'), ['bar']);\n});\n\n});");spade.register("sproutcore-metal/~tests/mixin/detect_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('Mixin.detect');\n\ntest('detect() finds a directly applied mixin', function() {\n  \n  var MixinA = SC.Mixin.create();\n  var obj = {};\n  \n  equals(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');\n\n  MixinA.apply(obj);\n  equals(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');\n});\n\ntest('detect() finds nested mixins', function() {\n  var MixinA = SC.Mixin.create({});\n  var MixinB = SC.Mixin.create(MixinA);\n  var obj = {};\n  \n  equals(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');\n\n  MixinB.apply(obj);\n  equals(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');\n});\n\ntest('detect() finds mixins on other mixins', function() {\n  var MixinA = SC.Mixin.create({});\n  var MixinB = SC.Mixin.create(MixinA);\n  equals(MixinA.detect(MixinB), true, 'MixinA is part of MixinB');\n  equals(MixinB.detect(MixinA), false, 'MixinB is not part of MixinA');\n});\n\ntest('detect handles null values', function() {\n  var MixinA = SC.Mixin.create();\n  equals(MixinA.detect(null), false);\n});\n\n});");spade.register("sproutcore-metal/~tests/mixin/introspection_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n// NOTE: A previous iteration differentiated between public and private props\n// as well as methods vs props.  We are just keeping these for testing; the\n// current impl doesn't care about the differences as much...\n\nvar PrivateProperty = SC.Mixin.create({\n  _foo: '_FOO'\n});\n\nvar PublicProperty = SC.Mixin.create({\n  foo: 'FOO'\n});\n\nvar PrivateMethod = SC.Mixin.create({\n  _fooMethod: function() {}\n});\n\nvar PublicMethod = SC.Mixin.create({\n  fooMethod: function() {}\n});\n\nvar BarProperties = SC.Mixin.create({\n  _bar: '_BAR',\n  bar: 'bar'\n});\n\nvar BarMethods = SC.Mixin.create({\n  _barMethod: function() {},\n  barMethod: function() {}\n});\n\nvar Combined = SC.Mixin.create(BarProperties, BarMethods);\n\nvar obj ;\n\nmodule('Basic introspection', {\n  setup: function() {\n    obj = {};\n    SC.mixin(obj, PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined);\n  }\n});\n\ntest('SC.mixins()', function() {\n  \n  function mapGuids(ary) { \n    return ary.map(function(x) { return SC.guidFor(x); }); \n  }\n  \n  same(mapGuids(SC.Mixin.mixins(obj)), mapGuids([PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined, BarProperties, BarMethods]), 'should return included mixins');\n});\n\n});");spade.register("sproutcore-metal/~tests/mixin/method_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals raises */\n\n\nmodule('Mixin Methods');\n\ntest('defining simple methods', function() {\n  \n  var MixinA, obj, props;\n  \n  props = {\n    publicMethod: function() { return 'publicMethod'; },\n    _privateMethod: function() { return 'privateMethod'; }\n  };\n  \n  MixinA = SC.Mixin.create(props);\n  obj = {};\n  MixinA.apply(obj);\n  \n  // but should be defined\n  equals(props.publicMethod(), 'publicMethod', 'publicMethod is func');\n  equals(props._privateMethod(), 'privateMethod', 'privateMethod is func');\n});\n\ntest('overriding public methods', function() {\n  var MixinA, MixinB, MixinC, MixinD, MixinE, MixinF, obj;\n  \n  MixinA = SC.Mixin.create({\n    publicMethod: function() { return 'A'; }\n  });\n  \n  MixinB = SC.Mixin.create(MixinA, {\n    publicMethod: function() { return this._super()+'B'; }\n  });\n\n  MixinD = SC.Mixin.create(MixinA, {\n    publicMethod: function() { return this._super()+'D'; }\n  });\n  \n  MixinF = SC.Mixin.create({\n    publicMethod: function() { return this._super()+'F'; }\n  });\n  \n  obj = {};\n  MixinB.apply(obj);\n  equals(obj.publicMethod(), 'AB', 'should define super for A and B');\n\n  obj = {};\n  MixinD.apply(obj);\n  equals(obj.publicMethod(), 'AD', 'should define super for A and B');\n\n  obj = {};\n  MixinA.apply(obj);\n  MixinF.apply(obj);\n  equals(obj.publicMethod(), 'AF', 'should define super for A and F');\n\n  obj = { publicMethod: function() { return 'obj'; } };\n  MixinF.apply(obj);\n  equals(obj.publicMethod(), 'objF', 'should define super for F');\n});\n\n\ntest('overriding inherited objects', function() {\n  \n  var cnt = 0;\n  var MixinA = SC.Mixin.create({\n    foo: function() { cnt++; }\n  });\n  \n  var MixinB = SC.Mixin.create({\n    foo: function() { this._super(); cnt++; }\n  });\n\n  var objA = {};\n  MixinA.apply(objA);\n  \n  var objB = SC.create(objA);\n  MixinB.apply(objB);\n  \n  cnt = 0;\n  objB.foo();\n  equals(cnt, 2, 'should invoke both methods');\n  \n  cnt = 0;\n  objA.foo();\n  equals(cnt, 1, 'should not screw w/ parent obj');\n});\n\ntest('Including the same mixin more than once will only run once', function() {\n  var cnt = 0;\n  var MixinA = SC.Mixin.create({\n    foo: function() { cnt++; }\n  });\n  \n  var MixinB = SC.Mixin.create(MixinA, {\n    foo: function() { this._super(); }\n  });\n  \n  var MixinC = SC.Mixin.create(MixinA, {\n    foo: function() { this._super(); }\n  });\n\n  var MixinD = SC.Mixin.create(MixinB, MixinC, MixinA, {\n    foo: function() { this._super(); }\n  });\n  \n  var obj = {};\n  MixinD.apply(obj);\n  MixinA.apply(obj); // try to apply again..\n  \n  cnt = 0;\n  obj.foo();\n  \n  equals(cnt, 1, 'should invoke MixinA.foo one time');\n});\n\n// ..........................................................\n// CONFLICTS\n// \n\nmodule('Method Conflicts');\n\n\ntest('overriding toString', function() {\n  var MixinA = SC.Mixin.create({\n    toString: function() { return 'FOO'; }\n  });\n  \n  var obj = {};\n  MixinA.apply(obj);\n  equals(obj.toString(), 'FOO', 'should override toString w/o error');\n  \n  obj = {};\n  SC.mixin(obj, { toString: function() { return 'FOO'; } });\n  equals(obj.toString(), 'FOO', 'should override toString w/o error');\n});\n\n// ..........................................................\n// BUGS\n// \n\nmodule('system/mixin/method_test BUGS');\n\ntest('applying several mixins at once with sup already defined causes infinite loop', function() {\n  \n  var cnt = 0;\n  var MixinA = SC.Mixin.create({\n    foo: function() { cnt++; }\n  });\n  \n  var MixinB = SC.Mixin.create({\n    foo: function() { this._super(); cnt++; }\n  });\n\n  var MixinC = SC.Mixin.create({\n    foo: function() { this._super(); cnt++; }\n  });\n\n  var obj = {};\n  SC.mixin(obj, MixinA); // sup already exists\n  SC.mixin(obj, MixinB, MixinC); // must be more than one mixin\n\n  cnt = 0;\n  obj.foo();\n  equals(cnt, 3, 'should invoke all 3 methods');\n});\n\n});");spade.register("sproutcore-metal/~tests/mixin/mixin_delegate_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.MixinDelegate');\n\ntest('Basic usage', function() {\n  var obj = {};\n  SC.mixin(obj, SC.MixinDelegate, {\n       \n    foo: 'BAR',\n     \n    willApplyProperty: function(keyName) {\n      if (keyName === 'foo') {\n        this._before = [keyName, SC.get(this, keyName)];\n      }\n    },\n    \n    didApplyProperty: function(keyName) {\n      if (keyName === 'foo') {\n        this._after = [keyName, SC.get(this, keyName)];\n      }\n    }\n  });\n  \n  ok(SC.MixinDelegate.detect(obj), 'should have PropMixinDelegate applied');\n  ok(!!obj._before, 'should have called with props');\n  ok(!!obj._after,  'should have called with props');\n\n  SC.mixin(obj, { foo: 'FOO' });\n  same(obj._before, ['foo', 'BAR'], 'should have called before apply');\n  same(obj._after,  ['foo', 'FOO'], 'should have called after apply');\n  \n});\n\ntest('Only invokes callbacks once mixin is applied', function() {\n  var obj = {};\n  \n  // NOTE: does not apply mixin\n  SC.mixin(obj, SC.MixinDelegate, {\n    foo: 'BAR',\n\n    _before: null, \n    _after: null,\n    \n    willApplyProperty: function(keyName, desc) {\n      this._before = SC.get(this, keyName);\n    },\n    \n    didApplyProperty: function(keyName, desc) {\n      this._after = SC.get(this, keyName);\n    }\n  });\n  \n  SC.mixin(obj, { foo: 'FOO' });\n  equals(obj._before, 'BAR', 'should not have called yet');\n  equals(obj._after,  'FOO', 'should not have called yet');\n  \n});\n\n\n// test('Uses existing callbacks until mixin applied', function() {\n//   var obj = {};\n//   SC.mixin(obj, SC.Accessors);\n//   SC.mixin(obj, SC.MixinDelegate, {\n//     \n//     _before: null, \n//     _after: null,\n// \n//     willApplyProperty: function(keyName, desc) {\n//       if (!this._before) this._before = {};\n//       this._before[keyName] = this.get(keyName);\n//       this._super(keyName, desc);\n//     },\n//     \n//     didApplyProperty: function(keyName, desc) {\n//       if (!this._after) this._after = {};\n//       this._after[keyName] = this.get(keyName);\n//       this._super(keyName, desc);\n//     },\n//     \n//     foo: 'FOO'\n//   });\n//   \n//   ok(!!obj._before, 'should have invoked willApply yet');\n//   ok(!!obj._after, 'should have invoked didApply yet');  \n//   obj._before = obj._after = null;\n//   \n//   var secondBefore, secondAfter;\n//   \n//   SC.mixin(obj, { \n//     \n//     willApplyProperty: function(keyName, desc) {\n//       if (!secondBefore) secondBefore = {};\n//       secondBefore[keyName] = true;\n//       this._super(keyName, desc);\n//     },\n// \n//     didApplyProperty: function(keyName, desc) {\n//       if (!secondAfter) secondAfter = {};\n//       secondAfter[keyName] = true;\n//       this._super(keyName, desc);\n//     },\n//     \n//     bar: 'BAR'\n//     \n//   });\n// \n//   ['willApplyProperty', 'didApplyProperty', 'bar'].forEach(function(key) {\n//     ok(key in obj._before, 'should have called first willApply for '+key);\n//     ok(key in obj._after, 'should have called first didApply for '+key);\n//     ok(key in secondBefore, 'should have called second willApply for '+key);\n//     ok(key in secondAfter, 'should have called second didApply for '+key);\n//   });\n//   \n//   \n//   // Third mixin...\n//   SC.mixin(obj, { baz: 'BAZ' });\n// \n//   ok('baz' in obj._before, 'should have called first willApply');\n//   ok('baz' in obj._after, 'should have called first didApply');\n//   ok('baz' in secondBefore, 'should have called second willApply');\n//   ok('baz' in secondAfter, 'should have called second didApply');\n//   \n// });\n\n});");spade.register("sproutcore-metal/~tests/mixin/observer_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth */\n\n\nrequire('sproutcore-metal/~tests/props_helper');\n\nmodule('SC.Mixin observer');\n\ntestBoth('global observer helper', function(get, set) {\n\n  var MyMixin = SC.Mixin.create({\n    \n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var obj = SC.mixin({}, MyMixin);\n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equals(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('global observer helper takes multiple params', function(get, set) {\n\n  var MyMixin = SC.Mixin.create({\n    \n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar', 'baz')\n\n  });\n\n  var obj = SC.mixin({}, MyMixin);\n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  set(obj, 'baz', \"BAZ\");\n  equals(get(obj, 'count'), 2, 'should invoke observer after change');\n});\n\n\ntestBoth('replacing observer should remove old observer', function(get, set) {\n\n  var MyMixin = SC.Mixin.create({\n    \n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var Mixin2 = SC.Mixin.create({\n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+10);\n    }, 'baz')\n  });\n  \n  var obj = SC.mixin({}, MyMixin, Mixin2);\n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equals(get(obj, 'count'), 0, 'should not invoke observer after change');\n\n  set(obj, 'baz', \"BAZ\");\n  equals(get(obj, 'count'), 10, 'should invoke observer after change');\n\n});\n\n});");spade.register("sproutcore-metal/~tests/mixin/reopen_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.Mixin#reopen');\n\ntest('using reopen() to add more properties to a simple', function() {\n  var MixinA = SC.Mixin.create({ foo: 'FOO', baz: 'BAZ' });\n  MixinA.reopen({ bar: 'BAR', foo: 'FOO2' });\n  var obj = {};\n  MixinA.apply(obj);\n  \n  equals(SC.get(obj, 'foo'), 'FOO2', 'mixin() should override');\n  equals(SC.get(obj, 'baz'), 'BAZ', 'preserve MixinA props');\n  equals(SC.get(obj, 'bar'), 'BAR', 'include MixinB props');\n});\n\n\n});");spade.register("sproutcore-metal/~tests/mixin/required_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals setup raises */\n\n\nvar PartialMixin, FinalMixin, obj;\n\nmodule('Module.required', {\n  setup: function() {\n    PartialMixin = SC.Mixin.create({\n      foo: SC.required(),\n      bar: 'BAR'\n    });\n  \n    FinalMixin = SC.Mixin.create({\n      foo: 'FOO'\n    });\n  \n    obj = {};\n  },\n  \n  teardown: function() {\n    PartialMixin = FinalMixin = obj = null;\n  }\n});\n\ntest('applying a mixin with unmet requirement', function() {\n  raises(function() {\n    PartialMixin.apply(obj);\n  }, Error, 'should raise error for unmet requirement');\n});\n\ntest('applying a mixin with unmet requirement using applyPartial', function() {\n  PartialMixin.applyPartial(obj);\n  equals(obj.foo, null, 'obj.foo has required');\n  \n  // applying regularly to object should throw\n  raises(function() {\n    SC.Mixin.create({ bar: 'BAR' }).apply(obj);\n  }, Error, 'should raise error for unmet requirement');\n  \n});\n\ntest('applying a mixin to meet requirement', function() {\n  FinalMixin.apply(obj);\n  PartialMixin.apply(obj);\n  equals(SC.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\ntest('combined mixins to meet requirement', function() {\n  SC.Mixin.create(PartialMixin, FinalMixin).apply(obj);\n  equals(SC.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\ntest('merged mixin', function() {\n  SC.Mixin.create(PartialMixin, { foo: 'FOO' }).apply(obj);\n});\n\ntest('define property on source object', function() {\n  obj.foo = 'FOO';\n  PartialMixin.apply(obj);\n  equals(SC.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\ntest('using apply', function() {\n  SC.mixin(obj, PartialMixin, { foo: 'FOO' });\n  equals(SC.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\n\n});");spade.register("sproutcore-metal/~tests/mixin/without_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals setup */\n\n\ntest('without should create a new mixin excluding named properties', function() {\n\n  var MixinA = SC.Mixin.create({\n    foo: 'FOO',\n    bar: 'BAR'\n  });\n  \n  var MixinB = MixinA.without('bar');\n  \n  var obj = {};\n  MixinB.apply(obj);\n  \n  equals(obj.foo, 'FOO', 'should defined foo');\n  equals(obj.bar, undefined, 'should not define bar');\n  \n});\n\n});");spade.register("sproutcore-metal/~tests/observer_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth Global */\n\n\nrequire('sproutcore-metal/~tests/props_helper');\n\n// ..........................................................\n// ADD OBSERVER\n// \n\nmodule('SC.addObserver');\n\ntestBoth('observer should fire when property is modified', function(get,set) {\n  \n  var obj = {};\n  var count = 0;\n  \n  SC.addObserver(obj, 'foo', function() { \n    equals(get(obj, 'foo'), 'bar', 'should invoke AFTER value changed');\n    count++; \n  });\n\n  set(obj, 'foo', 'bar');\n  equals(count, 1, 'should have invoked observer');\n});\n\ntestBoth('observer should fire when dependent property is modified', function(get, set) {\n  var obj = { bar: 'bar' };\n  SC.defineProperty(obj, 'foo', SC.computed(function() {\n    return get(this,'bar').toUpperCase();\n  }).property('bar'));\n  \n  var count = 0;\n  SC.addObserver(obj, 'foo', function() { \n    equals(get(obj, 'foo'), 'BAZ', 'should have invoked after prop change');\n    count++; \n  });\n  \n  set(obj, 'bar', 'baz');\n  equals(count, 1, 'should have invoked observer');\n});\n\ntestBoth('nested observers should fire in order', function(get,set) {\n  var obj = { foo: 'foo', bar: 'bar' };\n  var fooCount = 0, barCount = 0;\n  \n  SC.addObserver(obj, 'foo' ,function() { fooCount++; });\n  SC.addObserver(obj, 'bar', function() {\n    set(obj, 'foo', 'BAZ');\n    equals(fooCount, 1, 'fooCount should have fired already');\n    barCount++;\n  });\n\n  set(obj, 'bar', 'BIFF');\n  equals(barCount, 1, 'barCount should have fired');\n  equals(fooCount, 1, 'foo should have fired');\n  \n});\n\ntestBoth('suspending property changes will defer', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n\n  SC.addObserver(obj, 'foo' ,function() { fooCount++; });\n\n  SC.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BIFF');\n  set(obj, 'foo', 'BAZ');\n  SC.endPropertyChanges(obj);\n\n  equals(fooCount, 1, 'foo should have fired once');\n});\n\ntestBoth('suspending property changes will not defer before observers', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n\n  SC.addBeforeObserver(obj, 'foo' ,function() { fooCount++; });\n\n  SC.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BIFF');\n  equals(fooCount, 1, 'should fire before observer immediately');\n  set(obj, 'foo', 'BAZ');\n  SC.endPropertyChanges(obj);\n\n  equals(fooCount, 1, 'should not fire before observer twice');\n});\n\ntestBoth('addObserver should propogate through prototype', function(get,set) {\n  var obj = { foo: 'foo', count: 0 }, obj2;\n  \n  SC.addObserver(obj, 'foo', function() { this.count++; });\n  obj2 = SC.create(obj);\n  \n  set(obj2, 'foo', 'bar');\n\n  equals(obj2.count, 1, 'should have invoked observer on inherited');\n  equals(obj.count, 0, 'should not have invoked observer on parent');\n  \n  obj2.count = 0;\n  set(obj, 'foo', 'baz');\n  equals(obj.count, 1, 'should have invoked observer on parent');\n  equals(obj2.count, 0, 'should not have invoked observer on inherited');  \n});\n\ntestBoth('addObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n  \n  var target1 = { \n    count: 0, \n    \n    didChange: function(obj, keyName, value) {\n      equals(this, target1, 'should invoke with this');\n      equals(obj, observed, 'param1 should be observed object');\n      equals(keyName, 'foo', 'param2 should be keyName');\n      equals(value, 'BAZ', 'param3 should new value');\n      this.count++;\n    }\n  };\n\n  var target2 = { \n    count: 0, \n    \n    didChange: function(obj, keyName, value) {\n      equals(this, target2, 'should invoke with this');\n      equals(obj, observed, 'param1 should be observed object');\n      equals(keyName, 'foo', 'param2 should be keyName');\n      equals(value, 'BAZ', 'param3 should new value');\n      this.count++;\n    }\n  };\n\n  SC.addObserver(observed, 'foo', target1, 'didChange');\n  SC.addObserver(observed, 'foo', target2, target2.didChange);\n  \n  set(observed, 'foo', 'BAZ');\n  equals(target1.count, 1, 'target1 observer should have fired');\n  equals(target2.count, 1, 'target2 observer should have fired');\n\n});\n\ntestBoth('addObserver should preserve additional context passed when firing the observer', function(get, set) {\n  var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function(obj, keyName, value, ctx1, ctx2) {\n      equals(ctx1, \"biff\", \"first context is passed\");\n      equals(ctx2, \"bang\", \"second context is passed\");\n      this.count++;\n    }\n  };\n\n  SC.addObserver(observed, 'foo', target1, 'didChange', \"biff\", \"bang\");\n\n  set(observed, 'foo', 'BAZ');\n  equals(target1.count, 1, 'target1 observer should have fired');\n});\n\n\ntestBoth('addObserver should allow multiple objects to observe a property', function(get, set) { var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function(obj, keyName, value) {\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    didChange: function(obj, keyName, value) {\n      this.count++;\n    }\n  };\n\n  SC.addObserver(observed, 'foo', target1, 'didChange');\n  SC.addObserver(observed, 'foo', target2, 'didChange');\n\n  set(observed, 'foo', 'BAZ');\n  equals(target1.count, 1, 'target1 observer should have fired');\n  equals(target2.count, 1, 'target2 observer should have fired');\n});\n\n// ..........................................................\n// REMOVE OBSERVER\n// \n\nmodule('SC.removeObserver');\n\ntestBoth('removing observer should stop firing', function(get,set) {\n  \n  var obj = {};\n  var count = 0;\n  function F() { count++; }\n  SC.addObserver(obj, 'foo', F);\n  \n  set(obj, 'foo', 'bar');\n  equals(count, 1, 'should have invoked observer');\n  \n  SC.removeObserver(obj, 'foo', F);\n});\n\ntestBoth('local observers can be removed', function(get, set) {\n  var barObserved = 0;\n\n  var MyMixin = SC.Mixin.create({\n    foo1: SC.observer(function() {\n      barObserved++;\n    }, 'bar'),\n\n    foo2: SC.observer(function() {\n      barObserved++;\n    }, 'bar')\n  });\n\n  var obj = {};\n  MyMixin.apply(obj);\n\n  set(obj, 'bar', 'HI!');\n  equals(barObserved, 2, 'precond - observers should be fired');\n\n  SC.removeObserver(obj, 'bar', null, 'foo1');\n\n  barObserved = 0;\n  set(obj, 'bar', 'HI AGAIN!');\n\n  equals(barObserved, 1, 'removed observers should not be called');\n});\n\ntestBoth('removeObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n  \n  var target1 = { \n    count: 0, \n    \n    didChange: function() {\n      this.count++;\n    }\n  };\n\n  var target2 = { \n    count: 0, \n    \n    didChange: function() {\n      this.count++;\n    }\n  };\n\n  SC.addObserver(observed, 'foo', target1, 'didChange');\n  SC.addObserver(observed, 'foo', target2, target2.didChange);\n  \n  set(observed, 'foo', 'BAZ');\n  equals(target1.count, 1, 'target1 observer should have fired');\n  equals(target2.count, 1, 'target2 observer should have fired');\n\n  SC.removeObserver(observed, 'foo', target1, 'didChange');\n  SC.removeObserver(observed, 'foo', target2, target2.didChange);\n\n  target1.count = target2.count = 0;\n  set(observed, 'foo', 'BAZ');\n  equals(target1.count, 0, 'target1 observer should not fire again');\n  equals(target2.count, 0, 'target2 observer should not fire again');\n});\n\n// ..........................................................\n// BEFORE OBSERVER\n// \n\nmodule('SC.addBeforeObserver');\n\ntestBoth('observer should fire before a property is modified', function(get,set) {\n  \n  var obj = { foo: 'foo' };\n  var count = 0;\n  \n  SC.addBeforeObserver(obj, 'foo', function() { \n    equals(get(obj, 'foo'), 'foo', 'should invoke before value changed');\n    count++; \n  });\n  \n  set(obj, 'foo', 'bar');\n  equals(count, 1, 'should have invoked observer');\n});\n\ntestBoth('observer should fire before dependent property is modified', function(get, set) {\n  var obj = { bar: 'bar' };\n  SC.defineProperty(obj, 'foo', SC.computed(function() {\n    return get(this,'bar').toUpperCase();\n  }).property('bar'));\n  \n  var count = 0;\n  SC.addBeforeObserver(obj, 'foo', function() { \n    equals(get(obj, 'foo'), 'BAR', 'should have invoked after prop change');\n    count++; \n  });\n  \n  set(obj, 'bar', 'baz');\n  equals(count, 1, 'should have invoked observer');\n});\n\ntestBoth('addBeforeObserver should propogate through prototype', function(get,set) {\n  var obj = { foo: 'foo', count: 0 }, obj2;\n  \n  SC.addBeforeObserver(obj, 'foo', function() { this.count++; });\n  obj2 = SC.create(obj);\n\n  set(obj2, 'foo', 'bar');\n  equals(obj2.count, 1, 'should have invoked observer on inherited');\n  equals(obj.count, 0, 'should not have invoked observer on parent');\n  \n  obj2.count = 0;\n  set(obj, 'foo', 'baz');\n  equals(obj.count, 1, 'should have invoked oberver on parent');\n  equals(obj2.count, 0, 'should not have invoked observer on inherited');  \n});\n\ntestBoth('addBeforeObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n  \n  var target1 = { \n    count: 0, \n    \n    willChange: function(obj, keyName, value) {\n      equals(this, target1, 'should invoke with this');\n      equals(obj, observed, 'param1 should be observed object');\n      equals(keyName, 'foo', 'param2 should be keyName');\n      equals(value, 'foo', 'param3 should old value');\n      this.count++;\n    }\n  };\n\n  var target2 = { \n    count: 0, \n    \n    willChange: function(obj, keyName, value) {\n      equals(this, target2, 'should invoke with this');\n      equals(obj, observed, 'param1 should be observed object');\n      equals(keyName, 'foo', 'param2 should be keyName');\n      equals(value, 'foo', 'param3 should old value');\n      this.count++;\n    }\n  };\n\n  SC.addBeforeObserver(observed, 'foo', target1, 'willChange');\n  SC.addBeforeObserver(observed, 'foo', target2, target2.willChange);\n  \n  set(observed, 'foo', 'BAZ');\n  equals(target1.count, 1, 'target1 observer should have fired');\n  equals(target2.count, 1, 'target2 observer should have fired');\n  \n});\n\n// ..........................................................\n// CHAINED OBSERVERS\n// \n\nvar obj, count;\n\nmodule('SC.computed - dependentkey with chained properties', {\n  setup: function() {\n    obj = { \n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }  \n    };\n\n    Global = { \n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }  \n    };\n    \n    count = 0;\n  },\n  \n  teardown: function() {\n    obj = count = Global = null;\n  } \n});\n\ntestBoth('depending on a simple chain', function(get, set) { \n\n  var val ;\n  SC.addObserver(obj, 'foo.bar.baz.biff', function(target, key, value) { \n    val = value;\n    count++; \n  });\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(val, 'BUZZ');\n  equals(count, 1);\n\n  set(SC.getPath(obj, 'foo.bar'), 'baz', { biff: 'BLARG' });\n  equals(val, 'BLARG');\n  equals(count, 2);\n\n  set(SC.get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equals(val, 'BOOM');\n  equals(count, 3);\n  \n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(val, 'BLARG');\n  equals(count, 4);\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(val, 'BUZZ');\n  equals(count, 5);\n\n  var foo = get(obj, 'foo');\n  \n  set(obj, 'foo', 'BOO');\n  equals(val, undefined);\n  equals(count, 6);\n  \n  set(foo.bar.baz, 'biff', \"BOOM\");\n  equals(count, 6, 'should be not have invoked observer');\n});\n\ntestBoth('depending on complex chain', function(get, set) {\n  \n  var val ;\n  SC.addObserver(obj, 'foo.bar*baz.biff', function(target, key, value) { \n    val = value;\n    count++; \n  });\n  \n  set(SC.getPath(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equals(val, 'BUZZ');\n  equals(count, 1);\n\n  set(SC.getPath(obj, 'foo.bar'), 'baz', { biff: 'BLARG' });\n  equals(val, 'BLARG');\n  equals(count, 2);\n\n  // // NOTHING SHOULD CHANGE AFTER THIS POINT BECAUSE OF THE CHAINED *\n\n  set(SC.get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equals(val, 'BLARG');\n  equals(count, 2);\n  \n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(val, 'BLARG');\n  equals(count, 2);\n  \n\n});\n\ntestBoth('depending on a Global chain', function(get, set) { \n\n  var val ;\n  SC.addObserver(obj, 'Global.foo.bar.baz.biff', function(target, key, value){ \n    val = value;\n    count++; \n  });\n  \n  set(SC.getPath(Global, 'foo.bar.baz'),  'biff', 'BUZZ');\n  equals(val, 'BUZZ');\n  equals(count, 1);\n\n  set(SC.getPath(Global, 'foo.bar'),  'baz', { biff: 'BLARG' });\n  equals(val, 'BLARG');\n  equals(count, 2);\n\n  set(SC.get(Global, 'foo'),  'bar', { baz: { biff: 'BOOM' } });\n  equals(val, 'BOOM');\n  equals(count, 3);\n  \n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(val, 'BLARG');\n  equals(count, 4);\n  \n  set(SC.getPath(Global, 'foo.bar.baz'),  'biff', 'BUZZ');\n  equals(val, 'BUZZ');\n  equals(count, 5);\n\n  var foo = get(obj, 'foo');\n  \n  set(Global, 'foo', 'BOO');\n  equals(val, undefined);\n  equals(count, 6);\n  \n  set(foo.bar.baz, 'biff', \"BOOM\");\n  equals(count, 6, 'should be not have invoked observer');\n});\n\ntestBoth('depending on complex chain', function(get, set) {\n  \n  var val ;\n  SC.addObserver(obj, 'Global.foo.bar*baz.biff', function(target, key, value){ \n    val = value;\n    count++; \n  });\n  \n  set(SC.getPath(Global, 'foo.bar.baz'),  'biff', 'BUZZ');\n  equals(val, 'BUZZ');\n  equals(count, 1);\n\n  set(SC.getPath(Global, 'foo.bar'),  'baz', { biff: 'BLARG' });\n  equals(val, 'BLARG');\n  equals(count, 2);\n\n  // // NOTHING SHOULD CHANGE AFTER THIS POINT BECAUSE OF THE CHAINED *\n\n  set(SC.get(Global, 'foo'),  'bar', { baz: { biff: 'BOOM' } });\n  equals(val, 'BLARG');\n  equals(count, 2);\n  \n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equals(val, 'BLARG');\n  equals(count, 2);\n\n});\n\n// ..........................................................\n// SETTING IDENTICAL VALUES\n// \n\nmodule('props/observer_test - setting identical values');\n\ntestBoth('setting simple prop should not trigger', function(get, set) {\n  \n  var obj = { foo: 'bar' };\n  var count = 0;\n  \n  SC.addObserver(obj, 'foo', function() { count++; });\n  \n  set(obj, 'foo', 'bar');\n  equals(count, 0, 'should not trigger observer');\n  \n  set(obj, 'foo', 'baz');\n  equals(count, 1, 'should trigger observer');\n  \n  set(obj, 'foo', 'baz');\n  equals(count, 1, 'should not trigger observer again');\n});\n\ntestBoth('setting computed prop with same value should not trigger', function(get, set) {\n  \n  var obj = {};\n  SC.defineProperty(obj, 'foo', SC.computed(function(key, value) {\n    if (value !== undefined) this._value = value+' X';\n    return this._value;\n  }));\n  \n  var count = 0;\n  \n  SC.addObserver(obj, 'foo', function() { count++; });\n  \n  set(obj, 'foo', 'bar');\n  equals(count, 1, 'should trigger observer since we do not have existing val');\n  \n  set(obj, 'foo', 'baz');\n  equals(count, 2, 'should trigger observer');\n  \n  set(obj, 'foo', 'baz');\n  equals(count, 2, 'should not trigger observer again');\n});\n\n});");spade.register("sproutcore-metal/~tests/platform/create_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Metal\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-metal');\n\nmodule(\"SC.platform.create()\");\n\ntest(\"should inherit the properties from the parent object\", function() {\n  var obj = { foo: 'FOO' };\n  var obj2 = SC.platform.create(obj);\n  ok(obj !== obj2, 'should be a new instance');\n  equals(obj2.foo, obj.foo, 'should inherit from parent');\n  \n  obj2.foo = 'BAR';\n  equals(obj2.foo, 'BAR', 'should change foo');\n  equals(obj.foo, 'FOO', 'modifying obj2 should not modify obj');\n});\n\ntest(\"passing additional property descriptors should define\", function() {\n  var obj = { foo: 'FOO', repl: 'obj' };\n  var obj2 = SC.platform.create(obj, { \n    bar: {\n      value: 'BAR'    \n    },\n    \n    repl: {\n      value: 'obj2'\n    }\n  });\n  \n  equals(obj2.bar, 'BAR', 'should have defined');\n  equals(obj2.repl, 'obj2', 'should have replaced parent');\n});\n\n\n});");spade.register("sproutcore-metal/~tests/platform/defineProperty_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Metal\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-metal');\n\nfunction isEnumerable(obj, keyName) {\n  var keys = [];\n  for(var key in obj) {\n    if (obj.hasOwnProperty(key)) keys.push(key);\n  }\n  return keys.indexOf(keyName)>=0;\n}\n\nmodule(\"SC.platform.defineProperty()\");\n\ntest(\"defining a simple property\", function() {\n  var obj = {};\n  SC.platform.defineProperty(obj, 'foo', {\n    enumerable:   true,\n    writable:     true,\n    value: 'FOO'\n  });\n  \n  equals(obj.foo, 'FOO', 'should have added property');\n  \n  obj.foo = \"BAR\";\n  equals(obj.foo, 'BAR', 'writable defined property should be writable');\n  equals(isEnumerable(obj, 'foo'), true, 'foo should be enumerable');\n});\n\ntest('defining a read only property', function() {\n  var obj = {};\n  SC.platform.defineProperty(obj, 'foo', {\n    enumerable:   true,\n    writable:     false,\n    value: 'FOO'\n  });\n  \n  equals(obj.foo, 'FOO', 'should have added property');\n  \n  obj.foo = \"BAR\";\n  if (SC.platform.defineProperty.isSimulated) {\n    equals(obj.foo, 'BAR', 'simulated defineProperty should silently work');\n  } else {\n    equals(obj.foo, 'FOO', 'real defined property should not be writable');\n  }\n  \n});\n\ntest('defining a non enumerable property', function() {\n  var obj = {};\n  SC.platform.defineProperty(obj, 'foo', {\n    enumerable:   false,\n    writable:     true,\n    value: 'FOO'\n  });\n  \n  if (SC.platform.defineProperty.isSimulated) {\n    equals(isEnumerable(obj, 'foo'), true, 'simulated defineProperty will leave properties enumerable');\n  } else {\n    equals(isEnumerable(obj, 'foo'), false, 'real defineProperty will make property not-enumerable');\n  }\n});\n\ntest('defining a getter/setter', function() {\n  var obj = {}, getCnt = 0, setCnt = 0, v = 'FOO';\n\n  var desc = {\n    enumerable: true,\n    get: function() { getCnt++; return v; },\n    set: function(val) { setCnt++; v = val; }\n  };\n  \n  if (SC.platform.hasPropertyAccessors) {\n    SC.platform.defineProperty(obj, 'foo', desc);\n    equals(obj.foo, 'FOO', 'should return getter');\n    equals(getCnt, 1, 'should have invoked getter');\n    \n    obj.foo = 'BAR';\n    equals(obj.foo, 'BAR', 'setter should have worked');\n    equals(setCnt, 1, 'should have invoked setter');\n\n  } else {\n    raises(function() {\n      SC.platform.defineProperty(obj, 'foo', desc);\n    }, Error, 'should throw exception if getters/setters not supported');\n  }\n  \n});\n\ntest('defining getter/setter along with writable', function() {\n  var obj  ={};\n  raises(function() {\n    SC.platform.defineProperty(obj, 'foo', {\n      enumerable: true,\n      get: function() {},\n      set: function() {},\n      writable: true\n    });\n  }, Error, 'defining writable and get/set should throw exception');\n});\n\ntest('defining getter/setter along with value', function() {\n  var obj  ={};\n  raises(function() {\n    SC.platform.defineProperty(obj, 'foo', {\n      enumerable: true,\n      get: function() {},\n      set: function() {},\n      value: 'FOO'\n    });\n  }, Error, 'defining value and get/set should throw exception');\n});\n\n});");spade.register("sproutcore-metal/~tests/properties_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.defineProperty');\n\ntest('toString', function() {\n\n  var obj = {};\n  SC.defineProperty(obj, 'toString', SC.SIMPLE_PROPERTY, function() { return 'FOO'; });\n  equals(obj.toString(), 'FOO', 'should replace toString');\n});\n\n});");spade.register("sproutcore-metal/~tests/props_helper", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*global testBoth */\n\n// used by unit tests to test both accessor mode and non-accessor mode\ntestBoth = function(testname, callback) {\n  \n  function scget(x,y) { return SC.get(x,y); }\n  function scset(x,y,z) { return SC.set(x,y,z); }\n  function aget(x,y) { return x[y]; }\n  function aset(x,y,z) { return (x[y] = z); }\n\n  test(testname+' using SC.get()/SC.set()', function() {\n    callback(scget, scset);\n  });\n  \n  test(testname+' using accessors', function() {\n    if (SC.USES_ACCESSORS) callback(aget, aset);\n    else ok('SKIPPING ACCESSORS');\n  });\n};\n\n});");spade.register("sproutcore-metal/~tests/utils/guidFor_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-metal');\n\nmodule(\"SC.guidFor\");\n\nvar sameGuid = function(a, b, message) {\n  equals( SC.guidFor(a), SC.guidFor(b), message );\n};\n\nvar diffGuid = function(a, b, message) {\n  ok( SC.guidFor(a) !== SC.guidFor(b), message);\n};\n\nvar nanGuid = function(obj) {\n  var type = typeof obj;\n  ok( isNaN(parseInt(SC.guidFor(obj), 0)), \"guids for \" + type + \"don't parse to numbers\");\n};\n\ntest(\"Object\", function() {\n  var a = {}, b = {};\n\n  sameGuid( a, a, \"same object always yields same guid\" );\n  diffGuid( a, b, \"different objects yield different guids\" );\n  nanGuid( a );\n});\n\ntest(\"Object with prototype\", function() {\n  var Class = function() { };\n\n  SC.guidFor(Class.prototype);\n\n  var a = new Class();\n  var b = new Class();\n\n  sameGuid( a, b , \"without calling rewatch, objects copy the guid from their prototype\");\n\n  SC.rewatch(a);\n  SC.rewatch(b);\n\n  diffGuid( a, b, \"after calling rewatch, objects don't share guids\" );\n});\n\ntest(\"strings\", function() {\n  var a = \"string A\", aprime = \"string A\", b = \"String B\";\n\n  sameGuid( a, a,      \"same string always yields same guid\" );\n  sameGuid( a, aprime, \"identical strings always yield the same guid\" );\n  diffGuid( a, b,      \"different strings yield different guids\" );\n  nanGuid( a );\n});\n\ntest(\"numbers\", function() {\n  var a = 23, aprime = 23, b = 34;\n\n  sameGuid( a, a,      \"same numbers always yields same guid\" );\n  sameGuid( a, aprime, \"identical numbers always yield the same guid\" );\n  diffGuid( a, b,      \"different numbers yield different guids\" );\n  nanGuid( a );\n});\n\ntest(\"numbers\", function() {\n  var a = true, aprime = true, b = false;\n\n  sameGuid( a, a,      \"same booleans always yields same guid\" );\n  sameGuid( a, aprime, \"identical booleans always yield the same guid\" );\n  diffGuid( a, b,      \"different boolean yield different guids\" );\n  nanGuid( a );\n  nanGuid( b );\n});\n\ntest(\"null and undefined\", function() {\n  var a = null, aprime = null, b = undefined;\n\n  sameGuid( a, a,      \"null always returns the same guid\" );\n  sameGuid( b, b,      \"undefined always returns the same guid\" );\n  sameGuid( a, aprime, \"different nulls return the same guid\" );\n  diffGuid( a, b,      \"null and undefined return different guids\" );\n  nanGuid( a );\n  nanGuid( b );\n});\n\ntest(\"arrays\", function() {\n  var a = [\"a\", \"b\", \"c\"], aprime = [\"a\", \"b\", \"c\"], b = [\"1\", \"2\", \"3\"];\n\n  sameGuid( a, a,      \"same instance always yields same guid\" );\n  diffGuid( a, aprime, \"identical arrays always yield the same guid\" );\n  diffGuid( a, b,      \"different arrays yield different guids\" );\n  nanGuid( a );\n});\n\n\n});");spade.register("sproutcore-metal/~tests/utils/meta_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule(\"SC.meta\");\n\ntest(\"should return the same hash for an object\", function() {\n  var obj = {};\n\n  SC.meta(obj).foo = \"bar\";\n\n  equals(SC.meta(obj).foo, \"bar\", \"returns same hash with multiple calls to SC.meta()\");\n});\n\nmodule(\"SC.metaPath\")\n\ntest(\"should not create nested objects if writable is false\", function() {\n  var obj = {};\n\n  ok(!SC.meta(obj).foo, \"precond - foo property on meta does not yet exist\");\n  equals(SC.metaPath(obj, ['foo', 'bar', 'baz'], false), undefined, \"should return undefined when writable is false and doesn't already exist\") ;\n  equals(SC.meta(obj).foo, undefined, \"foo property is not created\");\n});\n\ntest(\"should create nested objects if writable is true\", function() {\n  var obj = {};\n\n  ok(!SC.meta(obj).foo, \"precond - foo property on meta does not yet exist\");\n\n  equals(typeof SC.metaPath(obj, ['foo', 'bar', 'baz'], true), \"object\", \"should return hash when writable is true and doesn't already exist\") ;\n  ok(SC.meta(obj).foo.bar.baz['bat'] = true, \"can set a property on the newly created hash\");\n});\n\n});");spade.register("sproutcore-metal/~tests/watching/isWatching_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.isWatching');\n\nvar testObserver = function(setup, teardown) {\n  var obj = {}, key = 'foo', fn = function() {};\n\n  equals(SC.isWatching(obj, 'foo'), false, \"precond - isWatching is false by default\");\n  setup(obj, key, fn);\n  equals(SC.isWatching(obj, 'foo'), true, \"isWatching is true when observers are added\");\n  teardown(obj, key, fn);\n  equals(SC.isWatching(obj, 'foo'), false, \"isWatching is false after observers are removed\");\n};\n\ntest(\"isWatching is true for regular local observers\", function() {\n  testObserver(function(obj, key, fn) {\n    SC.Mixin.create({\n      didChange: SC.observer(fn, key)\n    }).apply(obj);\n  }, function(obj, key, fn) {\n    SC.removeObserver(obj, key, null, fn);\n  });\n});\n\ntest(\"isWatching is true for nonlocal observers\", function() {\n  testObserver(function(obj, key, fn) {\n    SC.addObserver(obj, key, obj, fn);\n  }, function(obj, key, fn) {\n    SC.removeObserver(obj, key, obj, fn);\n  });\n});\n\ntest(\"isWatching is true for chained observers\", function() {\n  testObserver(function(obj, key, fn) {\n    SC.addObserver(obj, key + '.bar', obj, fn);\n  }, function(obj, key, fn) {\n    SC.removeObserver(obj, key + '.bar', obj, fn);\n  });\n});\n\ntest(\"isWatching is true for computed properties\", function() {\n  testObserver(function(obj, key, fn) {\n    SC.defineProperty(obj, 'computed', SC.computed(fn).property(key));\n  }, function(obj, key, fn) {\n    SC.defineProperty(obj, 'computed', null);\n  });\n});\n\ntest(\"isWatching is true for computed properties\", function() {\n  testObserver(function(obj, key, fn) {\n    SC.defineProperty(obj, 'computed', SC.computed(fn).property(key + '.bar'));\n  }, function(obj, key, fn) {\n    SC.defineProperty(obj, 'computed', null);\n  });\n});\n\n});");spade.register("sproutcore-metal/~tests/watching/unwatch_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth */\n\n\nrequire('sproutcore-metal/~tests/props_helper');\n\nvar willCount = 0 , didCount = 0, \n    willChange = SC.propertyWillChange, \n    didChange = SC.propertyDidChange;\n\nmodule('SC.unwatch', {\n  setup: function() {\n    willCount = didCount = 0;\n    SC.propertyWillChange = function(cur, keyName) {\n      willCount++;\n      willChange.call(this, cur, keyName);\n    };\n\n    SC.propertyDidChange = function(cur, keyName) {\n      didCount++;\n      didChange.call(this, cur, keyName);\n    };\n  },\n  \n  teardown: function() {\n    SC.propertyWillChange = willChange;\n    SC.propertyDidChange  = didChange;\n  }\n});\n\ntestBoth('unwatching a computed property - regular get/set', function(get, set) {\n\n  var obj = {};\n  SC.defineProperty(obj, 'foo', SC.computed(function(keyName, value) {\n    if (value !== undefined) this.__foo = value;\n    return this.__foo;\n  }));\n  \n  SC.watch(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equals(willCount, 1, 'should have invoked willCount');\n  equals(didCount, 1, 'should have invoked didCount');\n\n  SC.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  set(obj, 'foo', 'BAZ');\n  equals(willCount, 0, 'should NOT have invoked willCount');\n  equals(didCount, 0, 'should NOT have invoked didCount');\n});\n\n\ntestBoth('unwatching a regular property - regular get/set', function(get, set) {\n\n  var obj = { foo: 'BIFF' };\n  \n  SC.watch(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equals(willCount, 1, 'should have invoked willCount');\n  equals(didCount, 1, 'should have invoked didCount');\n\n  SC.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  set(obj, 'foo', 'BAZ');\n  equals(willCount, 0, 'should NOT have invoked willCount');\n  equals(didCount, 0, 'should NOT have invoked didCount');\n});\n\ntest('unwatching should be nested', function() {\n\n  var obj = { foo: 'BIFF' };\n  \n  SC.watch(obj, 'foo');\n  SC.watch(obj, 'foo');\n  SC.set(obj, 'foo', 'bar');\n  equals(willCount, 1, 'should have invoked willCount');\n  equals(didCount, 1, 'should have invoked didCount');\n\n  SC.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  SC.set(obj, 'foo', 'BAZ');\n  equals(willCount, 1, 'should NOT have invoked willCount');\n  equals(didCount, 1, 'should NOT have invoked didCount');\n\n  SC.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  SC.set(obj, 'foo', 'BAZ');\n  equals(willCount, 0, 'should NOT have invoked willCount');\n  equals(didCount, 0, 'should NOT have invoked didCount');\n});\n\n});");spade.register("sproutcore-metal/~tests/watching/watch_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth Global */\n\n\nrequire('sproutcore-metal/~tests/props_helper');\n\nvar willCount = 0 , didCount = 0, \n    willChange = SC.propertyWillChange, \n    didChange = SC.propertyDidChange;\n\nmodule('SC.watch', {\n  setup: function() {\n    willCount = didCount = 0;\n    SC.propertyWillChange = function(cur, keyName) {\n      willCount++;\n      willChange.call(this, cur, keyName);\n    };\n\n    SC.propertyDidChange = function(cur, keyName) {\n      didCount++;\n      didChange.call(this, cur, keyName);\n    };\n  },\n  \n  teardown: function() {\n    SC.propertyWillChange = willChange;\n    SC.propertyDidChange  = didChange;\n  }\n});\n\ntestBoth('watching a computed property', function(get, set) {\n\n  var obj = {};\n  SC.defineProperty(obj, 'foo', SC.computed(function(keyName, value) {\n    if (value !== undefined) this.__foo = value;\n    return this.__foo;\n  }));\n  \n  SC.watch(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equals(willCount, 1, 'should have invoked willCount');\n  equals(didCount, 1, 'should have invoked didCount');\n});\n\ntestBoth('watching a regular defined property', function(get, set) {\n\n  var obj = { foo: 'baz' };\n  \n  SC.watch(obj, 'foo');\n  equals(get(obj, 'foo'), 'baz', 'should have original prop');\n  \n  set(obj, 'foo', 'bar');\n  equals(willCount, 1, 'should have invoked willCount');\n  equals(didCount, 1, 'should have invoked didCount');\n});\n\ntestBoth('watches should inherit', function(get, set) {\n\n  var obj = { foo: 'baz' };\n  var objB = SC.create(obj);\n  \n  SC.watch(obj, 'foo');\n  equals(get(obj, 'foo'), 'baz', 'should have original prop');\n  \n  set(obj, 'foo', 'bar');\n  set(objB, 'foo', 'baz');\n  equals(willCount, 2, 'should have invoked willCount once only');\n  equals(didCount, 2, 'should have invoked didCount once only');\n});\n\ntest(\"watching an object THEN defining it should work also\", function() {\n\n  var obj = {};\n  SC.watch(obj, 'foo');\n  \n  SC.defineProperty(obj, 'foo');\n  SC.set(obj, 'foo', 'bar');\n  \n  equals(SC.get(obj, 'foo'), 'bar', 'should have set');\n  equals(willCount, 1, 'should have invoked willChange once');\n  equals(didCount, 1, 'should have invoked didChange once');\n  \n});\n\ntestBoth('watching an object value then unwatching should restore old value', function(get, set) {\n\n  var obj = { foo: { bar: { baz: { biff: 'BIFF' } } } };\n  SC.watch(obj, 'foo.bar.baz.biff');\n\n  var foo = SC.get(obj, 'foo');\n  equals(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');\n\n  SC.unwatch(obj, 'foo.bar.baz.biff');\n  equals(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');\n});\n\ntestBoth('watching a global object that does not yet exist should queue', function(get, set) {\n\n  Global = null;\n\n  var obj = {};\n  SC.watch(obj, 'Global.foo'); // only works on global chained props\n\n  equals(willCount, 0, 'should not have fired yet');\n  equals(didCount, 0, 'should not have fired yet');\n\n  Global = { foo: 'bar' };\n  SC.watch.flushPending(); // this will also be invoked automatically on ready\n\n  equals(willCount, 0, 'should not have fired yet');\n  equals(didCount, 0, 'should not have fired yet');\n\n  set(Global, 'foo', 'baz');\n\n  // should fire twice because this is a chained property (once on key, once\n  // on path)\n  equals(willCount, 2, 'should be watching');\n  equals(didCount, 2, 'should be watching');\n\n  Global = null; // reset\n});\n\n\n});");