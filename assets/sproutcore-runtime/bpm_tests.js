/* ===========================================================================
   BPM Combined Asset File
   MANIFEST: sproutcore-runtime (2.0.beta.3)
   This file is generated automatically by the bpm (http://www.bpmjs.org)
   =========================================================================*/

spade.register("sproutcore-runtime/~tests/controllers/array_controller_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nmodule(\"sproutcore-runtime/controllers/array_controller_test\");\n\nSC.MutableArrayTests.extend({\n\n  name: 'SC.ArrayController',\n\n  newObject: function(ary) {\n    var ret = ary ? ary.slice() : this.newFixture(3);\n    return SC.ArrayController.create({\n      content: ret\n    });\n  },\n\n  mutate: function(obj) {\n    obj.pushObject(SC.get(obj, 'length')+1);\n  },\n\n  toArray: function(obj) {\n    return obj.toArray ? obj.toArray() : obj.slice();\n  }\n}).run();\n\n});");spade.register("sproutcore-runtime/~tests/core/compare_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Apple Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals module ok equals same test MyApp */\n\n// test parsing of query string\nvar v = [];\nmodule(\"SC.compare()\", {\n  setup: function() {\n    // setup dummy data\n    v[0]  = null;\n    v[1]  = false;\n    v[2]  = true;\n    v[3]  = -12;\n    v[4]  = 3.5;\n    v[5]  = 'a string';\n    v[6]  = 'another string';\n    v[7]  = 'last string';\n    v[8]  = [1,2];\n    v[9]  = [1,2,3];\n    v[10] = [1,3];\n    v[11] = {a: 'hash'};\n    v[12] = SC.Object.create();\n    v[13] = function (a) {return a;};\n  }\n});\n\n\n// ..........................................................\n// TESTS\n// \n\ntest(\"ordering should work\", function() {\n  for (var j=0; j < v.length; j++) {\n    equals(SC.compare(v[j],v[j]), 0, j +' should equal itself');\n    for (var i=j+1; i < v.length; i++) {\n      equals(SC.compare(v[j],v[i]), -1, 'v[' + j + '] (' + SC.typeOf(v[j]) + ') should be smaller than v[' + i + '] (' + SC.typeOf(v[i]) + ')' );\n    }\n    \n  }\n}); \n  \n\n});");spade.register("sproutcore-runtime/~tests/core/copy_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule(\"SproutCore Copy Method\");\n\ntest(\"SC.copy null\", function() {\n  var obj = {field: null};\n  equal(SC.copy(obj, true).field, null, \"null should still be null\")\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/core/isEqual_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n// ========================================================================\n// SC.isEqual Tests\n// ========================================================================\n/*globals module test */\n\n\nmodule(\"isEqual\");\n\ntest(\"undefined and null\", function() {\n  ok(  SC.isEqual(undefined, undefined), \"undefined is equal to undefined\" );\n  ok( !SC.isEqual(undefined, null),      \"undefined is not equal to null\" );\n  ok(  SC.isEqual(null, null),           \"null is equal to null\" );\n  ok( !SC.isEqual(null, undefined),      \"null is not equal to undefined\" );\n});\n\ntest(\"strings should be equal\",function(){\n\tok( !SC.isEqual(\"Hello\", \"Hi\"),    \"different Strings are unequal\" );\n\tok(  SC.isEqual(\"Hello\", \"Hello\"), \"same Strings are equal\" );\n});\n\ntest(\"numericals should be equal\",function(){\n  ok(  SC.isEqual(24, 24), \"same numbers are equal\" );\n\tok( !SC.isEqual(24, 21), \"different numbers are inequal\" );\n});\n\ntest(\"array should be equal\",function(){\n\t// NOTE: We don't test for array contents -- that would be too expensive.\n\tok( !SC.isEqual( [1,2], [1,2] ), 'two array instances with the same values should not be equal' );\n\tok( !SC.isEqual( [1,2], [1] ),   'two array instances with different values should not be equal' );\n});\n\ntest(\"first object implements isEqual should use it\", function() {\n  ok(SC.isEqual({ isEqual: function() { return true; } }, null), 'should return true always');\n  \n  var obj = { isEqual: function() { return false; } };\n  equals(SC.isEqual(obj, obj), false, 'should return false because isEqual returns false');\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/core/keys_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n// ========================================================================\n// SC.keys Tests\n// ========================================================================\n/*globals module test */\n\n\nmodule(\"Fetch Keys \");\n\ntest(\"should get a key array for a specified object \",function(){\n\tvar object1 = {};\n\n\tobject1.names = \"Rahul\";\n\tobject1.age = \"23\";\n\tobject1.place = \"Mangalore\";\n\n\tvar object2 = [];\n\tobject2 = SC.keys(object1);\n\tsame(object2,['names','age','place']);\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/core/type_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule(\"SproutCore Type Checking\");\n\ntest(\"SC.typeOf\", function() {\n\tvar a = null,\n\t    arr = [1,2,3],\n\t    obj = {},\n      object = SC.Object.create({ method: function() {} });\n\n  equals(SC.typeOf(undefined),     'undefined', \"item of type undefined\");\n  equals(SC.typeOf(a),             'null',      \"item of type null\");\n\tequals(SC.typeOf(arr),           'array',     \"item of type array\");\n\tequals(SC.typeOf(obj),           'object',    \"item of type object\");\n\tequals(SC.typeOf(object),        'instance',  \"item of type instance\");\n\tequals(SC.typeOf(object.method), 'function',  \"item of type function\") ;\n\tequals(SC.typeOf(SC.Object),     'class',     \"item of type class\");\n  equals(SC.typeOf(new Error()),   'error',     \"item of type error\");\n});\n\ntest(\"SC.none\", function() {\n  var string = \"string\", fn = function() {};\n\n  equals(true,  SC.none(null),      \"for null\");\n  equals(true,  SC.none(undefined), \"for undefined\");\n  equals(false, SC.none(\"\"),        \"for an empty String\");\n  equals(false, SC.none(true),      \"for true\");\n  equals(false, SC.none(false),     \"for false\");\n  equals(false, SC.none(string),    \"for a String\");\n  equals(false, SC.none(fn),        \"for a Function\");\n  equals(false, SC.none(0),         \"for 0\");\n  equals(false, SC.none([]),        \"for an empty Array\");\n  equals(false, SC.none({}),        \"for an empty Object\");\n});\n\ntest(\"SC.empty\", function() {\n  var string = \"string\", fn = function() {};\n\n  equals(true,  SC.empty(null),      \"for null\");\n  equals(true,  SC.empty(undefined), \"for undefined\");\n  equals(true,  SC.empty(\"\"),        \"for an empty String\");\n  equals(false, SC.empty(true),      \"for true\");\n  equals(false, SC.empty(false),     \"for false\");\n  equals(false, SC.empty(string),    \"for a String\");\n  equals(false, SC.empty(fn),        \"for a Function\");\n  equals(false, SC.empty(0),         \"for 0\");\n  equals(false, SC.empty([]),        \"for an empty Array\");\n  equals(false, SC.empty({}),        \"for an empty Object\");\n});\n\ntest(\"SC.isArray\" ,function(){\n  var numarray      = [1,2,3],\n      number        = 23,\n      strarray      = [\"Hello\", \"Hi\"],\n      string        = \"Hello\",\n      object         = {},\n      length        = {length: 12},\n      fn            = function() {};\n\n  equals( SC.isArray(numarray), true,  \"[1,2,3]\" );\n  equals( SC.isArray(number),   false, \"23\" );\n  equals( SC.isArray(strarray), true,  '[\"Hello\", \"Hi\"]' );\n  equals( SC.isArray(string),   false, '\"Hello\"' );\n  equals( SC.isArray(object),   false, \"{}\" );\n  equals( SC.isArray(length),   true,  \"{length: 12}\" );\n  equals( SC.isArray(window),   false, \"window\" );\n  equals( SC.isArray(fn),       false, \"function() {}\" );\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/ext/function_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth */\n\n\nrequire('sproutcore-runtime/~tests/props_helper');\n\nmodule('Function.prototype.observes() helper');\n\ntestBoth('global observer helper takes multiple params', function(get, set) {\n\n  if (SC.ENHANCE_PROTOTYPES === false) {\n    ok('Function.prototype helper disabled');\n    return ;\n  }\n  \n  var MyMixin = SC.Mixin.create({\n    \n    count: 0,\n    \n    foo: function() {\n      set(this, 'count', get(this, 'count')+1);\n    }.observes('bar', 'baz')\n\n  });\n\n  var obj = SC.mixin({}, MyMixin);\n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  set(obj, 'baz', \"BAZ\");\n  equals(get(obj, 'count'), 2, 'should invoke observer after change');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/ext/mixin_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n\nmodule('system/mixin/binding_test');\n\ntest('Defining a property ending in Binding should setup binding when applied', function() {\n\n  var MyMixin = SC.Mixin.create({\n    fooBinding: 'bar.baz'\n  });\n  \n  var obj = { bar: { baz: 'BIFF' } };\n  MyMixin.apply(obj);\n  SC.run.sync(); // let bindings sync...\n  \n  ok(SC.get(obj, 'fooBinding') instanceof SC.Binding, 'should be a binding object');\n  equals(SC.get(obj, 'foo'), 'BIFF', 'binding should be created and synced');\n  \n});\n\ntest('Defining a property ending in Binding should apply to prototype children', function() {\n\n  var MyMixin = SC.Mixin.create({\n    fooBinding: 'bar.baz'\n  });\n  \n  var obj = { bar: { baz: 'BIFF' } };\n  MyMixin.apply(obj);\n\n  var obj2 = SC.create(obj);\n  SC.set(SC.get(obj2, 'bar'), 'baz', 'BARG');\n  \n  SC.run.sync(); // let bindings sync...\n  \n  ok(SC.get(obj2, 'fooBinding') instanceof SC.Binding, 'should be a binding object');\n  equals(SC.get(obj2, 'foo'), 'BARG', 'binding should be created and synced');\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/mixins/observable/chained_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * changed obj.set() and obj.get() to SC.set() and SC.get()\n  * changed obj.addObserver() to SC.addObserver()\n*/\n\n\nvar get = SC.get, set = SC.set;\n\nmodule(\"SC.Observable - Observing with @each\");\n\ntest(\"chained observers on enumerable properties are triggered when the observed property of any item changes\", function() {\n  var family = SC.Object.create({ momma: null });\n  var momma = SC.Object.create({ children: [] });\n\n  var child1 = SC.Object.create({ name: \"Bartholomew\" });\n  var child2 = SC.Object.create({ name: \"Agnes\" });\n  var child3 = SC.Object.create({ name: \"Dan\" });\n  var child4 = SC.Object.create({ name: \"Nancy\" });\n\n  set(family, 'momma', momma);\n  set(momma, 'children', [child1, child2, child3]);\n\n  var observerFiredCount = 0;\n  SC.addObserver(family, 'momma.children.@each.name', this, function() {\n    observerFiredCount++;\n  });\n\n  observerFiredCount = 0;\n  SC.run(function() { get(momma, 'children').setEach('name', 'Juan'); });\n  equals(observerFiredCount, 3, \"observer fired after changing child names\");\n\n  observerFiredCount = 0;\n  SC.run(function() { get(momma, 'children').pushObject(child4); });\n  equals(observerFiredCount, 1, \"observer fired after adding a new item\");\n\n  observerFiredCount = 0;\n  SC.run(function() { set(child4, 'name', \"Herbert\"); });\n  equals(observerFiredCount, 1, \"observer fired after changing property on new object\");\n\n  set(momma, 'children', []);\n\n  observerFiredCount = 0;\n  SC.run(function() { set(child1, 'name', \"Hanna\"); });\n  equals(observerFiredCount, 0, \"observer did not fire after removing changing property on a removed object\");\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/mixins/observable/observable_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar get = SC.get, set = SC.set;\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * Added ObservableObject which applies the SC.Observable mixin.\n  * Changed reference to SC.T_FUNCTION to 'function'\n  * Changed all references to sc_super to this._super()\n  * Changed SC.objectForPropertyPath() to SC.getPath()\n  * Removed allPropertiesDidChange test - no longer supported\n  * Changed test that uses 'ObjectE' as path to 'objectE' to reflect new \n    rule on using capital letters for property paths.\n  * Removed test passing context to addObserver.  context param is no longer\n    supported.\n  * Changed calls to SC.Binding.flushPendingChanges() -> SC.run.sync()\n  * removed test in observer around line 862 that expected key/value to be\n    the last item in the chained path.  Should be root and chained path\n  \n*/\n\n// ========================================================================\n// SC.Observable Tests\n// ========================================================================\n/*globals module test ok isObj equals expects Namespace DepObj */\n\nvar object, ObjectC, ObjectD, objectA, objectB ;\n\nvar ObservableObject = SC.Object.extend(SC.Observable);\n\n// ..........................................................\n// GET()\n//\n\nmodule(\"object.get()\", {\n\n  setup: function() {\n    object = ObservableObject.create(SC.Observable, {\n\n      normal: 'value',\n      numberVal: 24,\n      toggleVal: true,\n\n      computed: function() { return 'value'; }.property(),\n\n      method: function() { return \"value\"; },\n\n      nullProperty: null,\n\n      unknownProperty: function(key, value) {\n        this.lastUnknownProperty = key ;\n        this._super(key, value);\n        return \"unknown\" ;\n      }\n\n    });\n  }\n\n});\n\ntest(\"should get normal properties\", function() {\n  equals(object.get('normal'), 'value') ;\n});\n\ntest(\"should call computed properties and return their result\", function() {\n  equals(object.get(\"computed\"), \"value\") ;\n});\n\ntest(\"should return the function for a non-computed property\", function() {\n  var value = object.get(\"method\") ;\n  equals(SC.typeOf(value), 'function') ;\n});\n\ntest(\"should return null when property value is null\", function() {\n  equals(object.get(\"nullProperty\"), null) ;\n});\n\ntest(\"should call unknownProperty when value is undefined\", function() {\n  equals(object.get(\"unknown\"), \"unknown\") ;\n  equals(object.lastUnknownProperty, \"unknown\") ;\n});\n\n// ..........................................................\n// SC.GET()\n//\nmodule(\"SC.get()\", {\n  setup: function() {\n    objectA = ObservableObject.create({\n\n      normal: 'value',\n      numberVal: 24,\n      toggleVal: true,\n\n      computed: function() { return 'value'; }.property(),\n\n      method: function() { return \"value\"; },\n\n      nullProperty: null,\n\n      unknownProperty: function(key, value) {\n        this.lastUnknownProperty = key ;\n        this._super(key, value);\n        return \"unknown\" ;\n      }\n\n    });\n\n    objectB = {\n      normal: 'value',\n\n      nullProperty: null\n    };\n  }\n});\n\ntest(\"should get normal properties on SC.Observable\", function() {\n  equals(SC.get(objectA, 'normal'), 'value') ;\n});\n\ntest(\"should call computed properties on SC.Observable and return their result\", function() {\n  equals(SC.get(objectA, \"computed\"), \"value\") ;\n});\n\ntest(\"should return the function for a non-computed property on SC.Observable\", function() {\n  var value = SC.get(objectA, \"method\") ;\n  equals(SC.typeOf(value), 'function') ;\n});\n\ntest(\"should return null when property value is null on SC.Observable\", function() {\n  equals(SC.get(objectA, \"nullProperty\"), null) ;\n});\n\ntest(\"should call unknownProperty when value is undefined on SC.Observable\", function() {\n  equals(SC.get(object, \"unknown\"), \"unknown\") ;\n  equals(object.lastUnknownProperty, \"unknown\") ;\n});\n\ntest(\"should get normal properties on standard objects\", function() {\n  equals(SC.get(objectB, 'normal'), 'value');\n});\n\ntest(\"should return null when property is null on standard objects\", function() {\n  equals(SC.get(objectB, 'nullProperty'), null);\n});\n\ntest(\"raise if the provided object is null\", function() {\n  raises(function() {\n    SC.get(null, 'key');\n  })\n});\n\ntest(\"raise if the provided object is undefined\", function() {\n  raises(function() {\n    SC.get(undefined, 'key');\n  })\n});\n\ntest(\"should work when object is SC (used in SC.getPath)\", function() {\n  equals(SC.getPath('SC.RunLoop'), SC.RunLoop, 'SC.getPath');\n  equals(SC.get('RunLoop'), SC.RunLoop, 'SC.get(RunLoop)');\n  equals(SC.get(SC, 'RunLoop'), SC.RunLoop, 'SC.get(SC, RunLoop)');\n});\n\nmodule(\"SC.getPath()\");\n\ntest(\"should return a property at a given path relative to the window\", function() {\n  window.Foo = ObservableObject.create({\n    Bar: ObservableObject.create({\n      Baz: function() { return \"blargh\"; }.property()\n    })\n  });\n\n  try {\n    equals(SC.getPath('Foo.Bar.Baz'), \"blargh\");\n  } finally {\n    window.Foo = undefined;\n  }\n});\n\ntest(\"should return a property at a given path relative to the passed object\", function() {\n  var foo = ObservableObject.create({\n    bar: ObservableObject.create({\n      baz: function() { return \"blargh\"; }.property()\n    })\n  });\n\n  equals(SC.getPath(foo, 'bar.baz'), \"blargh\");\n});\n\ntest(\"should return a property at a given path relative to the window - JavaScript hash\", function() {\n  window.Foo = {\n    Bar: {\n      Baz: \"blargh\"\n    }\n  };\n\n  try {\n    equals(SC.getPath('Foo.Bar.Baz'), \"blargh\");\n  } finally {\n    window.Foo = undefined;\n  }\n});\n\ntest(\"should return a property at a given path relative to the passed object - JavaScript hash\", function() {\n  var foo = {\n    bar: {\n      baz: \"blargh\"\n    }\n  };\n\n  equals(SC.getPath(foo, 'bar.baz'), \"blargh\");\n});\n\n// ..........................................................\n// SET()\n//\n\nmodule(\"object.set()\", {\n\n  setup: function() {\n    object = ObservableObject.create({\n\n      // normal property\n      normal: 'value',\n\n      // computed property\n      _computed: \"computed\",\n      computed: function(key, value) {\n        if (value !== undefined) {\n          this._computed = value ;\n        }\n        return this._computed ;\n      }.property(),\n\n      // method, but not a property\n      _method: \"method\",\n      method: function(key, value) {\n        if (value !== undefined) {\n          this._method = value ;\n        }\n        return this._method ;\n      },\n\n      // null property\n      nullProperty: null,\n\n      // unknown property\n      _unknown: 'unknown',\n      unknownProperty: function(key) {\n        this._super(key);\n        return this._unknown ;\n      },\n\n      setUnknownProperty: function(key, value) {\n        this._unknown = value ;\n        this._super(key, value);\n        return this._unknown ;\n      }\n    });\n  }\n\n});\n\ntest(\"should change normal properties and return this\", function() {\n  var ret = object.set(\"normal\", \"changed\") ;\n  equals(object.normal, \"changed\") ;\n  equals(ret, object) ;\n});\n\ntest(\"should call computed properties passing value and return this\", function() {\n  var ret = object.set(\"computed\", \"changed\") ;\n  equals(object._computed, \"changed\") ;\n  \n  // DISABLED: this is no longer true with accessors\n  //equals(SC.typeOf(object.computed), 'function') ;\n\n  equals(ret, object) ;\n});\n\ntest(\"should change normal properties when passing undefined\", function() {\n  var ret = object.set('normal', undefined);\n  equals(object.normal, undefined);\n  equals(ret, object);\n});\n\ntest(\"should replace the function for a non-computed property and return this\", function() {\n  var ret = object.set(\"method\", \"changed\") ;\n  equals(object._method, \"method\") ; // make sure this was NOT run\n  ok(SC.typeOf(object.method) !== 'function') ;\n  equals(ret, object) ;\n});\n\ntest(\"should replace prover when property value is null\", function() {\n  var ret = object.set(\"nullProperty\", \"changed\") ;\n  equals(object.nullProperty, \"changed\") ;\n  equals(ret, object) ;\n});\n\ntest(\"should call unknownProperty with value when property is undefined\", function() {\n  var ret = object.set(\"unknown\", \"changed\") ;\n  equals(object._unknown, \"changed\") ;\n  equals(ret, object) ;\n});\n\n// ..........................................................\n// COMPUTED PROPERTIES\n//\n\nmodule(\"Computed properties\", {\n  setup: function() {\n    object = ObservableObject.create({\n\n      // REGULAR\n\n      computedCalls: [],\n      computed: function(key, value) {\n        this.computedCalls.push(value);\n        return 'computed';\n      }.property(),\n\n      computedCachedCalls: [],\n      computedCached: function(key, value) {\n        this.computedCachedCalls.push(value);\n        return 'computedCached';\n      }.property().cacheable(),\n\n\n      // DEPENDENT KEYS\n\n      changer: 'foo',\n\n      dependentCalls: [],\n      dependent: function(key, value) {\n        this.dependentCalls.push(value);\n        return 'dependent';\n      }.property('changer'),\n\n      dependentCachedCalls: [],\n      dependentCached: function(key, value) {\n        this.dependentCachedCalls.push(value);\n        return 'dependentCached';\n      }.property('changer').cacheable(),\n\n      // everytime it is recomputed, increments call\n      incCallCount: 0,\n      inc: function() {\n        return this.incCallCount++;\n      }.property('changer').cacheable(),\n\n      // depends on cached property which depends on another property...\n      nestedIncCallCount: 0,\n      nestedInc: function(key, value) {\n        return this.nestedIncCallCount++;\n      }.property('inc').cacheable(),\n\n      // two computed properties that depend on a third property\n      state: 'on',\n      isOn: function(key, value) {\n        if (value !== undefined) this.set('state', 'on');\n        return this.get('state') === 'on';\n      }.property('state'),\n\n      isOff: function(key, value) {\n        if (value !== undefined) this.set('state', 'off');\n        return this.get('state') === 'off';\n      }.property('state')\n\n    }) ;\n  }\n});\n\ntest(\"getting values should call function return value\", function() {\n\n  // get each property twice. Verify return.\n  var keys = 'computed computedCached dependent dependentCached'.w();\n\n  keys.forEach(function(key) {\n    equals(object.get(key), key, 'Try #1: object.get(%@) should run function'.fmt(key));\n    equals(object.get(key), key, 'Try #2: object.get(%@) should run function'.fmt(key));\n  });\n\n  // verify each call count.  cached should only be called once\n  'computedCalls dependentCalls'.w().forEach(function(key) {\n    equals(object[key].length, 2, 'non-cached property %@ should be called 2x'.fmt(key));\n  });\n\n  'computedCachedCalls dependentCachedCalls'.w().forEach(function(key) {\n    equals(object[key].length, 1, 'non-cached property %@ should be called 1x'.fmt(key));\n  });\n\n});\n\ntest(\"setting values should call function return value\", function() {\n\n  // get each property twice. Verify return.\n  var keys = 'computed dependent computedCached dependentCached'.w();\n  var values = 'value1 value2'.w();\n\n  keys.forEach(function(key) {\n\n    equals(object.set(key, values[0]), object, 'Try #1: object.set(%@, %@) should run function'.fmt(key, values[0]));\n\n    equals(object.set(key, values[1]), object, 'Try #2: object.set(%@, %@) should run function'.fmt(key, values[1]));\n    \n    equals(object.set(key, values[1]), object, 'Try #3: object.set(%@, %@) should not run function since it is setting same value as before'.fmt(key, values[1]));\n\n  });\n\n\n  // verify each call count.  cached should only be called once\n  keys.forEach(function(key) {\n    var calls = object[key + 'Calls'], idx;\n    var expectedLength;\n\n    // Cached properties first check their cached value before setting the\n    // property. Other properties blindly call set.\n    expectedLength = 3;\n    equals(calls.length, expectedLength, 'set(%@) should be called the right amount of times'.fmt(key));\n    for(idx=0;idx<2;idx++) {\n      equals(calls[idx], values[idx], 'call #%@ to set(%@) should have passed value %@'.fmt(idx+1, key, values[idx]));\n    }\n  });\n\n});\n\ntest(\"notify change should clear cache\", function() {\n\n  // call get several times to collect call count\n  object.get('computedCached'); // should run func\n  object.get('computedCached'); // should not run func\n\n  object.propertyWillChange('computedCached')\n    .propertyDidChange('computedCached');\n\n  object.get('computedCached'); // should run again\n  equals(object.computedCachedCalls.length, 2, 'should have invoked method 2x');\n});\n\ntest(\"change dependent should clear cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('inc'); // should run func\n  equals(object.get('inc'), ret1, 'multiple calls should not run cached prop');\n\n  object.set('changer', 'bar');\n\n  equals(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again\n});\n\ntest(\"just notifying change of dependent should clear cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('inc'); // should run func\n  equals(object.get('inc'), ret1, 'multiple calls should not run cached prop');\n\n  object.notifyPropertyChange('changer');\n\n  equals(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again\n});\n\ntest(\"changing dependent should clear nested cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('nestedInc'); // should run func\n  equals(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');\n\n  object.set('changer', 'bar');\n\n  equals(object.get('nestedInc'), ret1+1, 'should increment after dependent key changes'); // should run again\n\n});\n\ntest(\"just notifying change of dependent should clear nested cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('nestedInc'); // should run func\n  equals(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');\n\n  object.notifyPropertyChange('changer');\n\n  equals(object.get('nestedInc'), ret1+1, 'should increment after dependent key changes'); // should run again\n\n});\n\n\n// This verifies a specific bug encountered where observers for computed\n// properties would fire before their prop caches were cleared.\ntest(\"change dependent should clear cache when observers of dependent are called\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('inc'); // should run func\n  equals(object.get('inc'), ret1, 'multiple calls should not run cached prop');\n\n  // add observer to verify change...\n  object.addObserver('inc', this, function() {\n    equals(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again\n  });\n\n  // now run\n  object.set('changer', 'bar');\n\n});\n\ntest('setting one of two computed properties that depend on a third property should clear the kvo cache', function() {\n  // we have to call set twice to fill up the cache\n  object.set('isOff', YES);\n  object.set('isOn', YES);\n\n  // setting isOff to YES should clear the kvo cache\n  object.set('isOff', YES);\n  equals(object.get('isOff'), YES, 'object.isOff should be YES');\n  equals(object.get('isOn'), NO, 'object.isOn should be NO');\n});\n\ntest(\"dependent keys should be able to be specified as property paths\", function() {\n  var depObj = ObservableObject.create({\n    menu: ObservableObject.create({\n      price: 5\n    }),\n\n    menuPrice: function() {\n      return this.getPath('menu.price');\n    }.property('menu.price').cacheable()\n  });\n\n  equals(depObj.get('menuPrice'), 5, \"precond - initial value returns 5\");\n\n  depObj.setPath('menu.price', 6);\n\n  equals(depObj.get('menuPrice'), 6, \"cache is properly invalidated after nested property changes\");\n});\n\ntest(\"nested dependent keys should propagate after they update\", function() {\n  window.DepObj = ObservableObject.create({\n    restaurant: ObservableObject.create({\n      menu: ObservableObject.create({\n        price: 5\n      })\n    }),\n\n    price: function() {\n      return this.getPath('restaurant.menu.price');\n    }.property('restaurant.menu.price')\n  });\n\n  var bindObj = ObservableObject.create({\n    priceBinding: \"DepObj.price\"\n  });\n\n  SC.run.sync();\n\n  equals(bindObj.get('price'), 5, \"precond - binding propagates\");\n\n  DepObj.setPath('restaurant.menu.price', 10);\n\n  SC.run.sync();\n\n  equals(bindObj.get('price'), 10, \"binding propagates after a nested dependent keys updates\");\n\n  DepObj.setPath('restaurant.menu', ObservableObject.create({\n    price: 15\n  }));\n\n  SC.run.sync();\n\n  equals(bindObj.get('price'), 15, \"binding propagates after a middle dependent keys updates\");\n});\n\ntest(\"cacheable nested dependent keys should clear after their dependencies update\", function() {\n  window.DepObj = ObservableObject.create({\n    restaurant: ObservableObject.create({\n      menu: ObservableObject.create({\n        price: 5\n      })\n    }),\n\n    price: function() {\n      return this.getPath('restaurant.menu.price');\n    }.property('restaurant.menu.price').cacheable()\n  });\n\n  SC.run.sync();\n\n  equals(DepObj.get('price'), 5, \"precond - computed property is correct\");\n\n  DepObj.setPath('restaurant.menu.price', 10);\n\n  equals(DepObj.get('price'), 10, \"cacheable computed properties are invalidated even if no run loop occurred\");\n  DepObj.setPath('restaurant.menu.price', 20);\n\n  equals(DepObj.get('price'), 20, \"cacheable computed properties are invalidated after a second get before a run loop\");\n\n  SC.run.sync();\n\n  equals(DepObj.get('price'), 20, \"precond - computed properties remain correct after a run loop\");\n\n  DepObj.setPath('restaurant.menu', ObservableObject.create({\n    price: 15\n  }));\n\n  equals(DepObj.get('price'), 15, \"cacheable computed properties are invalidated after a middle property changes\");\n\n  DepObj.setPath('restaurant.menu', ObservableObject.create({\n    price: 25\n  }));\n\n  equals(DepObj.get('price'), 25, \"cacheable computed properties are invalidated after a middle property changes again, before a run loop\");\n});\n\n\n\n// ..........................................................\n// OBSERVABLE OBJECTS\n//\n\nmodule(\"Observable objects & object properties \", {\n\n  setup: function() {\n    object = ObservableObject.create({\n\n      normal: 'value',\n      abnormal: 'zeroValue',\n      numberVal: 24,\n      toggleVal: true,\n      observedProperty: 'beingWatched',\n      testRemove: 'observerToBeRemoved',\n      normalArray: [1,2,3,4,5],\n\n      getEach: function() {\n        var keys = ['normal','abnormal'];\n        var ret = [];\n        for(var idx=0; idx<keys.length;idx++) {\n          ret[ret.length] = this.getPath(keys[idx]);\n        }\n        return ret ;\n      },\n\n      newObserver:function(){\n        this.abnormal = 'changedValueObserved';\n      },\n\n      testObserver:function(){\n        this.abnormal = 'removedObserver';\n      }.observes('normal'),\n\n      testArrayObserver:function(){\n        this.abnormal = 'notifiedObserver';\n      }.observes('*normalArray.[]')\n\n    });\n  }\n\n});\n\ntest('incrementProperty and decrementProperty',function(){\n  var newValue = object.incrementProperty('numberVal');\n  equals(25,newValue,'numerical value incremented');\n  object.numberVal = 24;\n  newValue = object.decrementProperty('numberVal');\n  equals(23,newValue,'numerical value decremented');\n  object.numberVal = 25;\n  newValue = object.incrementProperty('numberVal', 5);\n  equals(30,newValue,'numerical value incremented by specified increment');\n  object.numberVal = 25;\n  newValue = object.decrementProperty('numberVal',5);\n  equals(20,newValue,'numerical value decremented by specified increment');\n});\n\ntest('toggle function, should be boolean',function(){\n  equals(object.toggleProperty('toggleVal',true,false),object.get('toggleVal'));\n  equals(object.toggleProperty('toggleVal',true,false),object.get('toggleVal'));\n  equals(object.toggleProperty('toggleVal',undefined,undefined),object.get('toggleVal'));\n});\n\ntest('should notify array observer when array changes',function(){\n  get(object, 'normalArray').replace(0,0,6);\n  equals(object.abnormal, 'notifiedObserver', 'observer should be notified');\n});\n\n\nmodule(\"object.addObserver()\", {\n  setup: function() {\n\n    ObjectC = ObservableObject.create({\n\n      objectE:ObservableObject.create({\n        propertyVal:\"chainedProperty\"\n      }),\n\n      normal: 'value',\n      normal1: 'zeroValue',\n      normal2: 'dependentValue',\n      incrementor: 10,\n\n      action: function() {\n        this.normal1= 'newZeroValue';\n      },\n\n      observeOnceAction: function() {\n        this.incrementor= this.incrementor+1;\n      },\n\n      chainedObserver:function(){\n        this.normal2 = 'chainedPropertyObserved' ;\n      }\n\n    });\n  }\n});\n\ntest(\"should register an observer for a property\", function() {\n  ObjectC.addObserver('normal', ObjectC, 'action');\n  ObjectC.set('normal','newValue');\n  equals(ObjectC.normal1, 'newZeroValue');\n});\n\ntest(\"should register an observer for a property - Special case of chained property\", function() {\n  ObjectC.addObserver('objectE.propertyVal',ObjectC,'chainedObserver');\n  ObjectC.objectE.set('propertyVal',\"chainedPropertyValue\");\n  equals('chainedPropertyObserved',ObjectC.normal2);\n  ObjectC.normal2 = 'dependentValue';\n  ObjectC.set('objectE','');\n  equals('chainedPropertyObserved',ObjectC.normal2);\n});\n\nmodule(\"object.removeObserver()\", {\n  setup: function() {\n    ObjectD = ObservableObject.create({\n\n      objectF:ObservableObject.create({\n        propertyVal:\"chainedProperty\"\n      }),\n\n      normal: 'value',\n      normal1: 'zeroValue',\n      normal2: 'dependentValue',\n      ArrayKeys: ['normal','normal1'],\n\n      addAction: function() {\n        this.normal1 = 'newZeroValue';\n      },\n      removeAction: function() {\n        this.normal2 = 'newDependentValue';\n      },\n      removeChainedObserver:function(){\n        this.normal2 = 'chainedPropertyObserved' ;\n      },\n\n      observableValue: \"hello world\",\n\n      observer1: function() {\n        // Just an observer\n      },\n      observer2: function() {\n        this.removeObserver('observableValue', null, 'observer1');\n        this.removeObserver('observableValue', null, 'observer2');\n        this.hasObserverFor('observableValue');   // Tickle 'getMembers()'\n        this.removeObserver('observableValue', null, 'observer3');\n      },\n      observer3: function() {\n        // Just an observer\n      }\n    });\n\n  }\n});\n\ntest(\"should unregister an observer for a property\", function() {\n  ObjectD.addObserver('normal', ObjectD, 'addAction');\n  ObjectD.set('normal','newValue');\n  equals(ObjectD.normal1, 'newZeroValue');\n\n  ObjectD.set('normal1','zeroValue');\n\n  ObjectD.removeObserver('normal', ObjectD, 'addAction');\n  ObjectD.set('normal','newValue');\n  equals(ObjectD.normal1, 'zeroValue');\n});\n\n\ntest(\"should unregister an observer for a property - special case when key has a '.' in it.\", function() {\n  ObjectD.addObserver('objectF.propertyVal',ObjectD,'removeChainedObserver');\n  ObjectD.objectF.set('propertyVal',\"chainedPropertyValue\");\n  ObjectD.removeObserver('objectF.propertyVal',ObjectD,'removeChainedObserver');\n  ObjectD.normal2 = 'dependentValue';\n  ObjectD.objectF.set('propertyVal',\"removedPropertyValue\");\n  equals('dependentValue',ObjectD.normal2);\n  ObjectD.set('objectF','');\n  equals('dependentValue',ObjectD.normal2);\n});\n\n\ntest(\"removing an observer inside of an observer shouldn’t cause any problems\", function() {\n  // The observable system should be protected against clients removing\n  // observers in the middle of observer notification.\n  var encounteredError = NO;\n  try {\n    ObjectD.addObserver('observableValue', null, 'observer1');\n    ObjectD.addObserver('observableValue', null, 'observer2');\n    ObjectD.addObserver('observableValue', null, 'observer3');\n    SC.run(function() { ObjectD.set('observableValue', \"hi world\"); });\n  }\n  catch(e) {\n    encounteredError = YES;\n  }\n  equals(encounteredError, NO);\n});\n\n\n\nmodule(\"Bind function \", {\n\n  setup: function() {\n    objectA = ObservableObject.create({\n      name: \"Sproutcore\",\n      location: \"Timbaktu\"\n    });\n\n    objectB = ObservableObject.create({\n      normal: \"value\",\n      computed:function() {\n        this.normal = 'newValue';\n      }\n    }) ;\n\n    Namespace = {\n      objectA: objectA,\n      objectB: objectB\n    } ;\n  }\n});\n\ntest(\"should bind property with method parameter as undefined\", function() {\n  // creating binding\n  objectA.bind(\"name\", \"Namespace.objectB.normal\",undefined) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  objectB.set(\"normal\", \"changedValue\") ;\n\n  // support new-style bindings if available\n  SC.run.sync();\n  equals(\"changedValue\", objectA.get(\"name\"), \"objectA.name is binded\");\n});\n\n// ..........................................................\n// SPECIAL CASES\n//\n\ntest(\"changing chained observer object to null should not raise exception\", function() {\n\n  var obj = ObservableObject.create({\n    foo: ObservableObject.create({\n      bar: ObservableObject.create({ bat: \"BAT\" })\n    })\n  });\n\n  var callCount = 0;\n  obj.foo.addObserver('bar.bat', obj, function(target, key, value) {\n    callCount++;\n  });\n\n  SC.run(function() {\n    obj.foo.set('bar', null);\n  });\n\n  equals(callCount, 1, 'changing bar should trigger observer');\n  expect(1);\n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/mixins/observable/observersForKey_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * Create ObservableObject which includes SC.Observable\n*/\n\n// ========================================================================\n// SC.Observable Tests\n// ========================================================================\n/*globals module test ok isObj equals expects Namespace */\n\n\nvar ObservableObject = SC.Object.extend(SC.Observable);\n\n// ..........................................................\n// GET()\n//\n\nmodule(\"object.observesForKey()\", {\n\n});\n\ntest(\"should get observers\", function() {\n  var o1 = ObservableObject.create({ foo: 100 }),\n      o2 = ObservableObject.create({ func: function() {} }),\n      o3 = ObservableObject.create({ func: function() {} }),\n      observers = null;\n      \n  equals(o1.observersForKey('foo').get('length'), 0, \"o1.observersForKey should return empty array\");\n  \n  o1.addObserver('foo', o2, o2.func);\n  o1.addObserver('foo', o3, o3.func);\n  \n  observers = o1.observersForKey('foo');\n    \n  equals(observers.get('length'), 2, \"o2.observersForKey should return an array with length 2\");\n  equals(observers[0][0], o2, \"first item in observers array should be o2\");\n  equals(observers[1][0], o3, \"second item in observers array should be o3\");\n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/mixins/observable/propertyChanges_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * Create ObservableObject which includes SC.Observable\n  * Remove test that tests internal _kvo_changeLevel property.  This is an\n    implementation detail.\n  * Remove test for allPropertiesDidChange\n  * Removed star observer test.  no longer supported\n  * Removed property revision test.  no longer supported\n*/\n\n// ========================================================================\n// SC.Observable Tests\n// ========================================================================\n/*globals module test ok isObj equals expects */\n\n\nvar ObservableObject = SC.Object.extend(SC.Observable);\n\nvar revMatches = NO , ObjectA;\n\nmodule(\"object.propertyChanges\", {  \n  setup: function() {\n    ObjectA = ObservableObject.create({\n      foo  : 'fooValue',\n      prop : 'propValue',\n            \n      action: function() {\n        this.set('prop', 'changedPropValue');\n      }.observes('foo'),\n      \n      newFoo : 'newFooValue',\n      newProp: 'newPropValue',\n      \n      notifyAction: function() {\n        this.set('newProp', 'changedNewPropValue');\n      }.observes('newFoo'),\n      \n      notifyAllAction: function() {\n        this.set('newFoo', 'changedNewFooValue');\n      }.observes('prop'),\n\n      starProp: null,\n      starObserver: function(target, key, value, rev) {\n        revMatches = (rev === target.propertyRevision) ;\n        this.starProp = key;\n      }\n      \n    });\n    }\n});\n\n\ntest(\"should observe the changes within the nested begin / end property changes\", function() {\n    \n  //start the outer nest\n  ObjectA.beginPropertyChanges();\n    // Inner nest\n    ObjectA.beginPropertyChanges();\n        ObjectA.set('foo', 'changeFooValue');\n      equals(ObjectA.prop, \"propValue\") ;\n      ObjectA.endPropertyChanges();\n    \n    //end inner nest\n    ObjectA.set('prop', 'changePropValue');\n    equals(ObjectA.newFoo, \"newFooValue\") ;\n  //close the outer nest\n  ObjectA.endPropertyChanges();\n  \n  equals(ObjectA.prop, \"changedPropValue\") ;\n  equals(ObjectA.newFoo, \"changedNewFooValue\") ;\n  \n});\n\ntest(\"should observe the changes within the begin and end property changes\", function() {\n    \n  ObjectA.beginPropertyChanges();\n    ObjectA.set('foo', 'changeFooValue');\n    \n  equals(ObjectA.prop, \"propValue\") ;\n    ObjectA.endPropertyChanges();\n    \n  equals(ObjectA.prop, \"changedPropValue\") ;\n});\n\ntest(\"should indicate that the property of an object has just changed\", function() {\n  // inidicate that proprty of foo will change to its subscribers\n  ObjectA.propertyWillChange('foo') ;\n  \n  //Value of the prop is unchanged yet as this will be changed when foo changes\n  equals(ObjectA.prop, 'propValue' ) ;\n  \n  //change the value of foo.\n  ObjectA.set('foo', 'changeFooValue');\n  \n  // Indicate the subscribers of foo that the value has just changed\n  ObjectA.propertyDidChange('foo', null) ;\n  \n  // Values of prop has just changed\n  equals(ObjectA.prop,'changedPropValue') ;\n});\n\ntest(\"should notify that the property of an object has changed\", function() {\n  // Notify to its subscriber that the values of 'newFoo' will be changed. In this\n  // case the observer is \"newProp\". Therefore this will call the notifyAction function\n  // and value of \"newProp\" will be changed.\n  ObjectA.notifyPropertyChange('newFoo','fooValue');\n  \n  //value of newProp changed.\n  equals(ObjectA.newProp,'changedNewPropValue') ;\n});\n\ntest(\"should invalidate function property cache when notifyPropertyChange is called\", function() {\n  \n  var a = ObservableObject.create({\n    _b: null,\n    b: function(key, value) {\n      if (value !== undefined) {\n        this._b = value;\n        return this;\n      }\n      return this._b;\n    }.property()\n  });\n  \n  a.set('b', 'foo');\n  equals(a.get('b'), 'foo', 'should have set the correct value for property b');\n  \n  a._b = 'bar';\n  a.notifyPropertyChange('b');\n  a.set('b', 'foo');\n  equals(a.get('b'), 'foo', 'should have invalidated the cache so that the newly set value is actually set');\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/system/binding_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * All calls to SC.run.sync() were changed to \n    SC.run.sync()\n    \n  * Bindings no longer accept a root object as their second param.  Instead \n    our test binding objects were put under a single object they could \n    originate from.\n  \n  * tests that inspected internal properties were removed.\n  \n  * converted foo.get/foo.set to use SC.get/SC.set\n  \n  * Removed tests for SC.Binding.isConnected.  Since binding instances are now\n    shared this property no longer makes sense.\n    \n  * Changed call calls for obj.bind(...) to SC.bind(obj, ...);\n  \n  * Changed all calls to sc_super() to this._super()\n  \n  * Changed all calls to disconnect() to pass the root object.\n  \n  * removed calls to SC.Binding.destroy() as that method is no longer useful\n    (or defined)\n    \n  * changed use of T_STRING to 'string'\n*/\n\n\nvar get = SC.get, set = SC.set;\n\n// ========================================================================\n// SC.Binding Tests\n// ========================================================================\n/*globals TestNamespace */\n\nvar fromObject, toObject, binding, Bon1, bon2, root ; // global variables\n\nmodule(\"basic object binding\", {\n\n  setup: function() {\n    fromObject = SC.Object.create({ value: 'start' }) ;\n    toObject = SC.Object.create({ value: 'end' }) ;\n    root = { fromObject: fromObject, toObject: toObject };\n    binding = SC.bind(root, 'toObject.value', 'fromObject.value');\n    SC.run.sync() ; // actually sets up up the connection\n  }\n});\n\ntest(\"binding should have synced on connect\", function() {\n  equals(get(toObject, \"value\"), \"start\", \"toObject.value should match fromObject.value\");\n});\n\ntest(\"fromObject change should propogate to toObject only after flush\", function() {\n  set(fromObject, \"value\", \"change\") ;\n  equals(get(toObject, \"value\"), \"start\") ;\n  SC.run.sync() ;\n  equals(get(toObject, \"value\"), \"change\") ;\n});\n\ntest(\"toObject change should propogate to fromObject only after flush\", function() {\n  set(toObject, \"value\", \"change\") ;\n  equals(get(fromObject, \"value\"), \"start\") ;\n  SC.run.sync() ;\n  equals(get(fromObject, \"value\"), \"change\") ;\n});\n\ntest(\"suspended observing during bindings\", function() {\n\n  // setup special binding\n  fromObject = SC.Object.create({\n    value1: 'value1',\n    value2: 'value2'\n  });\n\n  toObject = SC.Object.create({\n    value1: 'value1',\n    value2: 'value2',\n\n    callCount: 0,\n\n    observer: function() {\n      equals(get(this, 'value1'), 'CHANGED', 'value1 when observer fires');\n      equals(get(this, 'value2'), 'CHANGED', 'value2 when observer fires');\n      this.callCount++;\n    }.observes('value1', 'value2')\n  });\n\n  var root = { fromObject: fromObject, toObject: toObject };\n  SC.bind(root, 'toObject.value1', 'fromObject.value1');\n  SC.bind(root, 'toObject.value2', 'fromObject.value2');\n\n  // change both value1 + value2, then  flush bindings.  observer should only\n  // fire after bindings are done flushing.\n  set(fromObject, 'value1', 'CHANGED');\n  set(fromObject, 'value2', 'CHANGED');\n  SC.run.sync();\n\n  equals(toObject.callCount, 2, 'should call observer twice');\n});\n\ntest(\"binding disconnection actually works\", function() {\n  binding.disconnect(root);\n  set(fromObject, 'value', 'change');\n  SC.run.sync();\n  equals(get(toObject, 'value'), 'start');\n});\n\n// ..........................................................\n// one way binding\n// \n\nmodule(\"one way binding\", {\n\n  setup: function() {\n    fromObject = SC.Object.create({ value: 'start' }) ;\n    toObject = SC.Object.create({ value: 'end' }) ;\n    root = { fromObject: fromObject, toObject: toObject };\n    binding = SC.oneWay(root, 'toObject.value', 'fromObject.value');\n    SC.run.sync() ; // actually sets up up the connection\n  }\n\n});\n\ntest(\"fromObject change should propogate after flush\", function() {\n  set(fromObject, \"value\", \"change\") ;\n  equals(get(toObject, \"value\"), \"start\") ;\n  SC.run.sync() ;\n  equals(get(toObject, \"value\"), \"change\") ;\n});\n\ntest(\"toObject change should NOT propogate\", function() {\n  set(toObject, \"value\", \"change\") ;\n  equals(get(fromObject, \"value\"), \"start\") ;\n  SC.run.sync() ;\n  equals(get(fromObject, \"value\"), \"start\") ;\n});\n\nvar first, second, third, binding1, binding2 ; // global variables\n\n// ..........................................................\n// chained binding\n// \n\nmodule(\"chained binding\", {\n\n  setup: function() {\n    first = SC.Object.create({ output: 'first' }) ;\n\n    second = SC.Object.create({\n      input: 'second',\n      output: 'second',\n\n      inputDidChange: function() {\n        set(this, \"output\", get(this, \"input\")) ;\n      }.observes(\"input\")\n    }) ;\n\n    third = SC.Object.create({ input: \"third\" }) ;\n\n    root = { first: first, second: second, third: third };\n    binding1 = SC.bind(root, 'second.input', 'first.output');\n    binding2 = SC.bind(root, 'second.output', 'third.input');\n    SC.run.sync() ; // actually sets up up the connection\n  }\n\n});\n\ntest(\"changing first output should propograte to third after flush\", function() {\n  set(first, \"output\", \"change\") ;\n  equals(\"change\", get(first, \"output\"), \"first.output\") ;\n  ok(\"change\" !== get(third, \"input\"), \"third.input\") ;\n\n  var didChange = YES;\n  while(didChange) didChange = SC.run.sync() ;\n\n  equals(\"change\", get(first, \"output\"), \"first.output\") ;\n  equals(\"change\", get(second, \"input\"), \"second.input\") ;\n  equals(\"change\", get(second, \"output\"), \"second.output\") ;\n  equals(\"change\", get(third,\"input\"), \"third.input\") ;\n});\n\n// ..........................................................\n// Custom Binding\n// \n\nmodule(\"Custom Binding\", {\n\n  setup: function() {\n\tBon1 = SC.Object.extend({\n\t\tvalue1: \"hi\",\n\t\tvalue2: 83,\n\t\tarray1: []\n\t});\n\n\tbon2 = SC.Object.create({\n\t\tval1: \"hello\",\n\t\tval2: 25,\n\t\tarr: [1,2,3,4]\n\t});\n\n\tTestNamespace = {\n      bon2: bon2,\n      Bon1: Bon1\n    } ;\n  },\n\n  teardown: function() {\n    Bon1 = bon2 = TestNamespace  = null;\n  }\n});\n\ntest(\"Binding value1 such that it will recieve only single values\", function() {\n\tvar bon1 = Bon1.create({\n\t\tvalue1Binding: SC.Binding.single(\"TestNamespace.bon2.val1\"),\n\t\tarray1Binding: SC.Binding.single(\"TestNamespace.bon2.arr\")\n\t});\n\tSC.run.sync();\n\tvar a = [23,31,12,21];\n\tset(bon2, \"arr\", a);\n\tset(bon2, \"val1\",\"changed\");\n\tSC.run.sync();\n\tequals(get(bon2, \"val1\"),get(bon1, \"value1\"));\n\tequals(\"@@MULT@@\",get(bon1, \"array1\"));\n});\n\ntest(\"Single binding using notEmpty function.\", function() {\n  // This should raise an exception for SC 1.x developers who are using\n  // the old syntax.\n  raises(function() {\n    var bond = Bon1.create ({\n      array1Binding: SC.Binding.single(\"TestNamespace.bon2.arr\").notEmpty(null,'(EMPTY)')\n    });\n  });\n});\n\ntest(\"Binding with transforms, function to check the type of value\", function() {\n\tvar jon = Bon1.create({\n\t\tvalue1Binding: SC.Binding.transform({\n      to: function(val1) {\n        return (SC.typeOf(val1) == 'string')? val1 : \"\";\n      }\n    }).from(\"TestNamespace.bon2.val1\")\n\t});\n\tSC.run.sync();\n\tset(bon2, \"val1\",\"changed\");\n\tSC.run.sync();\n\tequals(get(jon, \"value1\"), get(bon2, \"val1\"));\n});\n\ntest(\"two bindings to the same value should sync in the order they are initialized\", function() {\n\n  SC.RunLoop.begin();\n\n  var a = SC.Object.create({\n    foo: \"bar\"\n  });\n\n  var b = SC.Object.create({\n    foo: \"baz\",\n    fooBinding: \"a.foo\",\n\n    a: a,\n    \n    C: SC.Object.extend({\n      foo: \"bee\",\n      fooBinding: \"owner.foo\"\n    }),\n\n    init: function() {\n      this._super();\n      set(this, 'c', this.C.create({ owner: this }));\n    }\n\n  });\n\n  SC.RunLoop.end();\n\n  equals(get(a, 'foo'), \"bar\", 'a.foo should not change');\n  equals(get(b, 'foo'), \"bar\", 'a.foo should propogate up to b.foo');\n  equals(get(b.c, 'foo'), \"bar\", 'a.foo should propogate up to b.c.foo');\n});\n\n// ..........................................................\n// AND BINDING\n// \n\nmodule(\"AND binding\", {\n\n  setup: function() {\n    // temporarily set up two source objects in the SC namespace so we can\n    // use property paths to access them\n    SC.set(SC, 'testControllerA', SC.Object.create({ value: NO }));\n    SC.set(SC, 'testControllerB', SC.Object.create({ value: NO }));\n\n    toObject = SC.Object.create({\n      value: null,\n      valueBinding: SC.Binding.and('SC.testControllerA.value', 'SC.testControllerB.value')\n    });\n  },\n\n  teardown: function() {\n    set(SC, 'testControllerA', null);\n    set(SC, 'testControllerB', null);\n  }\n\n});\n\ntest(\"toObject.value should be YES if both sources are YES\", function() {\n  SC.RunLoop.begin();\n  set(SC.testControllerA, 'value', YES);\n  set(SC.testControllerB, 'value', YES);\n  SC.RunLoop.end();\n\n  SC.run.sync();\n  equals(get(toObject, 'value'), YES);\n});\n\ntest(\"toObject.value should be NO if either source is NO\", function() {\n  SC.RunLoop.begin();\n  set(SC.testControllerA, 'value', YES);\n  set(SC.testControllerB, 'value', NO);\n  SC.RunLoop.end();\n\n  SC.run.sync();\n  equals(get(toObject, 'value'), NO);\n\n  SC.RunLoop.begin();\n  set(SC.testControllerA, 'value', YES);\n  set(SC.testControllerB, 'value', YES);\n  SC.RunLoop.end();\n\n  SC.run.sync();\n  equals(get(toObject, 'value'), YES);\n\n  SC.RunLoop.begin();\n  set(SC.testControllerA, 'value', NO);\n  set(SC.testControllerB, 'value', YES);\n  SC.RunLoop.end();\n\n  SC.run.sync();\n  equals(get(toObject, 'value'), NO);\n});\n\n// ..........................................................\n// OR BINDING\n// \n\nmodule(\"OR binding\", {\n\n  setup: function() {\n    // temporarily set up two source objects in the SC namespace so we can\n    // use property paths to access them\n    SC.set(SC, 'testControllerA', SC.Object.create({ value: NO }));\n    SC.set(SC, 'testControllerB', SC.Object.create({ value: null }));\n\n    toObject = SC.Object.create({\n      value: null,\n      valueBinding: SC.Binding.or('SC.testControllerA.value', 'SC.testControllerB.value')\n    });\n  },\n\n  teardown: function() {\n    set(SC, 'testControllerA', null);\n    set(SC, 'testControllerB', null);\n  }\n\n});\n\ntest(\"toObject.value should be first value if first value is truthy\", function() {\n  SC.RunLoop.begin();\n  set(SC.testControllerA, 'value', 'first value');\n  set(SC.testControllerB, 'value', 'second value');\n  SC.RunLoop.end();\n\n  SC.run.sync();\n  equals(get(toObject, 'value'), 'first value');\n});\n\ntest(\"toObject.value should be second value if first is falsy\", function() {\n  SC.RunLoop.begin();\n  set(SC.testControllerA, 'value', NO);\n  set(SC.testControllerB, 'value', 'second value');\n  SC.RunLoop.end();\n\n  SC.run.sync();\n  equals(get(toObject, 'value'), 'second value');\n});\n\n// ..........................................................\n// BINDING WITH []\n// \n\nmodule(\"Binding with '[]'\", {\n  setup: function() {\n    fromObject = SC.Object.create({ value: [] });\n    toObject = SC.Object.create({ value: '' });\n    root = { toObject: toObject, fromObject: fromObject };\n    \n    binding = SC.bind(root, 'toObject.value', 'fromObject.value.[]').transform(function(v) {\n      return v ? v.join(',') : '';\n    });\n  },\n  \n  teardown: function() {\n    root = fromObject = toObject = null;\n  }\n});\n\ntest(\"Binding refreshes after a couple of items have been pushed in the array\", function() {\n  get(fromObject, 'value').pushObjects(['foo', 'bar']);\n  SC.run.sync();\n  equals(get(toObject, 'value'), 'foo,bar');\n});\n\n\n// ..........................................................\n// propertyNameBinding with longhand\n// \n\nmodule(\"propertyNameBinding with longhand\", {\n  setup: function(){\n    TestNamespace = {\n      fromObject: SC.Object.create({\n        value: \"originalValue\"\n      }),\n      \n      toObject: SC.Object.create({\n        valueBinding: SC.Binding.from('TestNamespace.fromObject.value'),\n        localValue: \"originalLocal\",\n        relativeBinding: SC.Binding.from('.localValue')\n      })\n    };\n    \n    SC.run.sync();\n  },\n  teardown: function(){\n    TestNamespace = null;\n  }\n});\n\ntest(\"works with full path\", function(){\n\n  set(TestNamespace.fromObject, 'value', \"updatedValue\");\n  SC.run.sync();\n  \n  equals(get(TestNamespace.toObject, 'value'), \"updatedValue\");\n\n  set(TestNamespace.fromObject, 'value', \"newerValue\");\n  SC.run.sync();\n\n  equals(get(TestNamespace.toObject, 'value'), \"newerValue\");\n});\n\ntest(\"works with local path\", function(){\n  set(TestNamespace.toObject, 'localValue', \"updatedValue\");\n  SC.run.sync();\n\n  equals(get(TestNamespace.toObject, 'relative'), \"updatedValue\");\n\n  set(TestNamespace.toObject, 'localValue', \"newerValue\");\n  SC.run.sync();\n\n  equals(get(TestNamespace.toObject, 'relative'), \"newerValue\");\n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/system/object/base_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * Changed get(obj, ) and set(obj, ) to SC.get() and SC.set()\n  * Removed obj.instanceOf() and obj.kindOf() tests.  use obj instanceof Foo \n    instead\n  * Removed respondsTo() and tryToPerform() tests.  Can be brought back in a \n    utils package.\n  * Removed destroy() test.  You can impl yourself but not built in\n  * Changed Class.subclassOf() test to Class.detect()\n  * Remove broken test for 'superclass' property.\n  * Removed obj.didChangeFor()\n*/\n\n// ========================================================================\n// SC.Object Base Tests\n// ========================================================================\n/*globals module test ok isObj equals expects same plan TestNamespace*/\n\n\nvar obj, obj1, don, don1 ; // global variables\n\nvar get = SC.get, set = SC.set;\n\nmodule(\"A new SC.Object instance\", {\n\n  setup: function() {\n    obj = SC.Object.create({\n      foo: \"bar\",\n      total: 12345,\n      aMethodThatExists: function() {},\n      aMethodThatReturnsTrue: function() { return true; },\n      aMethodThatReturnsFoobar: function() { return \"Foobar\"; },\n      aMethodThatReturnsFalse: function() { return NO; }\n    });\n  },\n\n  teardown: function() {\n    obj = undefined ;\n  }\n\n});\n\ntest(\"Should return it's properties when requested using SC.Object#get\", function() {\n  equals(get(obj, 'foo'), 'bar') ;\n  equals(get(obj, 'total'), 12345) ;\n});\n\ntest(\"Should allow changing of those properties by calling SC.Object#set\", function() {\n  equals(get(obj,'foo'), 'bar') ;\n  equals(get(obj, 'total'), 12345) ;\n\n  set(obj,  'foo', 'Chunky Bacon' ) ;\n  set(obj,  'total', 12 ) ;\n\n  equals(get(obj, 'foo'), 'Chunky Bacon') ;\n  equals(get(obj, 'total'), 12) ;\n});\n\n\nmodule(\"SC.Object observers\", {\n  setup: function() {\n    // create a namespace\n    TestNamespace = {\n      obj: SC.Object.create({\n        value: \"test\"\n      })\n    };\n\n    // create an object\n    obj = SC.Object.create({\n      prop1: null,\n\n      // normal observer\n      observer: function(){\n        this._normal = YES;\n      }.observes(\"prop1\"),\n\n      globalObserver: function() {\n        this._global = YES;\n      }.observes(\"TestNamespace.obj.value\"),\n\n      bothObserver: function() {\n        this._both = YES;\n      }.observes(\"prop1\", \"TestNamespace.obj.value\")\n    });\n\n  }\n});\n\ntest(\"Local observers work\", function() {\n  obj._normal = NO;\n  set(obj, \"prop1\", NO);\n  equals(obj._normal, YES, \"Normal observer did change.\");\n});\n\ntest(\"Global observers work\", function() {\n  obj._global = NO;\n  set(TestNamespace.obj, \"value\", \"test2\");\n  equals(obj._global, YES, \"Global observer did change.\");\n});\n\ntest(\"Global+Local observer works\", function() {\n  obj._both = NO;\n  set(obj, \"prop1\", NO);\n  equals(obj._both, YES, \"Both observer did change.\");\n});\n\n\n\nmodule(\"SC.Object superclass and subclasses\", {\n  setup: function() {\n    obj = SC.Object.extend ({\n\t  method1: function() {\n\t\treturn \"hello\";\n\t  }\n\t});\n\tobj1 = obj.extend();\n\tdon = obj1.create ({\n\t  method2: function() {\n\t\t  return this.superclass();\n\t\t}\n\t});\n  },\n\n  teardown: function() {\n\tobj = undefined ;\n    obj1 = undefined ;\n    don = undefined ;\n  }\n});\n\ntest(\"Checking the detect() function on an object and its subclass\", function(){\n\tequals(obj.detect(obj1), YES);\n\tequals(obj1.detect(obj), NO);\n});\n\ntest(\"subclasses should contain defined subclasses\", function() {\n  ok(obj.subclasses.contains(obj1), 'obj.subclasses should contain obj1');\n\n  equals(get(obj1.subclasses, 'length'),0,'obj1.subclasses should be empty');\n\n  var kls2 = obj1.extend();\n  ok(obj1.subclasses.contains(kls2), 'obj1.subclasses should contain kls2');\n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/system/object/bindings_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * changed SC.Bending.flushPendingChanges() -> SC.run.sync();\n  * changes obj.set() and obj.get() to SC.set() and SC.get()\n  * Fixed an actual bug in unit tests around line 133\n  * fixed 'bindings should disconnect on destroy' test to use SC.destroy.\n*/\n\n// ========================================================================\n// SC.Object bindings Tests\n// ========================================================================\n/*globals module test ok isObj equals expects TestNamespace */\n\n\nvar testObject, fromObject, extraObject, TestObject;\n\nvar set = SC.set, get = SC.get;\n\nmodule(\"bind() method\", {\n\n  setup: function() {\n    testObject = SC.Object.create({\n      foo: \"bar\",\n      bar: \"foo\",\n      extraObject: null\n    });\n\n    fromObject = SC.Object.create({\n      bar: \"foo\",\n      extraObject: null\n    }) ;\n\n    extraObject = SC.Object.create({\n      foo: \"extraObjectValue\"\n    }) ;\n\n    TestNamespace = {\n      fromObject: fromObject,\n      testObject: testObject\n    } ;\n  },\n\n  teardown: function() {\n    testObject = fromObject = extraObject = null ;\n  }\n\n});\n\ntest(\"bind(TestNamespace.fromObject.bar) should follow absolute path\", function() {\n  // create binding\n  testObject.bind(\"foo\", \"TestNamespace.fromObject.bar\") ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", \"changedValue\") ;\n\n  // support new-style bindings if available\n  SC.run.sync();\n  equals(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\ntest(\"bind(.bar) should bind to relative path\", function() {\n  // create binding\n  testObject.bind(\"foo\", \".bar\") ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(testObject, \"bar\", \"changedValue\") ;\n\n  SC.run.sync();\n  equals(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\ntest(\"SC.Binding.bool(TestNamespace.fromObject.bar)) should create binding with bool transform\", function() {\n  // create binding\n  testObject.bind(\"foo\", SC.Binding.bool(\"TestNamespace.fromObject.bar\")) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", 1) ;\n\n  SC.run.sync();\n  equals(YES, get(testObject, \"foo\"), \"testObject.foo == YES\");\n\n  set(fromObject, \"bar\", 0) ;\n\n  SC.run.sync();\n  equals(NO, get(testObject, \"foo\"), \"testObject.foo == NO\");\n});\n\ntest(\"bind(TestNamespace.fromObject*extraObject.foo) should create chained binding\", function() {\n  testObject.bind(\"foo\", \"TestNamespace.fromObject*extraObject.foo\");\n  SC.run.sync() ; // actually sets up up the binding\n\n  set(fromObject, \"extraObject\", extraObject) ;\n\n  SC.run.sync();\n  equals(\"extraObjectValue\", get(testObject, \"foo\"), \"testObject.foo\") ;\n});\n\ntest(\"bind(*extraObject.foo) should create locally chained binding\", function() {\n  testObject.bind(\"foo\", \"*extraObject.foo\");\n  SC.run.sync() ; // actually sets up up the binding\n\n  set(testObject, \"extraObject\", extraObject) ;\n\n  SC.run.sync();\n  equals(\"extraObjectValue\", get(testObject, \"foo\"), \"testObject.foo\") ;\n});\n\n\n// The following contains no test\ntest(\"bind(*extraObject.foo) should be disconnectable\", function() {\n  var binding = testObject.bind(\"foo\", \"*extraObject.foo\");\n  SC.run.sync() ; // actually sets up up the binding\n\n  binding.disconnect(testObject);\n\n  set(testObject, 'extraObject', extraObject);\n  SC.run.sync() ;\n\n  // there was actually a bug here - the binding above should have synced to\n  // null as there was no original value\n  equals(null, get(testObject, \"foo\"), \"testObject.foo after disconnecting\");\n});\n\nmodule(\"fooBinding method\", {\n\n  setup: function() {\n    TestObject = SC.Object.extend({\n      foo: \"bar\",\n      bar: \"foo\",\n      extraObject: null\n    });\n\n    fromObject = SC.Object.create({\n      bar: \"foo\",\n      extraObject: null\n    }) ;\n\n    extraObject = SC.Object.create({\n      foo: \"extraObjectValue\"\n    }) ;\n\n    TestNamespace = {\n      fromObject: fromObject,\n      testObject: TestObject\n    } ;\n  },\n\n  teardown: function() {\n    TestObject = fromObject = extraObject = null ;\n  //  delete TestNamespace ;\n  }\n\n});\n\ntest(\"fooBinding: TestNamespace.fromObject.bar should follow absolute path\", function() {\n  // create binding\n  testObject = TestObject.create({\n    fooBinding: \"TestNamespace.fromObject.bar\"\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", \"changedValue\") ;\n\n  SC.run.sync();\n  equals(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\ntest(\"fooBinding: .bar should bind to relative path\", function() {\n\n  testObject = TestObject.create({\n    fooBinding: \".bar\"\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(testObject, \"bar\", \"changedValue\") ;\n\n  SC.run.sync();\n  equals(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\ntest(\"fooBinding: SC.Binding.bool(TestNamespace.fromObject.bar should create binding with bool transform\", function() {\n\n  testObject = TestObject.create({\n    fooBinding: SC.Binding.bool(\"TestNamespace.fromObject.bar\")\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", 1) ;\n\n  SC.run.sync();\n  equals(YES, get(testObject, \"foo\"), \"testObject.foo == YES\");\n\n  set(fromObject, \"bar\", 0) ;\n\n  SC.run.sync();\n  equals(NO, get(testObject, \"foo\"), \"testObject.foo == NO\");\n});\n\ntest(\"fooBinding: TestNamespace.fromObject*extraObject.foo should create chained binding\", function() {\n\n  testObject = TestObject.create({\n    fooBinding: \"TestNamespace.fromObject*extraObject.foo\"\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  set(fromObject, \"extraObject\", extraObject) ;\n\n  SC.run.sync();\n  equals(\"extraObjectValue\", get(testObject, \"foo\"), \"testObject.foo\") ;\n});\n\ntest(\"fooBinding: *extraObject.foo should create locally chained binding\", function() {\n\n  testObject = TestObject.create({\n    fooBinding: \"*extraObject.foo\"\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  set(testObject, \"extraObject\", extraObject) ;\n\n  SC.run.sync();\n  equals(\"extraObjectValue\", get(testObject, \"foo\"), \"testObject.foo\") ;\n});\n\ntest('fooBinding: should disconnect bindings when destroyed', function () {\n\n  testObject = TestObject.create({\n    fooBinding: \"TestNamespace.fromObject.bar\"\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  set(TestNamespace.fromObject, 'bar', 'BAZ');\n  SC.run.sync();\n  equals(get(testObject, 'foo'), 'BAZ', 'binding should have synced');\n\n  SC.destroy(testObject);\n  set(TestNamespace.fromObject, 'bar', 'BIFF');\n  SC.run.sync();\n  ok(get(testObject, 'foo') !== 'bar', 'binding should not have synced');\n});\n\nmodule(\"fooBindingDefault: SC.Binding.Bool (old style)\", {\n\n  setup: function() {\n    TestObject = SC.Object.extend({\n      foo: \"bar\",\n      fooBindingDefault: SC.Binding.bool(),\n      bar: \"foo\",\n      extraObject: null\n    });\n\n    fromObject = SC.Object.create({\n      bar: \"foo\",\n      extraObject: null\n    }) ;\n\n    TestNamespace = {\n      fromObject: fromObject,\n      testObject: TestObject\n    } ;\n  },\n\n  teardown: function() {\n    TestObject = fromObject = null ;\n //   delete TestNamespace ;\n  }\n\n});\n\ntest(\"fooBinding: TestNamespace.fromObject.bar should have bool binding\", function() {\n  // create binding\n  testObject = TestObject.create({\n    fooBinding: \"TestNamespace.fromObject.bar\"\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", 1) ;\n\n  SC.run.sync();\n  equals(YES, get(testObject, \"foo\"), \"testObject.foo == YES\");\n\n  set(fromObject, \"bar\", 0) ;\n\n  SC.run.sync();\n  equals(NO, get(testObject, \"foo\"), \"testObject.foo == NO\");\n});\n\ntest(\"fooBinding: SC.Binding.not(TestNamespace.fromObject.bar should override default\", function() {\n\n  testObject = TestObject.create({\n    fooBinding: SC.Binding.not(\"TestNamespace.fromObject.bar\")\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", 1) ;\n\n  SC.run.sync();\n  equals(NO, get(testObject, \"foo\"), \"testObject.foo == NO\");\n\n  set(fromObject, \"bar\", 0) ;\n\n  SC.run.sync();\n  equals(YES, get(testObject, \"foo\"), \"testObject.foo == YES\");\n});\n\nmodule(\"fooBindingDefault: SC.Binding.bool() (new style)\", {\n\n  setup: function() {\n    TestObject = SC.Object.extend({\n      foo: \"bar\",\n      fooBindingDefault: SC.Binding.bool(),\n      bar: \"foo\",\n      extraObject: null\n    });\n\n    fromObject = SC.Object.create({\n      bar: \"foo\",\n      extraObject: null\n    }) ;\n\n    TestNamespace = {\n      fromObject: fromObject,\n      testObject: testObject\n    } ;\n  },\n\n  teardown: function() {\n    TestObject = fromObject = null ;\n   // delete TestNamespace ;\n  }\n\n});\n\ntest(\"fooBinding: TestNamespace.fromObject.bar should have bool binding\", function() {\n  // create binding\n  testObject = TestObject.create({\n    fooBinding: \"TestNamespace.fromObject.bar\"\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", 1) ;\n\n  SC.run.sync();\n  equals(YES, get(testObject, \"foo\"), \"testObject.foo == YES\");\n\n  set(fromObject, \"bar\", 0) ;\n\n  SC.run.sync();\n  equals(NO, get(testObject, \"foo\"), \"testObject.foo == NO\");\n});\n\ntest(\"fooBinding: SC.Binding.not(TestNamespace.fromObject.bar should override default\", function() {\n\n  testObject = TestObject.create({\n    fooBinding: SC.Binding.not(\"TestNamespace.fromObject.bar\")\n  }) ;\n  SC.run.sync() ; // actually sets up up the binding\n\n  // now make a change to see if the binding triggers.\n  set(fromObject, \"bar\", 1) ;\n\n  SC.run.sync();\n  equals(NO, get(testObject, \"foo\"), \"testObject.foo == NO\");\n\n  set(fromObject, \"bar\", 0) ;\n\n  SC.run.sync();\n  equals(YES, get(testObject, \"foo\"), \"testObject.foo == YES\");\n});\n\ntest(\"Chained binding should be null if intermediate object in chain is null\", function() {\n  var a, z;\n\n  a = SC.Object.create({\n    b: SC.Object.create({\n      c: 'c'\n    }),\n    zBinding: '*b.c'\n  });\n\n  SC.run.sync();\n  equals(get(a, 'z'), 'c', \"a.z == 'c'\");\n\n  set(a, 'b', null);\n  SC.run.sync();\n  equals(get(a, 'z'), null, \"a.z == null\");\n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/system/object/concatenated_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n\n  * changed get(obj, ) and set(obj, ) to SC.get() and SC.set()\n  * converted uses of obj.isEqual() to use same() test since isEqual is not \n    always defined\n*/\n\n\n\n\n  var klass, get = SC.get, set = SC.set;\n\n  module(\"SC.Object Concatenated Properties\", {\n    setup: function(){\n      klass = SC.Object.extend({\n        concatenatedProperties: ['values'],\n        values: ['a', 'b', 'c']\n      });\n    }\n  });\n\n  test(\"concatenates instances\", function() {\n    var obj = klass.create({\n      values: ['d', 'e', 'f']\n    });\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    same(values, expected, \"should concatenate values property (expected: %@, got: %@)\".fmt(expected, values));\n  });\n\n  test(\"concatenates subclasses\", function() {\n    var subKlass = klass.extend({\n      values: ['d', 'e', 'f']\n    });\n    var obj = subKlass.create();\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    same(values, expected, \"should concatenate values property (expected: %@, got: %@)\".fmt(expected, values));\n  });\n\n  test(\"concatenates reopen\", function() {\n    klass.reopen({\n      values: ['d', 'e', 'f']\n    });\n    var obj = klass.create();\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    same(values, expected, \"should concatenate values property (expected: %@, got: %@)\".fmt(expected, values));\n  });\n\n  test(\"concatenates mixin\", function() {\n    var mixin = {\n      values: ['d', 'e']\n    };\n    var subKlass = klass.extend(mixin, {\n      values: ['f']\n    });\n    var obj = subKlass.create();\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    same(values, expected, \"should concatenate values property (expected: %@, got: %@)\".fmt(expected, values));\n  });\n\n  test(\"concatenates reopen, subclass, and instance\", function() {\n    klass.reopen({ values: ['d'] });\n    var subKlass = klass.extend({ values: ['e'] });\n    var obj = subKlass.create({ values: ['f'] });\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    same(values, expected, \"should concatenate values property (expected: %@, got: %@)\".fmt(expected, values));\n  });\n\n\n\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/system/run_loop_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n  \n  CHANGES FROM 1.6:\n  \n  * Updated the API usage for setting up and syncing SC.Binding since these \n    are not the APIs this file is testing.\n    \n  * Disabled a call to invokeOnce() around line 127 because it appeared to be\n    broken anyway.  I don't think it ever even worked.\n*/\n\n\nvar MyApp, binding1, binding2;\n\nmodule(\"System:run_loop() - chained binding\", {\n  setup: function() {\n    MyApp = {};\n    MyApp.first = SC.Object.create(SC.Observable, { \n      output: 'MyApp.first' \n    }) ;\n    \n    MyApp.second = SC.Object.create(SC.Observable, { \n      input: 'MyApp.second',\n      output: 'MyApp.second',\n    \n      inputDidChange: function() {\n        this.set(\"output\", this.get(\"input\")) ;\n      }.observes(\"input\") \n\n    }) ;\n  \n    MyApp.third = SC.Object.create(SC.Observable, { \n      input: \"MyApp.third\" \n    }) ;\n  }\n});\n\ntest(\"Should propograte bindings after the RunLoop completes (using SC.RunLoop)\", function() {\n  SC.RunLoop.begin();\n    //Binding of output of MyApp.first object to input of MyApp.second object\n      binding1 = SC.Binding.from(\"first.output\")\n        .to(\"second.input\").connect(MyApp) ;\n      \n    //Binding of output of MyApp.second object to input of MyApp.third object\n    binding2 = SC.Binding.from(\"second.output\")\n      .to(\"third.input\").connect(MyApp) ;\n\n    SC.run.sync();\n    \n    // Based on the above binding if you change the output of MyApp.first \n    // object it should change the all the variable of \n    //  MyApp.first,MyApp.second and MyApp.third object\n    MyApp.first.set(\"output\", \"change\") ;\n    \n    //Changes the output of the MyApp.first object\n    equals(MyApp.first.get(\"output\"), \"change\") ;\n    \n    //since binding has not taken into effect the value still remains as change.\n    equals(MyApp.second.get(\"output\"), \"MyApp.first\") ;\n  SC.RunLoop.end(); // allows bindings to trigger...\n  \n  //Value of the output variable changed to 'change'\n  equals(MyApp.first.get(\"output\"), \"change\") ;\n  \n  //Since binding triggered after the end loop the value changed to 'change'.\n  equals(MyApp.second.get(\"output\"), \"change\") ;\n});\n\ntest(\"Should propograte bindings after the RunLoop completes (using SC.beginRunLoop)\", function() {\n    //Binding of output of MyApp.first object to input of MyApp.second object\n      binding1 = SC.Binding.from(\"first.output\")\n        .to(\"second.input\").connect(MyApp) ;\n      \n    //Binding of output of MyApp.second object to input of MyApp.third object\n    binding2 = SC.Binding.from(\"second.output\")\n        .to(\"third.input\").connect(MyApp) ;\n\n    SC.run.sync();\n    \n    //Based on the above binding if you change the output of MyApp.first object it should\n    //change the all the variable of MyApp.first,MyApp.second and MyApp.third object\n    MyApp.first.set(\"output\", \"change\") ;\n    \n    //Changes the output of the MyApp.first object\n    equals(MyApp.first.get(\"output\"), \"change\") ;\n    \n    //since binding has not taken into effect the value still remains as change.\n    equals(MyApp.second.get(\"output\"), \"MyApp.first\") ;\n  SC.run.sync() ; // actually sets up the connection\n  \n  //Value of the output variable changed to 'change'\n  equals(MyApp.first.get(\"output\"), \"change\") ;\n  \n  //Since binding triggered after the end loop the value changed to 'change'.\n  equals(MyApp.second.get(\"output\"), \"change\") ;\n});\n\ntest(\"Should propograte bindings after the RunLoop completes (checking invokeOnce() function)\", function() {\n  SC.RunLoop.begin();\n    //Binding of output of MyApp.first object to input of MyApp.second object\n      binding1 = SC.Binding.from(\"first.output\")\n        .to(\"second.input\").connect(MyApp) ;\n      \n    //Binding of output of MyApp.second object to input of MyApp.third object\n    binding2 = SC.Binding.from(\"second.output\")\n      .to(\"third.input\").connect(MyApp) ;\n    \n    SC.run.sync() ; // actually sets up the connection\n    \n    //Based on the above binding if you change the output of MyApp.first object it should\n    //change the all the variable of MyApp.first,MyApp.second and MyApp.third object\n    MyApp.first.set(\"output\", \"change\") ;\n    \n    //Changes the output of the MyApp.first object\n    equals(MyApp.first.get(\"output\"), \"change\") ;\n    \n    //since binding has not taken into effect the value still remains as change.\n    equals(MyApp.second.get(\"output\"), \"MyApp.first\") ;\n    \n    // Call the invokeOnce function to set the function which needs to be called once\n    // MyApp.second.invokeOnce('MyApp.second','inputDidChange'); <-- Broken?\n    \n  SC.RunLoop.end(); // allows bindings to trigger...\n  \n  //Value of the output variable changed to 'change'\n  equals(MyApp.first.get(\"output\"), \"change\") ;\n  \n  //Since binding triggered after the end loop the value changed to 'change'.\n  equals(MyApp.second.get(\"output\"), \"change\") ;\n  \n  //Set the output for the MyApp.first so that the 'inputDidChange' function in the MyApp.second object is called again\n  MyApp.first.set(\"output\", \"againChanged\") ;\n  \n  //Value of the output variable changed to 'change'\n  equals(MyApp.first.get(\"output\"), \"againChanged\") ;\n  \n  //Since the invoker function is called only once the value of output did not change.\n  equals(MyApp.second.get(\"output\"), \"change\") ;\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/legacy_1x/system/set_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n// NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n// are the same except for places where we intend to break the API we instead\n// validate that we warn the developer appropriately.\n//\n//  * Changed SC.Set.clone() call to SC.Set.copy()\n\n// ========================================================================\n// SC.Set Tests\n// ========================================================================\n/*globals module test ok isObj equals expects */\n\n\nvar a, b, c ; // global variables\n\nmodule(\"creating SC.Set instances\", {\n  \n  setup: function() {\n    // create objects...\n    a = { name: \"a\" } ;\n    b = { name: \"b\" } ;\n    c = { name: \"c\" } ;\n  },\n  \n  teardown: function() {\n    a = undefined ;\n    b = undefined ;\n    c = undefined ;\n  }\n  \n});\n\ntest(\"SC.Set.create() should create empty set\", function() {\n  var set = SC.Set.create() ;\n  equals(set.length, 0) ;\n});\n\ntest(\"SC.Set.create([1,2,3]) should create set with three items in them\", function() {\n  var set = SC.Set.create([a,b,c]) ;\n  equals(set.length, 3) ;\n  equals(set.contains(a), YES) ;\n  equals(set.contains(b), YES) ;\n  equals(set.contains(c), YES) ;\n});\n\ntest(\"SC.Set.create() should accept anything that implements SC.Array\", function() {\n  var arrayLikeObject = SC.Object.create(SC.Array, {\n    _content: [a,b,c],\n    length: 3,\n    objectAt: function(idx) { return this._content[idx]; } \n  }) ;\n  \n  var set = SC.Set.create(arrayLikeObject) ;\n  equals(set.length, 3) ;\n  equals(set.contains(a), YES) ;\n  equals(set.contains(b), YES) ;\n  equals(set.contains(c), YES) ;\n});\n\nvar set ; // global variables\n\n// The tests below also end up testing the contains() method pretty \n// exhaustively.\nmodule(\"SC.Set.add + SC.Set.contains\", {\n  \n  setup: function() {\n    set = SC.Set.create() ;\n  },\n  \n  teardown: function() {\n    set = undefined ;\n  }\n  \n});\n\ntest(\"should add an SC.Object\", function() {\n  var obj = SC.Object.create() ;\n  \n  var oldLength = set.length ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES, \"contains()\") ;\n  equals(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add a regular hash\", function() {\n  var obj = {} ;\n  \n  var oldLength = set.length ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES, \"contains()\") ;\n  equals(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add a string\", function() {\n  var obj = \"String!\" ;\n  \n  var oldLength = set.length ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES, \"contains()\") ;\n  equals(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add a number\", function() {\n  var obj = 23 ;\n  \n  var oldLength = set.length ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES, \"contains()\") ;\n  equals(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add bools\", function() {\n  var oldLength = set.length ;\n\n  set.add(true) ;\n  equals(set.contains(true), YES, \"contains(true)\");\n  equals(set.length, oldLength+1, \"new set length\");\n\n  set.add(false);\n  equals(set.contains(false), YES, \"contains(false)\");\n  equals(set.length, oldLength+2, \"new set length\");\n});\n\ntest(\"should add 0\", function() {\n  var oldLength = set.length ;\n\n  set.add(0) ;\n  equals(set.contains(0), YES, \"contains(0)\");\n  equals(set.length, oldLength+1, \"new set length\");\n});\n\ntest(\"should add a function\", function() {\n  var obj = function() { return \"Test function\"; } ;\n  \n  var oldLength = set.length ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES, \"contains()\") ;\n  equals(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should NOT add a null\", function() {\n  set.add(null) ;\n  equals(set.length, 0) ;\n  equals(set.contains(null), NO) ;\n});\n\ntest(\"should NOT add an undefined\", function() {\n  set.add(undefined) ;\n  equals(set.length, 0) ;\n  equals(set.contains(undefined), NO) ;\n});\n\ntest(\"adding an item, removing it, adding another item\", function() {\n  var item1 = \"item1\" ;\n  var item2 = \"item2\" ;\n\n  set.add(item1) ; // add to set\n  set.remove(item1) ; //remove from set\n  set.add(item2) ;\n  \n  equals(set.contains(item1), NO, \"set.contains(item1)\") ;\n  \n  set.add(item1) ; // re-add to set\n  equals(set.length, 2, \"set.length\") ;\n});\n\nmodule(\"SC.Set.remove + SC.Set.contains\", {\n  \n  // generate a set with every type of object, but none of the specific\n  // ones we add in the tests below...\n  setup: function() {\n    set = SC.Set.create([\n      SC.Object.create({ dummy: YES }),\n      { isHash: YES },\n      \"Not the String\",\n      16, true, false, 0]) ;\n  },\n  \n  teardown: function() {\n    set = undefined ;\n  }\n  \n});\n\ntest(\"should remove an SC.Object and reduce length\", function() {\n  var obj = SC.Object.create() ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES) ;\n  var oldLength = set.length ;\n  \n  set.remove(obj) ;\n  equals(set.contains(obj), NO, \"should be removed\") ;\n  equals(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a regular hash and reduce length\", function() {\n  var obj = {} ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES) ;\n  var oldLength = set.length ;\n  \n  set.remove(obj) ;\n  equals(set.contains(obj), NO, \"should be removed\") ;\n  equals(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a string and reduce length\", function() {\n  var obj = \"String!\" ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES) ;\n  var oldLength = set.length ;\n  \n  set.remove(obj) ;\n  equals(set.contains(obj), NO, \"should be removed\") ;\n  equals(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a number and reduce length\", function() {\n  var obj = 23 ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES) ;\n  var oldLength = set.length ;\n  \n  set.remove(obj) ;\n  equals(set.contains(obj), NO, \"should be removed\") ;\n  equals(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a bools and reduce length\", function() {\n  var oldLength = set.length ;\n  set.remove(true) ;\n  equals(set.contains(true), NO, \"should be removed\") ;\n  equals(set.length, oldLength-1, \"should be 1 shorter\") ;\n\n  set.remove(false);\n  equals(set.contains(false), NO, \"should be removed\") ;\n  equals(set.length, oldLength-2, \"should be 2 shorter\") ;\n});\n\ntest(\"should remove 0 and reduce length\", function(){\n  var oldLength = set.length;\n  set.remove(0) ;\n  equals(set.contains(0), NO, \"should be removed\") ;\n  equals(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a function and reduce length\", function() {\n  var obj = function() { return \"Test function\"; } ;\n  set.add(obj) ;\n  equals(set.contains(obj), YES) ;\n  var oldLength = set.length ;\n  \n  set.remove(obj) ;\n  equals(set.contains(obj), NO, \"should be removed\") ;\n  equals(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should NOT remove a null\", function() {\n  var oldLength = set.length ;\n  set.remove(null) ;\n  equals(set.length, oldLength) ;\n});\n\ntest(\"should NOT remove an undefined\", function() {\n  var oldLength = set.length ;\n  set.remove(undefined) ;\n  equals(set.length, oldLength) ;\n});\n\ntest(\"should ignore removing an object not in the set\", function() {\n  var obj = SC.Object.create() ;\n  var oldLength = set.length ;\n  set.remove(obj) ;\n  equals(set.length, oldLength) ;\n});\n\n// test(\"should remove all the elements in the set\", function() {\n// \tvar obj = [2,3,4];\n// \tset.add(obj) ;\n// \tvar oldLength = set.length ;\n// \tequals(oldLength, 6);\n// \ta = set.removeEach(obj);\n// \tequals(a.length, 0);\n// });\n\nmodule(\"SC.Set.pop + SC.Set.copy\", {\n// generate a set with every type of object, but none of the specific\n// ones we add in the tests below...\n\tsetup: function() {\n\t\tset = SC.Set.create([\n\t\t\tSC.Object.create({ dummy: YES }),\n\t\t\t{ isHash: YES },\n\t\t\t\"Not the String\",\n\t\t\t16, false]) ;\n\t\t},\n\t\t\n\t\tteardown: function() {\n\t\t\tset = undefined ;\n\t\t}\n});\n\ntest(\"the pop() should remove an arbitrary object from the set\", function() {\n\tvar oldLength = set.length ;\n\tvar obj = set.pop();\n\tok(!SC.none(obj), 'pops up an item');\n\tequals(set.length, oldLength-1, 'length shorter by 1');\n});\n\ntest(\"should pop false and 0\", function(){\n  set = SC.Set.create([false]);\n  ok(set.pop() === false, \"should pop false\");\n\n  set = SC.Set.create([0]);\n  ok(set.pop() === 0, \"should pop 0\");\n});\n\ntest(\"the copy() should return an indentical set\", function() {\n\tvar oldLength = set.length ;\n\tvar obj = set.copy();\n\tequals(oldLength,obj.length,'length of the clone should be same');\n\tequals(obj.contains(set[0]), YES);\n\tequals(obj.contains(set[1]), YES);\n\tequals(obj.contains(set[2]), YES);\n\tequals(obj.contains(set[3]), YES);\n\tequals(obj.contains(set[4]), YES);\n});\n\n});");spade.register("sproutcore-runtime/~tests/mixins/array_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth */\n\n\nrequire('sproutcore-runtime/~tests/props_helper');\nrequire('sproutcore-runtime/~tests/suites/array');\n\n/*\n  Implement a basic fake mutable array.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestArray = SC.Object.extend(SC.Array, {\n\n  _content: null,\n\n  init: function(ary) {\n    this._content = ary || [];\n  },\n\n  // some methods to modify the array so we can test changes.  Note that\n  // arrays can be modified even if they don't implement MutableArray.  The\n  // MutableArray is just a standard API for mutation but not required.\n  addObject: function(obj) {\n    var idx = this._content.length;\n    this.arrayContentWillChange(idx, 0, 1);\n    this._content.push(obj);\n    this.arrayContentDidChange(idx, 0, 1);\n  },\n\n  removeFirst: function(idx) {\n    this.arrayContentWillChange(0, 1, 0);\n    this._content.shift();\n    this.arrayContentDidChange(0, 1, 0);\n  },\n\n  objectAt: function(idx) {\n    return this._content[idx];\n  },\n\n  length: function() {\n    return this._content.length;\n  }.property('[]').cacheable(),\n\n  slice: function() {\n    return this._content.slice();\n  }\n\n});\n\n\nSC.ArrayTests.extend({\n\n  name: 'Basic Mutable Array',\n\n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestArray(ary);\n  },\n\n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(this.getFixture(1)[0]);\n  },\n\n  toArray: function(obj) {\n    return obj.slice();\n  }\n\n}).run();\n\n// ..........................................................\n// CONTENT DID CHANGE\n//\n\nvar DummyArray = SC.Object.extend(SC.Array, {\n  nextObject: function() {},\n  length: 0,\n  objectAt: function(idx) { return 'ITEM-'+idx; }\n});\n\nvar obj, observer;\n\n\n// ..........................................................\n// NOTIFY ARRAY OBSERVERS\n//\n\nmodule('mixins/array/arrayContent[Will|Did]Change');\n\ntest('should notify observers of []', function() {\n\n  obj = DummyArray.create({\n    _count: 0,\n    enumerablePropertyDidChange: function() {\n      this._count++;\n    }.observes('[]')\n  });\n\n  equals(obj._count, 0, 'should not have invoked yet');\n\n  obj.arrayContentWillChange(0, 1, 1);\n  obj.arrayContentDidChange(0, 1, 1);\n\n  equals(obj._count, 1, 'should have invoked');\n\n});\n\n// ..........................................................\n// NOTIFY CHANGES TO LENGTH\n//\n\nmodule('notify observers of length', {\n  setup: function() {\n    obj = DummyArray.create({\n      _after: 0,\n      lengthDidChange: function() {\n        this._after++;\n      }.observes('length')\n\n    });\n\n    equals(obj._after, 0, 'should not have fired yet');\n  },\n\n  teardown: function() {\n    obj = null;\n  }\n});\n\ntest('should notify observers when call with no params', function() {\n  obj.arrayContentWillChange();\n  equals(obj._after, 0);\n\n  obj.arrayContentDidChange();\n  equals(obj._after, 1);\n});\n\n// API variation that included items only\ntest('should not notify when passed lengths are same', function() {\n  obj.arrayContentWillChange(0, 1, 1);\n  equals(obj._after, 0);\n\n  obj.arrayContentDidChange(0, 1, 1);\n  equals(obj._after, 0);\n});\n\ntest('should notify when passed lengths are different', function() {\n  obj.arrayContentWillChange(0, 1, 2);\n  equals(obj._after, 0);\n\n  obj.arrayContentDidChange(0, 1, 2);\n  equals(obj._after, 1);\n});\n\n\n// ..........................................................\n// NOTIFY ARRAY OBSERVER\n//\n\nmodule('notify array observers', {\n  setup: function() {\n    obj = DummyArray.create();\n\n    observer = SC.Object.create({\n      _before: null,\n      _after: null,\n\n      arrayWillChange: function() {\n        equals(this._before, null); // should only call once\n        this._before = Array.prototype.slice.call(arguments);\n      },\n\n      arrayDidChange: function() {\n        equals(this._after, null); // should only call once\n        this._after = Array.prototype.slice.call(arguments);\n      }\n    });\n\n    obj.addArrayObserver(observer);\n  },\n\n  teardown: function() {\n    obj = observer = null;\n  }\n});\n\ntest('should notify enumerable observers when called with no params', function() {\n  obj.arrayContentWillChange();\n  same(observer._before, [obj, 0, -1, -1]);\n\n  obj.arrayContentDidChange();\n  same(observer._after, [obj, 0, -1, -1]);\n});\n\n// API variation that included items only\ntest('should notify when called with same length items', function() {\n  obj.arrayContentWillChange(0, 1, 1);\n  same(observer._before, [obj, 0, 1, 1]);\n\n  obj.arrayContentDidChange(0, 1, 1);\n  same(observer._after, [obj, 0, 1, 1]);\n});\n\ntest('should notify when called with diff length items', function() {\n  obj.arrayContentWillChange(0, 2, 1);\n  same(observer._before, [obj, 0, 2, 1]);\n\n  obj.arrayContentDidChange(0, 2, 1);\n  same(observer._after, [obj, 0, 2, 1]);\n});\n\ntest('removing enumerable observer should disable', function() {\n  obj.removeArrayObserver(observer);\n  obj.arrayContentWillChange();\n  same(observer._before, null);\n\n  obj.arrayContentDidChange();\n  same(observer._after, null);\n});\n\n// ..........................................................\n// NOTIFY ENUMERABLE OBSERVER\n//\n\nmodule('notify enumerable observers as well', {\n  setup: function() {\n    obj = DummyArray.create();\n\n    observer = SC.Object.create({\n      _before: null,\n      _after: null,\n\n      enumerableWillChange: function() {\n        equals(this._before, null); // should only call once\n        this._before = Array.prototype.slice.call(arguments);\n      },\n\n      enumerableDidChange: function() {\n        equals(this._after, null); // should only call once\n        this._after = Array.prototype.slice.call(arguments);\n      }\n    });\n\n    obj.addEnumerableObserver(observer);\n  },\n\n  teardown: function() {\n    obj = observer = null;\n  }\n});\n\ntest('should notify enumerable observers when called with no params', function() {\n  obj.arrayContentWillChange();\n  same(observer._before, [obj, null, null], 'before');\n\n  obj.arrayContentDidChange();\n  same(observer._after, [obj, null, null], 'after');\n});\n\n// API variation that included items only\ntest('should notify when called with same length items', function() {\n  obj.arrayContentWillChange(0, 1, 1);\n  same(observer._before, [obj, ['ITEM-0'], 1], 'before');\n\n  obj.arrayContentDidChange(0, 1, 1);\n  same(observer._after, [obj, 1, ['ITEM-0']], 'after');\n});\n\ntest('should notify when called with diff length items', function() {\n  obj.arrayContentWillChange(0, 2, 1);\n  same(observer._before, [obj, ['ITEM-0', 'ITEM-1'], 1], 'before');\n\n  obj.arrayContentDidChange(0, 2, 1);\n  same(observer._after, [obj, 2, ['ITEM-0']], 'after');\n});\n\ntest('removing enumerable observer should disable', function() {\n  obj.removeEnumerableObserver(observer);\n  obj.arrayContentWillChange();\n  same(observer._before, null, 'before');\n\n  obj.arrayContentDidChange();\n  same(observer._after, null, 'after');\n});\n\n// ..........................................................\n// @each\n//\n\nvar ary;\n\nmodule('SC.Array.@each support', {\n  setup: function() {\n    ary = new TestArray([\n      { isDone: true,  desc: 'Todo 1' },\n      { isDone: false, desc: 'Todo 2' },\n      { isDone: true,  desc: 'Todo 3' },\n      { isDone: false, desc: 'Todo 4' }\n    ]);\n  },\n\n  teardown: function() {\n    ary = null;\n  }\n});\n\nfunction verifyEachArray() {\n  var get = SC.get, set = SC.set;\n\n  ['isDone', 'desc'].forEach(function(keyName) {\n    var len  = get(ary, 'length'),\n        each = get(get(ary, '@each'), keyName), idx;\n\n    for(idx=0;idx<len;idx++) {\n      equals(each.objectAt(idx), get(ary.objectAt(idx), keyName),\n       'ary.@each.'+keyName+'['+idx+'] should eql ary['+idx+'].'+keyName);\n    }\n\n    equals(get(each, 'length'), get(ary, 'length'), 'lengths should match');\n  });\n}\n\ntest('@each should map properties on objects', function() {\n  verifyEachArray();\n});\n\ntest('modifying the array should update the each arrays too', function() {\n  verifyEachArray(); // ensure the arrays exist and values are cached\n\n  ary.addObject({ isDone: true, desc: 'Todo 5' });\n  verifyEachArray(); // ensure the arrays exist and values are cached\n\n  ary.removeFirst();\n  verifyEachArray(); // ensure the arrays exist and values are cached\n});\n\ntest('modifying a property in the array should notify on each', function() {\n\n  var get = SC.get, set = SC.set;\n\n  var each = SC.getPath(ary, '@each.isDone');\n  var item = ary.objectAt(2);\n\n  var obs = {\n    willCount: 0,\n    didCount: 0,\n\n    arrayWillChange: function(src, idx, inserted, removed) {\n      equals(idx, 2, 'idx');\n      equals(inserted, 1, 'inserted');\n      equals(removed, 1, 'removed');\n      this.willCount++;\n    },\n\n    arrayDidChange: function(src, idx, inserted, removed) {\n      equals(idx, 2, 'idx');\n      equals(inserted, 1, 'inserted');\n      equals(removed, 1, 'removed');\n      this.didCount++;\n    }\n\n  };\n\n  each.addArrayObserver(obs);\n\n  equals(each.objectAt(2), get(item, 'isDone'), 'compare before change');\n  set(item, 'isDone', !get(item, 'isDone'));\n  equals(each.objectAt(2), get(item, 'isDone'), 'compare after change');\n\n  equals(obs.willCount, 1, 'should have invoked willChange observer');\n  equals(obs.didCount, 1, 'should have invoked didChange observer');\n});\n\ntest('adding an object and then modifying it should notify', function() {\n\n  var get = SC.get, set = SC.set;\n\n  var each = SC.getPath(ary, '@each.isDone');\n  var item = { isDone: false, desc: 'Todo 5' };\n  var itemIndex = get(ary, 'length');\n\n  var obs = {\n    willCount: 0,\n    didCount: 0,\n\n    arrayWillChange: function(src, idx, inserted, removed) {\n      equals(idx, itemIndex, 'idx');\n      equals(inserted, 1, 'inserted');\n      equals(removed, 1, 'removed');\n      this.willCount++;\n    },\n\n    arrayDidChange: function(src, idx, inserted, removed) {\n      equals(idx, itemIndex, 'idx');\n      equals(inserted, 1, 'inserted');\n      equals(removed, 1, 'removed');\n      this.didCount++;\n    }\n\n  };\n\n  ary.addObject(item);\n  each.addArrayObserver(obs);\n\n  equals(each.objectAt(itemIndex), get(item, 'isDone'), 'compare before change');\n  set(item, 'isDone', !get(item, 'isDone'));\n  equals(each.objectAt(itemIndex), get(item, 'isDone'), 'compare after change');\n\n  equals(obs.willCount, 1, 'should have invoked willChange observer');\n  equals(obs.didCount, 1, 'should have invoked didChange observer');\n});\n\ntest('adding an object should notify (@each)', function() {\n\n  var get = SC.get, set = SC.set;\n  var called = 0;\n\n  var observerObject = SC.Object.create({\n    wasCalled: function() {\n      called++;\n    }\n  });\n\n  // SC.get(ary, '@each');\n  SC.addObserver(ary, '@each', observerObject, 'wasCalled');\n\n  ary.addObject(SC.Object.create({\n    desc: \"foo\",\n    isDone: false\n  }));\n\n  equals(called, 1, \"calls observer when object is pushed\");\n\n});\n\ntest('adding an object should notify (@each.isDone)', function() {\n\n  var get = SC.get, set = SC.set;\n  var called = 0;\n\n  var observerObject = SC.Object.create({\n    wasCalled: function() {\n      called++;\n    }\n  });\n\n  SC.addObserver(ary, '@each.isDone', observerObject, 'wasCalled');\n\n  ary.addObject(SC.Object.create({\n    desc: \"foo\",\n    isDone: false\n  }));\n\n  equals(called, 1, \"calls observer when object is pushed\");\n\n});\n\ntest('removing an object should no longer notify', function() {\n\n  var get = SC.get, set = SC.set;\n\n  var each = SC.getPath(ary, '@each.isDone');\n  var item = ary.objectAt(0);\n\n  var obs = {\n    willCount: 0,\n    didCount: 0,\n\n    arrayWillChange: function(src, idx, inserted, removed) {\n      this.willCount++;\n    },\n\n    arrayDidChange: function(src, idx, inserted, removed) {\n      this.didCount++;\n    }\n\n  };\n\n  each.addArrayObserver(obs);\n\n  equals(each.objectAt(0), get(item, 'isDone'), 'compare before change');\n  set(item, 'isDone', !get(item, 'isDone'));\n  equals(each.objectAt(0), get(item, 'isDone'), 'compare after change');\n\n  equals(obs.willCount, 1, 'should have invoked willChange observer');\n  equals(obs.didCount, 1, 'should have invoked didChange observer');\n\n  ary.removeFirst(); // remove the item\n  obs.willCount = obs.didCount = 0;\n\n  set(item, 'isDone', !get(item, 'isDone'));\n  equals(obs.willCount, 0, 'should NOT have invoked willChange observer');\n  equals(obs.didCount, 0, 'should NOT have invoked didChange observer');\n\n});\n\n\ntest('modifying the array should also indicate the isDone prop itself has changed', function() {\n  // NOTE: we never actually get the '@each.isDone' property here.  This is\n  // important because it tests the case where we don't have an isDone\n  // EachArray materialized but just want to know when the property has\n  // changed.\n\n  var get = SC.get, set = SC.set;\n  var each = get(ary, '@each');\n  var count = 0;\n\n  SC.addObserver(each, 'isDone', function() { count++; });\n\n  count = 0;\n  var item = ary.objectAt(2);\n  set(item, 'isDone', !get(item, 'isDone'));\n  equals(count, 1, '@each.isDone should have notified');\n});\n\n\ntestBoth(\"should be clear caches for computed properties that have dependent keys on arrays that are changed after object initialization\", function(get, set) {\n  var obj = SC.Object.create({\n    init: function() {\n      set(this, 'resources', SC.MutableArray.apply([]));\n    },\n\n    common: SC.computed(function() {\n      return get(get(this, 'resources').objectAt(0), 'common');\n    }).property('resources.@each.common').cacheable(),\n  });\n\n  get(obj, 'resources').pushObject(SC.Object.create({ common: \"HI!\" }));\n  equals(\"HI!\", get(obj, 'common'));\n\n  set(get(obj, 'resources').objectAt(0), 'common', \"BYE!\");\n  equals(\"BYE!\", get(obj, 'common'));\n});\n\ntestBoth(\"observers that contain @each in the path should fire only once the first time they are accessed\", function(get, set) {\n  count = 0;\n\n  var obj = SC.Object.create({\n    init: function() {\n      // Observer fires once when resources changes\n      set(this, 'resources', SC.MutableArray.apply([]));\n    },\n\n    commonDidChange: function() {\n      count++;\n    }.observes('resources.@each.common')\n  })\n\n  // Observer fires second time when new object is added\n  get(obj, 'resources').pushObject(SC.Object.create({ common: \"HI!\" }));\n  // Observer fires third time when property on an object is changed\n  set(get(obj, 'resources').objectAt(0), 'common', \"BYE!\");\n\n  equals(count, 3, \"observers should only be called once\");\n});\n\n});");spade.register("sproutcore-runtime/~tests/mixins/comparable_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            Portions ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n/*globals module test ok isObj equals expects */\n\n\nvar Rectangle = SC.Object.extend(SC.Comparable, {\n  length: 0,\n  width: 0,\n  \n  area: function() {\n    return SC.get(this,'length') * SC.get(this, 'width');\n  },\n  \n  compare: function(a, b) {\n    return SC.compare(a.area(), b.area());\n  }\n  \n});\n\nvar r1, r2;\n\nmodule(\"Comparable\", {\n  \n  setup: function() {\n    r1 = Rectangle.create({length: 6, width: 12});\n    r2 = Rectangle.create({length: 6, width: 13});\n  },\n  \n  teardown: function() {\n  }\n  \n});\n\ntest(\"should be comparable and return the correct result\", function() {\n  equals(SC.Comparable.detect(r1), true);\n  equals(SC.compare(r1, r1), 0);\n  equals(SC.compare(r1, r2), -1);\n  equals(SC.compare(r2, r1), 1);\n});\n\n});");spade.register("sproutcore-runtime/~tests/mixins/copyable_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/copyable');\n\n// NOTE: See debug/suites/copyable.js for mosts tests\n\nvar CopyableObject = SC.Object.extend(SC.Copyable, {\n  \n  id: null,\n  \n  init: function() {\n    this._super();\n    SC.set(this, 'id', SC.generateGuid());\n  },\n  \n  copy: function() {\n    var ret = new CopyableObject();\n    SC.set(ret, 'id', SC.get(this, 'id'));\n    return ret;\n  }\n});\n\nSC.CopyableTests.extend({\n  \n  name: 'SC.Copyable Basic Test',\n  \n  newObject: function() {\n    return new CopyableObject();\n  },\n  \n  isEqual: function(a, b) {\n    if (!(a instanceof CopyableObject) || !(b instanceof CopyableObject)) return false;\n    return SC.get(a, 'id') === SC.get(b,'id');\n  }\n}).run();\n\n});");spade.register("sproutcore-runtime/~tests/mixins/enumerable_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\n/*\n  Implement a basic fake enumerable.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestEnumerable = SC.Object.extend(SC.Enumerable, {\n\n  _content: null,\n  \n  init: function(ary) {\n    this._content = ary || [];\n  },\n\n  addObject: function(obj) {\n    if (this._content.indexOf(obj)>=0) return this;\n    this._content.push(obj);    \n    this.enumerableContentDidChange();\n  },\n  \n  nextObject: function(idx) {\n    return idx >= SC.get(this, 'length') ? undefined : this._content[idx];\n  },\n  \n  length: function() {\n    return this._content.length;\n  }.property('[]').cacheable(),\n  \n  slice: function() {\n    return this._content.slice();\n  }\n  \n});\n\n\nSC.EnumerableTests.extend({\n  \n  name: 'Basic Enumerable',\n    \n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestEnumerable(ary);\n  },\n  \n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(obj._content.length+1);\n  },\n  \n  toArray: function(obj) {\n    return obj.slice();\n  }\n  \n}).run();\n\n// ..........................................................\n// CONTENT DID CHANGE\n// \n\nvar DummyEnum = SC.Object.extend(SC.Enumerable, {\n  nextObject: function() {},\n  length: 0\n});\n\nvar obj, observer;\n\n// ..........................................................\n// NOTIFY ENUMERABLE PROPERTY\n// \n\nmodule('mixins/enumerable/enumerableContentDidChange');\n\ntest('should notify observers of []', function() {\n\n  var obj = SC.Object.create(SC.Enumerable, {\n    nextObject: function() {}, // avoid exceptions\n    \n    _count: 0,\n    enumerablePropertyDidChange: function() {\n      this._count++;\n    }.observes('[]')\n  });\n  \n  equals(obj._count, 0, 'should not have invoked yet');\n  obj.enumerableContentWillChange();\n  obj.enumerableContentDidChange();\n  equals(obj._count, 1, 'should have invoked');\n  \n});\n\n// ..........................................................\n// NOTIFY CHANGES TO LENGTH\n// \n\nmodule('notify observers of length', {\n  setup: function() {\n    obj = DummyEnum.create({\n      _after: 0,\n      lengthDidChange: function() {\n        this._after++;\n      }.observes('length')\n      \n    });\n    \n    equals(obj._after, 0, 'should not have fired yet');\n  },\n   \n  teardown: function() {\n    obj = null;\n  }\n});\n\ntest('should notify observers when call with no params', function() {\n  obj.enumerableContentWillChange();\n  equals(obj._after, 0);\n  \n  obj.enumerableContentDidChange();\n  equals(obj._after, 1);\n});\n\n// API variation that included items only\ntest('should not notify when passed arrays of same length', function() {\n  var added = ['foo'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  equals(obj._after, 0);\n  \n  obj.enumerableContentDidChange(removed, added);\n  equals(obj._after, 0);\n});\n\ntest('should notify when passed arrays of different length', function() {\n  var added = ['foo'], removed = ['bar', 'baz'];\n  obj.enumerableContentWillChange(removed, added);\n  equals(obj._after, 0);\n  \n  obj.enumerableContentDidChange(removed, added);\n  equals(obj._after, 1);\n});\n\n// API variation passes indexes only\ntest('should not notify when passed with indexes', function() {\n  obj.enumerableContentWillChange(1, 1);\n  equals(obj._after, 0);\n  \n  obj.enumerableContentDidChange(1, 1);\n  equals(obj._after, 0);\n});\n\ntest('should notify when passed old index API with delta', function() {\n  obj.enumerableContentWillChange(1, 2);\n  equals(obj._after, 0);\n  \n  obj.enumerableContentDidChange(1, 2);\n  equals(obj._after, 1);\n});\n\n\n// ..........................................................\n// NOTIFY ENUMERABLE OBSERVER\n// \n\nmodule('notify enumerable observers', {\n  setup: function() {\n    obj = DummyEnum.create();\n    \n    observer = SC.Object.create({\n      _before: null,\n      _after: null,\n      \n      enumerableWillChange: function() {\n        equals(this._before, null); // should only call once\n        this._before = Array.prototype.slice.call(arguments);  \n      },\n      \n      enumerableDidChange: function() {\n        equals(this._after, null); // should only call once\n        this._after = Array.prototype.slice.call(arguments);  \n      }\n    });\n    \n    obj.addEnumerableObserver(observer);\n  },\n   \n  teardown: function() {\n    obj = observer = null;\n  }\n});\n\ntest('should notify enumerable observers when called with no params', function() {\n  obj.enumerableContentWillChange();\n  same(observer._before, [obj, null, null]);\n\n  obj.enumerableContentDidChange();\n  same(observer._after, [obj, null, null]);\n});\n\n// API variation that included items only\ntest('should notify when called with same length items', function() {\n  var added = ['foo'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  same(observer._before, [obj, removed, added]);\n\n  obj.enumerableContentDidChange(removed, added);\n  same(observer._after, [obj, removed, added]);\n});\n\ntest('should notify when called with diff length items', function() {\n  var added = ['foo', 'baz'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  same(observer._before, [obj, removed, added]);\n\n  obj.enumerableContentDidChange(removed, added);\n  same(observer._after, [obj, removed, added]);\n});\n\ntest('should not notify when passed with indexes only', function() {\n  obj.enumerableContentWillChange(1, 2);\n  same(observer._before, [obj, 1, 2]);\n\n  obj.enumerableContentDidChange(1, 2);\n  same(observer._after, [obj, 1, 2]);\n});\n\ntest('removing enumerable observer should disable', function() {\n  obj.removeEnumerableObserver(observer);\n  obj.enumerableContentWillChange();\n  same(observer._before, null);\n\n  obj.enumerableContentDidChange();\n  same(observer._after, null);\n});\n\n\n\n\n\n});");spade.register("sproutcore-runtime/~tests/mixins/mutable_array_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\n/*\n  Implement a basic fake mutable array.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestMutableArray = SC.Object.extend(SC.MutableArray, {\n\n  _content: null,\n\n  init: function(ary) {\n    this._content = ary || [];\n  },\n\n  replace: function(idx, amt, objects) {\n    \n    var args = objects ? objects.slice() : [],\n        removeAmt = amt,\n        addAmt    = args.length;\n\n    this.arrayContentWillChange(idx, removeAmt, addAmt);\n\n    args.unshift(amt);\n    args.unshift(idx);\n    this._content.splice.apply(this._content, args);\n    this.arrayContentDidChange(idx, removeAmt, addAmt);\n    return this;  \n  },\n  \n  objectAt: function(idx) {\n    return this._content[idx];\n  },\n\n  length: function() {\n    return this._content.length;\n  }.property('[]').cacheable(),\n\n  slice: function() {\n    return this._content.slice();\n  }\n\n});\n\n\nSC.MutableArrayTests.extend({\n  \n  name: 'Basic Mutable Array',\n    \n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestMutableArray(ary);\n  },\n  \n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(this.getFixture(1)[0]);\n  },\n  \n  toArray: function(obj) {\n    return obj.slice();\n  }\n  \n}).run();\n\n\n\n\n});");spade.register("sproutcore-runtime/~tests/mixins/mutable_enumerable_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_enumerable');\n\n/*\n  Implement a basic fake mutable array.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestMutableEnumerable = SC.Object.extend(SC.MutableEnumerable, {\n\n  _content: null,\n  \n  addObject: function(obj) {\n    if (this._content.indexOf(obj)>=0) return this;\n    this.enumerableContentWillChange(null, [obj]);\n    this._content.push(obj);    \n    this.enumerableContentDidChange(null, [obj]);\n  },\n  \n  removeObject: function(obj) {\n    var idx = this._content.indexOf(obj);\n    if (idx<0) return this;\n\n    this.enumerableContentWillChange([obj], null);\n    this._content.splice(idx, 1);\n    this.enumerableContentDidChange([obj], null);\n    return this;\n  },\n  \n  init: function(ary) {\n    this._content = ary || [];\n  },\n  \n  nextObject: function(idx) {\n    return idx>=SC.get(this, 'length') ? undefined : this._content[idx];\n  },\n  \n  length: function() {\n    return this._content.length;\n  }.property('[]').cacheable(),\n  \n  slice: function() {\n    return this._content.slice();\n  }  \n});\n\n\nSC.MutableEnumerableTests.extend({\n  \n  name: 'Basic Mutable Array',\n    \n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestMutableEnumerable(ary);\n  },\n  \n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(this.getFixture(1)[0]);\n  },\n  \n  toArray: function(obj) {\n    return obj.slice();\n  }\n  \n}).run();\n\n\n\n\n});");spade.register("sproutcore-runtime/~tests/props_helper", "(function(require, exports, __module, ARGV, ENV, __filename){// used by unit tests to test both accessor mode and non-accessor mode\ntestBoth = function(testname, callback) {\n  \n  function scget(x,y) { return SC.get(x,y); }\n  function scset(x,y,z) { return SC.set(x,y,z); }\n  function aget(x,y) { return x[y]; }\n  function aset(x,y,z) { return (x[y] = z); }\n\n  test(testname+' using SC.get()/SC.set()', function() {\n    callback(scget, scset);\n  });\n  \n  test(testname+' using accessors', function() {\n    if (SC.USES_ACCESSORS) callback(aget, aset);\n    else ok('SKIPPING ACCESSORS');\n  });\n};\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/array", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\n\n\nvar ObserverClass =   SC.EnumerableTests.ObserverClass.extend({\n    \n   observeArray: function(obj) {\n    obj.addArrayObserver(this);\n    return this;\n  },\n  \n  stopObserveArray: function(obj) {\n    obj.removeArrayObserver(this);\n    return this;\n  },\n  \n  arrayWillChange: function() {\n    equals(this._before, null, 'should only call once');\n    this._before = Array.prototype.slice.call(arguments);\n  },\n\n  arrayDidChange: function() {\n    equals(this._after, null, 'should only call once');\n    this._after = Array.prototype.slice.call(arguments);\n  }\n  \n});\n\nSC.ArrayTests = SC.EnumerableTests.extend({\n  \n  observerClass: ObserverClass\n  \n});\n\nSC.ArrayTests.ObserverClass = ObserverClass;\n\nrequire('./array/indexOf');\nrequire('./array/objectAt');\n\n});");spade.register("sproutcore-runtime/~tests/suites/array/indexOf", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/array');\n\nvar suite = SC.ArrayTests;\n\nsuite.module('indexOf');\n\nsuite.test(\"should return index of object\", function() {\n  var expected = this.newFixture(3),\n      obj      = this.newObject(expected),\n      len      = 3,\n      idx;\n      \n  for(idx=0;idx<len;idx++) {\n    equals(obj.indexOf(expected[idx]), idx, 'obj.indexOf(%@) should match idx'.fmt(expected[idx]));\n  }\n  \n});\n\nsuite.test(\"should return -1 when requesting object not in index\", function() {\n  var obj = this.newObject(this.newFixture(3)), foo = {};\n  equals(obj.indexOf(foo), -1, 'obj.indexOf(foo) should be < 0');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/array/objectAt", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/array');\n\nvar suite = SC.ArrayTests;\n\nsuite.module('objectAt');\n\nsuite.test(\"should return object at specified index\", function() {\n  var expected = this.newFixture(3),\n      obj      = this.newObject(expected),\n      len      = expected.length,\n      idx;\n      \n  for(idx=0;idx<len;idx++) {\n    equals(obj.objectAt(idx), expected[idx], 'obj.objectAt(%@) should match'.fmt(idx));\n  }\n  \n});\n\nsuite.test(\"should return undefined when requesting objects beyond index\", function() {\n  var obj;\n  \n  obj = this.newObject(this.newFixture(3));\n  equals(obj.objectAt(5), undefined, 'should return undefined for obj.objectAt(5) when len = 3');\n  \n  obj = this.newObject([]);\n  equals(obj.objectAt(0), undefined, 'should return undefined for obj.objectAt(0) when len = 0');\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/copyable", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/suite');\n\nSC.CopyableTests = SC.Suite.extend({\n\n  /**\n    Must be able to create a new object for testing.\n    \n    @returns {Object} object\n  */\n  newObject: SC.required(Function),\n  \n  /**\n    Compares the two passed in objects.  Returns true if the two objects \n    are logically equivalent.\n    \n    @param {Object} a\n      First object\n      \n    @param {Object} b\n      Second object\n      \n    @returns {Boolean}\n  */\n  isEqual: SC.required(Function),\n  \n  /**\n    Set this to true if you expect the objects you test to be freezable.\n    The suite will verify that your objects actually match this.  (i.e. if\n    you say you can't test freezable it will verify that your objects really\n    aren't freezable.)\n    \n    @property {Boolean}\n  */\n  shouldBeFreezable: false\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/copyable/copy", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/copyable');\n\nvar suite = SC.CopyableTests;\n\nsuite.module('copy');\n\nsuite.test(\"should return an equivalent copy\", function() {\n  var obj = this.newObject();\n  var copy = obj.copy();\n  ok(this.isEqual(obj, copy), 'old object and new object should be equivalent');\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/copyable/frozenCopy", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/copyable');\n\nvar suite = SC.CopyableTests;\n\nsuite.module('frozenCopy');\n\nsuite.test(\"frozen objects should return same instance\", function() {\n  var obj, copy;\n  \n  obj = this.newObject();\n  if (SC.get(this, 'shouldBeFreezable')) {\n    ok(!SC.Freezable || SC.Freezable.detect(obj), 'object should be freezable');\n\n    copy = obj.frozenCopy();\n    ok(this.isEqual(obj, copy), 'new copy should be equal');\n    ok(SC.get(copy, 'isFrozen'), 'returned value should be frozen');\n    \n    copy = obj.freeze().frozenCopy();\n    equals(copy, obj, 'returns frozen object should be same');\n    ok(SC.get(copy, 'isFrozen'), 'returned object should be frozen');\n    \n  } else {\n    ok(!SC.Freezable || !SC.Freezable.detect(obj), 'object should not be freezable');\n  }\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/system/object');\nrequire('sproutcore-runtime/system/native_array');\nrequire('sproutcore-runtime/~tests/suites/suite');\n\n\n  \nvar ObserverClass = SC.Object.extend({\n  \n  _keys: null,\n  _values: null,\n  _before : null,\n  _after: null,\n  \n  isEnabled: true,\n  \n  init: function() {\n    this._super();\n    this.reset();\n  },\n  \n  /**\n    Invoked when the property changes.  Just records the parameters for \n    later analysis.\n  */\n  propertyDidChange: function(target, key, value) {\n      this._keys[key] = true;\n      this._values[key] = value;\n  },\n  \n  /**\n    Resets the recorded results for another run.\n      \n    @returns {Object} receiver\n  */\n  reset: function() {\n    this._keys = {};\n    this._values = {};\n    this._before = null;\n    this._after = null;\n    return this;\n  },\n  \n  /**\n    Begins observing the passed key names on the passed object.  Any changes\n    on the named properties will be recorded.\n    \n    @param {SC.Enumerable} obj \n      The enumerable to observe.\n      \n    @returns {Object} receiver\n  */\n  observe: function(obj) {\n    if (SC.Observer && SC.Observer.detect(obj)) {\n      var keys = Array.prototype.slice.call(arguments, 1),\n          loc  = keys.length;\n      while(--loc>=0) obj.addObserver(keys[loc], this, 'propertyDidChange');\n    } else {\n      this.isEnabled = false;\n    }\n    return this;\n  },\n  \n  /**\n    Returns true if the passed key was invoked.  If you pass a value as \n    well then validates that the values match.\n    \n    @param {String} key\n      Key to validate\n  \n    @param {Object} value\n      (Optional) value\n    \n    @returns {Boolean}\n  */\n  validate: function(key, value) {\n    if (!this.isEnabled) return true;\n    if (!this._keys[key]) return false;\n    if (arguments.length>1) return this._values[key] === value;\n    else return true;\n  },\n  \n  /**\n    begins acting as an enumerable observer.\n  */\n  observeEnumerable: function(obj) {\n    obj.addEnumerableObserver(this);\n    return this;\n  },\n  \n  stopObserveEnumerable: function(obj) {\n    obj.removeEnumerableObserver(this);\n    return this;\n  },\n  \n  enumerableWillChange: function() {\n    equals(this._before, null, 'should only call once');\n    this._before = Array.prototype.slice.call(arguments);\n  },\n\n  enumerableDidChange: function() {\n    equals(this._after, null, 'should only call once');\n    this._after = Array.prototype.slice.call(arguments);\n  }\n  \n});\n\n\n/**\n  Defines a test suite that can be used to test any object for compliance \n  with any enumerable.  To use, extend this object and define the required\n  methods to generate new object instances for testing, etc.  \n  \n  You can also add your own tests by defining new methods beginning with the\n  word 'test'\n*/\nvar EnumerableTests = SC.Object.extend({\n  \n  /**\n    Define a name for these tests - all modules are prefixed w/ it.\n    \n    @property {String}\n  */\n  name: SC.required(String),\n  \n  /**\n    Implement to return a new enumerable object for testing.  Should accept\n    either no parameters, a single number (indicating the desired length of\n    the collection) or an array of objects.\n    \n    @param {Array} content\n      An array of items to include in the enumerable optionally.  \n      \n    @returns {SC.Enumerable} a new enumerable\n  */\n  newObject: SC.required(Function),\n  \n  /**\n    Implement to return a set of new fixture objects that can be applied to\n    the enumerable.  This may be passed into the newObject method.\n    \n    @param {Number} count\n      The number of items required.\n      \n    @returns {Array} array of items\n  */\n  newFixture: function(cnt) {\n    var ret = [];\n    while(--cnt>=0) ret.push(SC.generateGuid());\n    return ret;\n  },\n  \n  /**\n    Implement accept an instance of the enumerable and return an array \n    containing the objects in the enumerable.  This is used only for testing\n    so performance is not important.\n    \n    @param {SC.Enumerable} enumerable\n      The enumerable to convert.\n      \n    @returns {Array} array of items\n  */\n  toArray: SC.required(Function),\n\n  /**\n    Implement this method if your object can mutate internally (even if it \n    does not support the MutableEnumerable API).  The method should accept\n    an object of your desired type and modify it somehow.  Suite tests will \n    use this to ensure that all appropriate caches, etc. clear when the\n    mutation occurs.\n    \n    If you do not define this optional method, then mutation-related tests\n    will be skipped.\n    \n    @param {SC.Enumerable} enumerable\n      The enumerable to mutate\n      \n    @returns {void}\n  */\n  mutate: function(){},\n  \n  /**\n    Becomes true when you define a new mutate() method, indicating that \n    mutation tests should run.  This is calculated automatically.\n    \n    @property {Boolean}\n  */\n  canTestMutation: function() {\n    return this.mutate !== EnumerableTests.prototype.mutate;  \n  }.property().cacheable(),\n  \n  /**\n    Invoked to actually run the test - overridden by mixins\n  */\n  run: function() {},\n  \n  \n  /**\n    Creates a new observer object for testing.  You can add this object as an\n    observer on an array and it will record results anytime it is invoked.  \n    After running the test, call the validate() method on the observer to \n    validate the results.\n  */\n  newObserver: function(obj) {\n    var ret = SC.get(this, 'observerClass').create();\n    if (arguments.length>0) ret.observe.apply(ret, arguments);\n    return ret;\n  },\n  \n  observerClass: ObserverClass\n\n});\n\nEnumerableTests.reopenClass({\n  \n  plan: null,\n  \n  run: function() {\n    var C = this;\n    return new C().run();\n  },\n  \n  module: function(desc, opts) {\n    if (!opts) opts = {};\n    var setup = opts.setup, teardown = opts.teardown;\n    this.reopen({\n      run: function() {\n        this._super();\n        var title = SC.get(this,'name')+': '+desc, ctx = this;\n        module(title, {\n          setup: function() {\n            if (setup) setup.call(ctx);\n          },\n\n          teardown: function() {\n            if (teardown) teardown.call(ctx);\n          }\n        });\n      }\n    });\n  },\n  \n  test: function(name, func) {\n    this.reopen({\n      run: function() {\n        this._super();\n        var ctx = this;\n        if (!func) test(name); // output warning\n        else test(name, function() { func.call(ctx); });\n      }\n    });\n  },\n  \n  // convert to guids to minimize logging.\n  same: function(actual, exp, message) {\n    actual = (actual && actual.map) ? actual.map(function(x) { return SC.guidFor(x); }) : actual;\n    exp = (exp && exp.map) ? exp.map(function(x) { return SC.guidFor(x); }) : exp;\n    return same(actual, exp, message);\n  },\n  \n  // easy way to disable tests\n  notest: function() {}\n  \n});\n\nSC.EnumerableTests = EnumerableTests;\nSC.EnumerableTests.ObserverClass = ObserverClass;\n\nrequire('./enumerable/contains');\nrequire('./enumerable/every');\nrequire('./enumerable/filter');\nrequire('./enumerable/find');\nrequire('./enumerable/firstObject');\nrequire('./enumerable/forEach');\nrequire('./enumerable/invoke');\nrequire('./enumerable/lastObject');\nrequire('./enumerable/map');\nrequire('./enumerable/some');\nrequire('./enumerable/toArray');\nrequire('./enumerable/uniq');\nrequire('./enumerable/without');\n\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/contains", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('contains');\n\nsuite.test('contains returns true if items is in enumerable', function() {\n  var data = this.newFixture(3);\n  var obj  = this.newObject(data);\n  equals(obj.contains(data[1]), true, 'should return true if contained');\n});\n\nsuite.test('contains returns false if item is not in enumerable', function() {\n  var data = this.newFixture(1);\n  var obj  = this.newObject(this.newFixture(3));\n  equals(obj.contains(data[0]), false, 'should return true if not contained');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/every", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\nrequire('sproutcore-runtime/mixins/comparable');\n\nvar suite = SC.EnumerableTests;\n\n// ..........................................................\n// every()\n// \n\nsuite.module('every');\n\nsuite.test('every should should invoke callback on each item as long as you return true', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [], result;\n      \n  result = obj.every(function(i) { found.push(i); return true; });\n  equals(result, true, 'return value of obj.every');\n  same(found, ary, 'items passed during every() should match');\n});\n\nsuite.test('every should stop invoking when you return false', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2, \n      exp = cnt, \n      found = [], result;\n      \n  result = obj.every(function(i) { found.push(i); return --cnt>0; });\n  equals(result, false, 'return value of obj.every');\n  equals(found.length, exp, 'should invoke proper number of times');\n  same(found, ary.slice(0,-2), 'items passed during every() should match');\n});\n\n// ..........................................................\n// everyProperty()\n// \n\nsuite.module('everyProperty');\n\nsuite.test('should return true of every property matches', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: 'BAZ' }, \n    SC.Object.create({ foo: 'foo', bar: 'bar' })\n  ]);\n  \n  equals(obj.everyProperty('foo', 'foo'), true, 'everyProperty(foo)');\n  equals(obj.everyProperty('bar', 'bar'), false, 'everyProperty(bar)');\n});\n\nsuite.test('should return true of every property is true', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: true }, \n    SC.Object.create({ foo: 'bar', bar: false })\n  ]);\n\n  // different values - all eval to true\n  equals(obj.everyProperty('foo'), true, 'everyProperty(foo)');\n  equals(obj.everyProperty('bar'), false, 'everyProperty(bar)');\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/filter", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\nrequire('sproutcore-runtime/mixins/comparable');\n\nvar suite = SC.EnumerableTests;\n\n// ..........................................................\n// filter()\n// \n\nsuite.module('filter');\n\nsuite.test('filter should invoke on each item', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2,\n      found = [], result;\n\n  // return true on all but the last two\n  result = obj.filter(function(i) { found.push(i); return --cnt>=0; });\n  same(found, ary, 'should have invoked on each item');\n  same(result, ary.slice(0,-2), 'filtered array should exclude items');\n});\n\n// ..........................................................\n// filterProperty()\n// \n\nsuite.module('filterProperty');\n\nsuite.test('should filter based on object', function() {\n  var obj, ary;\n  \n  ary = [\n    { foo: 'foo', bar: 'BAZ' }, \n    SC.Object.create({ foo: 'foo', bar: 'bar' })\n  ];\n  \n  obj = this.newObject(ary);\n  \n  same(obj.filterProperty('foo', 'foo'), ary, 'filterProperty(foo)');\n  same(obj.filterProperty('bar', 'bar'), [ary[1]], 'filterProperty(bar)');\n});\n\nsuite.test('should include in result if property is true', function() {\n  var obj, ary;\n  \n  ary = [\n    { foo: 'foo', bar: true }, \n    SC.Object.create({ foo: 'bar', bar: false })\n  ];\n  \n  obj = this.newObject(ary);\n\n  // different values - all eval to true\n  same(obj.filterProperty('foo'), ary, 'filterProperty(foo)');\n  same(obj.filterProperty('bar'), [ary[0]], 'filterProperty(bar)');\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/find", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\nrequire('sproutcore-runtime/mixins/comparable');\n\nvar suite = SC.EnumerableTests;\n\n// ..........................................................\n// find()\n// \n\nsuite.module('find');\n\nsuite.test('find should invoke callback on each item as long as you return false', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [], result;\n      \n  result = obj.find(function(i) { found.push(i); return false; });\n  equals(result, undefined, 'return value of obj.find');\n  same(found, ary, 'items passed during find() should match');\n});\n\nsuite.test('every should stop invoking when you return true', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2, \n      exp = cnt, \n      found = [], result;\n      \n  result = obj.find(function(i) { found.push(i); return !(--cnt>0); });\n  equals(result, ary[exp-1], 'return value of obj.find');\n  equals(found.length, exp, 'should invoke proper number of times');\n  same(found, ary.slice(0,-2), 'items passed during find() should match');\n});\n\n// ..........................................................\n// findProperty()\n// \n\nsuite.module('findProperty');\n\nsuite.test('should return first object of property matches', function() {\n  var ary, obj;\n  \n  ary = [\n    { foo: 'foo', bar: 'BAZ' }, \n    SC.Object.create({ foo: 'foo', bar: 'bar' })\n  ];\n  \n  obj = this.newObject(ary);\n  \n  equals(obj.findProperty('foo', 'foo'), ary[0], 'findProperty(foo)');\n  equals(obj.findProperty('bar', 'bar'), ary[1], 'findProperty(bar)');\n});\n\nsuite.test('should return first object with truthy prop', function() {\n  var ary, obj ;\n  \n  ary = [\n    { foo: 'foo', bar: false }, \n    SC.Object.create({ foo: 'bar', bar: true })\n  ];\n  \n  obj = this.newObject(ary);\n\n  // different values - all eval to true\n  equals(obj.findProperty('foo'), ary[0], 'findProperty(foo)');\n  equals(obj.findProperty('bar'), ary[1], 'findProperty(bar)');\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/firstObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('firstObject');\n\nsuite.test('firstObject return first item in enumerable', function() {\n  var obj = this.newObject();\n  equals(SC.get(obj, 'firstObject'), this.toArray(obj)[0]);\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/forEach", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('forEach');\n\nsuite.test('forEach should iterate over list', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [];\n      \n  obj.forEach(function(i) { found.push(i); });\n  same(found, ary, 'items passed during forEach should match');\n});\n\n\nsuite.test('forEach should iterate over list after mutation', function() {\n  if (SC.get(this, 'canTestMutation')) return ;\n  \n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [];\n      \n  obj.forEach(function(i) { found.push(i); });\n  same(found, ary, 'items passed during forEach should match');\n      \n  this.mutate(obj);\n  ary = this.toArray(obj);\n  found = [];\n  \n  obj.forEach(function(i) { found.push(i); });\n  same(found, ary, 'items passed during forEach should match');\n});\n\nsuite.test('2nd target parameter', function() {\n  var obj = this.newObject(), target = this;\n  \n  \n  obj.forEach(function() { \n    equals(SC.guidFor(this), SC.guidFor(window), 'should pass window as this if no context');\n  });\n\n  obj.forEach(function() { \n    equals(SC.guidFor(this), SC.guidFor(target), 'should pass target as this if context');\n  }, target);\n\n});\n\n\nsuite.test('callback params', function() {\n  var obj = this.newObject(), \n      ary = this.toArray(obj),\n      loc = 0;\n  \n  \n  obj.forEach(function(item, idx, enumerable) { \n    equals(item, ary[loc], 'item param');\n    equals(idx, loc, 'idx param');\n    equals(SC.guidFor(enumerable), SC.guidFor(obj), 'enumerable param');\n    loc++;\n  });\n\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/invoke", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('invoke');\n\nsuite.test('invoke should call on each object that implements', function() {\n  var cnt, ary, obj;\n  \n  function F(amt) {\n    cnt += amt===undefined ? 1 : amt;\n  }\n  cnt = 0;\n  ary = [\n    { foo: F },\n    SC.Object.create({ foo: F }),\n    \n    // NOTE: does not impl foo - invoke should just skip\n    SC.Object.create({ bar: F }),\n\n    { foo: F }\n  ];\n  \n  obj = this.newObject(ary);\n  obj.invoke('foo');\n  equals(cnt, 3, 'should have invoked 3 times');\n  \n  cnt = 0;\n  obj.invoke('foo', 2);\n  equals(cnt, 6, 'should have invoked 3 times, passing param');\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/lastObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('lastObject');\n\nsuite.test('lastObject return first item in enumerable', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj);\n  equals(SC.get(obj, 'lastObject'), ary[ary.length-1]);\n});\n \n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/map", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('map');\n\nfunction mapFunc(item) { return item ? item.toString() : null; }\n\nsuite.test('map should iterate over list', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj).map(mapFunc),\n      found = [];\n      \n  found = obj.map(mapFunc);\n  same(found, ary, 'mapped arrays should match');\n});\n\n\nsuite.test('map should iterate over list after mutation', function() {\n  if (SC.get(this, 'canTestMutation')) return ;\n  \n  var obj = this.newObject(),\n      ary = this.toArray(obj).map(mapFunc),\n      found;\n      \n  found = obj.map(mapFunc);\n  same(found, ary, 'items passed during forEach should match');\n      \n  this.mutate(obj);\n  ary = this.toArray(obj).map(mapFunc);\n  found = obj.map(mapFunc);\n  same(found, ary, 'items passed during forEach should match');\n});\n\nsuite.test('2nd target parameter', function() {\n  var obj = this.newObject(), target = this;\n  \n  \n  obj.map(function() { \n    equals(SC.guidFor(this), SC.guidFor(window), 'should pass window as this if no context');\n  });\n\n  obj.map(function() { \n    equals(SC.guidFor(this), SC.guidFor(target), 'should pass target as this if context');\n  }, target);\n\n});\n\n\nsuite.test('callback params', function() {\n  var obj = this.newObject(), \n      ary = this.toArray(obj),\n      loc = 0;\n  \n  \n  obj.map(function(item, idx, enumerable) { \n    equals(item, ary[loc], 'item param');\n    equals(idx, loc, 'idx param');\n    equals(SC.guidFor(enumerable), SC.guidFor(obj), 'enumerable param');\n    loc++;\n  });\n\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/some", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\n// ..........................................................\n// some()\n// \n\nsuite.module('some');\n\nsuite.test('some should should invoke callback on each item as long as you return false', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [], result;\n      \n  result = obj.some(function(i) { found.push(i); return false; });\n  equals(result, false, 'return value of obj.some');\n  same(found, ary, 'items passed during some() should match');\n});\n\nsuite.test('every should stop invoking when you return true', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2, \n      exp = cnt, \n      found = [], result;\n      \n  result = obj.some(function(i) { found.push(i); return !(--cnt>0); });\n  equals(result, true, 'return value of obj.some');\n  equals(found.length, exp, 'should invoke proper number of times');\n  same(found, ary.slice(0,-2), 'items passed during some() should match');\n});\n\n// ..........................................................\n// someProperty()\n// \n\nsuite.module('someProperty');\n\nsuite.test('should return true of any property matches', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: 'BAZ' }, \n    SC.Object.create({ foo: 'foo', bar: 'bar' })\n  ]);\n  \n  equals(obj.someProperty('foo', 'foo'), true, 'someProperty(foo)');\n  equals(obj.someProperty('bar', 'bar'), true, 'someProperty(bar)');\n  equals(obj.someProperty('bar', 'BIFF'), false, 'someProperty(BIFF)');\n});\n\nsuite.test('should return true of any property is true', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: true }, \n    SC.Object.create({ foo: 'bar', bar: false })\n  ]);\n\n  // different values - all eval to true\n  equals(obj.someProperty('foo'), true, 'someProperty(foo)');\n  equals(obj.someProperty('bar'), true, 'someProperty(bar)');\n  equals(obj.someProperty('BIFF'), false, 'someProperty(biff)');\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/toArray", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('toArray');\n\nsuite.test('toArray should convert to an array', function() {\n  var obj = this.newObject();\n  same(obj.toArray(), this.toArray(obj));\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/uniq", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('uniq');\n\nsuite.test('should return new instance with duplicates removed', function() {\n  var before, after, obj, ret;\n  \n  after  = this.newFixture(3);\n  before = [after[0], after[1], after[2], after[1], after[0]];\n  obj    = this.newObject(before);\n  before = obj.toArray(); // in case of set before will be different...\n  \n  ret = obj.uniq();\n  same(this.toArray(ret), after, 'should have removed item');\n  same(this.toArray(obj), before, 'should not have changed original');\n});\n\nsuite.test('should return same content if no duplicates found', function() {\n  var item, obj, ret;\n  obj = this.newObject(this.newFixture(3));\n  ret = obj.uniq(item);\n  same(this.toArray(ret), this.toArray(obj), 'should be same content');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/enumerable/without", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nvar suite = SC.EnumerableTests;\n\nsuite.module('without');\n\nsuite.test('should return new instance with item removed', function() {\n  var before, after, obj, ret;\n  \n  before = this.newFixture(3);\n  after  = [before[0], before[2]];\n  obj    = this.newObject(before);\n  \n  ret = obj.without(before[1]);\n  same(this.toArray(ret), after, 'should have removed item');\n  same(this.toArray(obj), before, 'should not have changed original');\n});\n\nsuite.test('should return same instance if object not found', function() {\n  var item, obj, ret;\n  \n  item   = this.newFixture(1)[0];\n  obj    = this.newObject(this.newFixture(3));\n  \n  ret = obj.without(item);\n  equals(ret, obj, 'should be same instance');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/array');\n\nSC.MutableArrayTests = SC.ArrayTests.extend();\n\nrequire('./mutable_array/insertAt');\nrequire('./mutable_array/popObject');\nrequire('./mutable_array/pushObject');\nrequire('./mutable_array/removeAt');\nrequire('./mutable_array/replace');\nrequire('./mutable_array/shiftObject');\nrequire('./mutable_array/unshiftObject');\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array/insertAt", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals raises */\n\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nvar suite = SC.MutableArrayTests;\n\nsuite.module('insertAt');\n\nsuite.test(\"[].insertAt(0, X) => [X] + notify\", function() {\n  var obj, after, observer;\n  \n  after = this.newFixture(1);\n  obj = this.newObject([]);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.insertAt(0, after[0]);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[].insertAt(200,X) => OUT_OF_RANGE_EXCEPTION exception\", function() {\n  var obj = this.newObject([]), that = this;\n  raises(function() {\n    obj.insertAt(200, that.newFixture(1)[0]);\n  }, Error);\n});\n\nsuite.test(\"[A].insertAt(0, X) => [X,A] + notify\", function() {\n  var obj, item, after, before, observer;\n  \n  item = this.newFixture(1)[0];\n  before = this.newFixture(1);\n  after  = [item, before[0]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.insertAt(0, item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A].insertAt(1, X) => [A,X] + notify\", function() {\n  var obj, item, after, before, observer;\n  \n  item = this.newFixture(1)[0];\n  before = this.newFixture(1);\n  after  = [before[0], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.insertAt(1, item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A].insertAt(200,X) => OUT_OF_RANGE exception\", function() {\n  var obj = this.newObject(this.newFixture(1)), that = this;\n  raises(function() {\n    obj.insertAt(200, that.newFixture(1)[0]);\n  }, Error);\n});\n\nsuite.test(\"[A,B,C].insertAt(0,X) => [X,A,B,C] + notify\", function() {\n  var obj, item, after, before, observer;\n  \n  item = this.newFixture(1)[0];\n  before = this.newFixture(3);\n  after  = [item, before[0], before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.insertAt(0, item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].insertAt(1,X) => [A,X,B,C] + notify\", function() {\n  var obj, item, after, before, observer;\n  \n  item = this.newFixture(1)[0];\n  before = this.newFixture(3);\n  after  = [before[0], item, before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.insertAt(1, item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].insertAt(3,X) => [A,B,C,X] + notify\", function() {\n  var obj, item, after, before, observer;\n  \n  item = this.newFixture(1)[0];\n  before = this.newFixture(3);\n  after  = [before[0], before[1], before[2], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.insertAt(3, item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array/popObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nvar suite = SC.MutableArrayTests;\n\nsuite.module('popObject');\n\nsuite.test(\"[].popObject() => [] + returns undefined + NO notify\", function() {\n  var obj, observer;\n  \n  obj = this.newObject([]);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.popObject(), undefined, 'popObject results');\n\n  same(this.toArray(obj), [], 'post item results');\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), false, 'should NOT have notified []');\n    equals(observer.validate('length'), false, 'should NOT have notified length');\n  }\n});\n\nsuite.test(\"[X].popObject() => [] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(1);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  ret = obj.popObject();\n\n  equals(ret, before[0], 'return object');\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should NOT have notified []');\n    equals(observer.validate('length'), true, 'should NOT have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].popObject() => [A,B] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(3);\n  after  = [before[0], before[1]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  ret = obj.popObject();\n\n  equals(ret, before[2], 'return object');\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should NOT have notified []');\n    equals(observer.validate('length'), true, 'should NOT have notified length');\n  }\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array/pushObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nvar suite = SC.MutableArrayTests;\n\nsuite.module('pushObject');\n\nsuite.test(\"returns pushed object\", function() {\n  var exp = this.newFixture(1)[0];\n  var obj = this.newObject([]);\n  equals(obj.pushObject(exp), exp, 'should return pushed object');\n});\n\nsuite.test(\"[].pushObject(X) => [X] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = [];\n  after  = this.newFixture(1);\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.pushObject(after[0]);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].pushObject(X) => [A,B,C,X] + notify\", function() {\n  var obj, before, after, item, observer, ret;\n  \n  before = this.newFixture(3);\n  item   = this.newFixture(1)[0];\n  after  = [before[0], before[1], before[2], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.pushObject(item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array/removeAt", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals raises */\n\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nvar suite = SC.MutableArrayTests;\n\nsuite.module('removeAt');\n\nsuite.test(\"[X].removeAt(0) => [] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(1);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.removeAt(0), obj, 'return self');\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[].removeAt(200) => OUT_OF_RANGE_EXCEPTION exception\", function() {\n  var obj = this.newObject([]);\n  raises(function() {\n    obj.removeAt(200);\n  }, Error);\n});\n\nsuite.test(\"[A,B].removeAt(0) => [B] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(2);\n  after  = [before[1]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.removeAt(0), obj, 'return self');\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B].removeAt(1) => [A] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(2);\n  after  = [before[0]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.removeAt(1), obj, 'return self');\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].removeAt(1) => [A,C] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(3);\n  after  = [before[0], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.removeAt(1), obj, 'return self');\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C,D].removeAt(1,2) => [A,D] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(4);\n  after  = [before[0], before[3]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.removeAt(1,2), obj, 'return self');\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.notest(\"[A,B,C,D].removeAt(IndexSet<0,2-3>) => [B] + notify\");\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array/replace", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nvar suite = SC.MutableArrayTests;\n\nsuite.module('replace');\n\nsuite.test(\"[].replace(0,0,'X') => ['X'] + notify\", function() {\n\n  var obj, exp, observer;\n  exp = this.newFixture(1);\n  obj = this.newObject([]);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.replace(0,0,exp) ;\n  \n  same(this.toArray(obj), exp, 'post item results');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C,D].replace(1,2,X) => [A,X,D] + notify\", function() {\n  var obj, observer, before, replace, after;\n  \n  before  = this.newFixture(4);\n  replace = this.newFixture(1);\n  after   = [before[0], replace[0], before[3]];\n  \n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.replace(1,2,replace) ;\n\n  same(this.toArray(obj), after, 'post item results');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C,D].replace(1,2,[X,Y]) => [A,X,Y,D] + notify\", function() {\n  var obj, observer, before, replace, after;\n  \n  before  = this.newFixture(4);\n  replace = this.newFixture(2);\n  after   = [before[0], replace[0], replace[1], before[3]];\n  \n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.replace(1,2,replace) ;\n\n  same(this.toArray(obj), after, 'post item results');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B].replace(1,0,[X,Y]) => [A,X,Y,B] + notify\", function() {\n  var obj, observer, before, replace, after;\n  \n  before  = this.newFixture(2);\n  replace = this.newFixture(2);\n  after   = [before[0], replace[0], replace[1], before[1]];\n  \n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.replace(1,0,replace) ;\n\n  same(this.toArray(obj), after, 'post item results');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.notest(\"[A,B,C,D].replace(2,2) => [A,B] + notify\", function() {\n  var obj, observer, before, replace, after;\n  \n  before  = this.newFixture(4);\n  after   = [before[0], before[1]];\n  \n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.replace(2,2) ;\n\n  same(this.toArray(obj), after, 'post item results');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test('Adding object should notify enumerable observer', function() {\n\n  var fixtures = this.newFixture(4);\n  var obj = this.newObject(fixtures);\n  var observer = this.newObserver(obj).observeEnumerable(obj);\n  var item = this.newFixture(1)[0];\n  \n  obj.replace(2, 2, [item]);\n  \n  same(observer._before, [obj, [fixtures[2], fixtures[3]], 1], 'before');\n  same(observer._after, [obj, 2, [item]], 'after');\n});\n\nsuite.test('Adding object should notify array observer', function() {\n\n  var fixtures = this.newFixture(4);\n  var obj = this.newObject(fixtures);\n  var observer = this.newObserver(obj).observeArray(obj);\n  var item = this.newFixture(1)[0];\n  \n  obj.replace(2, 2, [item]);\n  \n  same(observer._before, [obj, 2, 2, 1], 'before');\n  same(observer._after, [obj, 2, 2, 1], 'after');\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array/shiftObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nvar suite = SC.MutableArrayTests;\n\nsuite.module('shiftObject');\n\nsuite.test(\"[].shiftObject() => [] + returns undefined + NO notify\", function() {\n  var obj, before, after, observer, item;\n  \n  before = [];\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.shiftObject(), undefined);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), false, 'should NOT have notified []');\n    equals(observer.validate('length'), false, 'should NOT have notified length');\n  }\n});\n\nsuite.test(\"[X].shiftObject() => [] + notify\", function() {\n  var obj, before, after, observer;\n  \n  before = this.newFixture(1);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.shiftObject(), before[0], 'should return object');\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].shiftObject() => [B,C] + notify\", function() {\n  var obj, before, after, observer;\n  \n  before = this.newFixture(3);\n  after  = [before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  equals(obj.shiftObject(), before[0], 'should return object');\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_array/unshiftObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_array');\n\nvar suite = SC.MutableArrayTests;\n\nsuite.module('unshiftObject');\n\nsuite.test(\"returns unshifted object\", function() {\n  var obj = this.newObject([]);\n  var item = this.newFixture(1)[0];\n  equals(obj.unshiftObject(item), item, 'should return receiver');\n});\n\n\nsuite.test(\"[].unshiftObject(X) => [X] + notify\", function() {\n  var obj, before, after, item, observer;\n  \n  before = [];\n  item = this.newFixture(1)[0];\n  after  = [item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.unshiftObject(item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].unshiftObject(X) => [X,A,B,C] + notify\", function() {\n  var obj, before, after, item, observer;\n  \n  before = this.newFixture(3);\n  item = this.newFixture(1)[0];\n  after  = [item, before[0], before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.unshiftObject(item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].unshiftObject(A) => [A,A,B,C] + notify\", function() {\n  var obj, before, after, item, observer;\n  \n  before = this.newFixture(3);\n  item = before[0]; // note same object as current head. should end up twice\n  after  = [item, before[0], before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.unshiftObject(item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should have notified []');\n    equals(observer.validate('length'), true, 'should have notified length');\n  }\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_enumerable", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/enumerable');\n\nSC.MutableEnumerableTests = SC.EnumerableTests.extend();\n\nrequire('./mutable_enumerable/addObject');\nrequire('./mutable_enumerable/removeObject');\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_enumerable/addObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_enumerable');\n\nvar suite = SC.MutableEnumerableTests;\n\nsuite.module('addObject');\n\nsuite.test(\"should return receiver\", function() {\n  var before, obj;\n  before = this.newFixture(3);\n  obj    = this.newObject(before);\n  equals(obj.addObject(before[1]), obj, 'should return receiver');\n});\n\nsuite.test(\"[A,B].addObject(C) => [A,B, C] + notify\", function() {\n  var obj, before, after, observer, item, ret;\n  \n  before = this.newFixture(2);\n  item   = this.newFixture(1)[0];\n  after  = [before[0], before[1], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.addObject(item);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should NOT have notified []');\n    equals(observer.validate('length'), true, 'should NOT have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].addObject(A) => [A,B,C] + NO notify\", function() {\n  var obj, before, after, observer, item;\n  \n  before = this.newFixture(3);\n  after  = before;\n  item   = before[0];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.addObject(item); // note: item in set\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n  \n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), false, 'should NOT have notified []');\n    equals(observer.validate('length'), false, 'should NOT have notified length');\n  }\n});\n\nsuite.test('Adding object should notify enumerable observer', function() {\n  \n  var obj = this.newObject(this.newFixture(3));\n  var observer = this.newObserver(obj).observeEnumerable(obj);\n  var item = this.newFixture(1)[0];\n  \n  obj.addObject(item);\n  \n  same(observer._before, [obj, null, [item]]);\n  same(observer._after, [obj, null, [item]]);\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/mutable_enumerable/removeObject", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/~tests/suites/mutable_enumerable');\n\nvar suite = SC.MutableEnumerableTests;\n\nsuite.module('removeObject');\n\nsuite.test(\"should return receiver\", function() {\n  var before, obj;\n  before = this.newFixture(3);\n  obj    = this.newObject(before);\n  equals(obj.removeObject(before[1]), obj, 'shoudl return receiver');\n});\n\nsuite.test(\"[A,B,C].removeObject(B) => [A,C] + notify\", function() {\n  var obj, before, after, observer, ret;\n  \n  before = this.newFixture(3);\n  after  = [before[0], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.removeObject(before[1]);\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), true, 'should NOT have notified []');\n    equals(observer.validate('length'), true, 'should NOT have notified length');\n  }\n});\n\nsuite.test(\"[A,B,C].removeObject(D) => [A,B,C]\", function() {\n  var obj, before, after, observer, item;\n  \n  before = this.newFixture(3);\n  after  = before;\n  item   = this.newFixture(1)[0];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.removeObject(item); // note: item not in set\n\n  same(this.toArray(obj), after, 'post item results');\n  equals(SC.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equals(observer.validate('[]'), false, 'should NOT have notified []');\n    equals(observer.validate('length'), false, 'should NOT have notified length');\n  }\n});\n\nsuite.test('Removing object should notify enumerable observer', function() {\n  \n  var fixtures = this.newFixture(3);\n  var obj = this.newObject(fixtures);\n  var observer = this.newObserver(obj).observeEnumerable(obj);\n  var item = fixtures[1];\n  \n  obj.removeObject(item);\n  \n  same(observer._before, [obj, [item], null]);\n  same(observer._after, [obj, [item], null]);\n});\n\n});");spade.register("sproutcore-runtime/~tests/suites/suite", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nrequire('sproutcore-runtime/system/object');\n\n\n/**\n  @class\n  A Suite can be used to define a reusable set of unit tests that can be \n  applied to any object.  Suites are most useful for defining tests that \n  work against a mixin or plugin API.  Developers implementing objects that \n  use the mixin or support the API can then run these tests against their \n  own code to verify compliance.\n  \n  To define a suite, you need to define the tests themselves as well as a \n  callback API implementors can use to tie your tests to thier specific class.\n  \n  ## Defining a Callback API\n  \n  To define the callback API, just extend this class and add your properties\n  or methods that must be provided.  Use SC.required() placeholders for\n  any properties that implementors must define themselves.\n  \n  ## Defining Unit Tests\n  \n  To add unit tests, use the suite.module() or suite.test() methods instead \n  of a regular module() or test() method when defining your tests.  This will\n  add the tests to the suite.\n  \n  ## Using a Suite\n  \n  To use a Suite to test your own objects, extend the suite subclass and \n  define any required methods.  Then call run() on the new subclass.  This\n  will create an instance of your class and then defining the unit tests.\n  \n  @extends SC.Object\n  @private\n*/\nSC.Suite = SC.Object.extend(\n  /** @scope SC.Suite.prototype */ {\n  \n  /**\n    Define a name for these tests - all modules are prefixed w/ it.\n    \n    @property {String}\n  */\n  name: SC.required(String),\n  \n  /**\n    Invoked to actually run the test - overridden by mixins\n  */\n  run: function() {}  \n\n});\n\nSC.Suite.reopenClass({\n  \n  plan: null,\n  \n  run: function() {\n    var C = this;\n    return new C().run();\n  },\n  \n  module: function(desc, opts) {\n    if (!opts) opts = {};\n    var setup = opts.setup, teardown = opts.teardown;\n    this.reopen({\n      run: function() {\n        this._super();\n        var title = SC.get(this, 'name')+': '+desc, ctx = this;\n        module(title, {\n          setup: function() {\n            if (setup) setup.call(ctx);\n          },\n\n          teardown: function() {\n            if (teardown) teardown.call(ctx);\n          }\n        });\n      }\n    });\n  },\n  \n  test: function(name, func) {\n    this.reopen({\n      run: function() {\n        this._super();\n        var ctx = this;\n        if (!func) test(name); // output warning\n        else test(name, function() { func.call(ctx); });\n      }\n    });\n  },\n  \n  // convert to guids to minimize logging.\n  same: function(actual, exp, message) {\n    actual = (actual && actual.map) ? actual.map(function(x) { return SC.guidFor(x); }) : actual;\n    exp = (exp && exp.map) ? exp.map(function(x) { return SC.guidFor(x); }) : exp;\n    return same(actual, exp, message);\n  },\n  \n  // easy way to disable tests\n  notest: function() {}\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/application/base_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.Application');\n\ntest('SC.Application should be a subclass of SC.Namespace', function() {\n\n  ok(SC.Namespace.detect(SC.Application), 'SC.Application subclass of SC.Namespace');\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/array_proxy/suite_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nSC.MutableArrayTests.extend({\n  \n  name: 'SC.ArrayProxy',\n  \n  newObject: function(ary) {\n    var ret = ary ? ary.slice() : this.newFixture(3);\n    return new SC.ArrayProxy(ret);\n  },\n\n  mutate: function(obj) {\n    obj.pushObject(SC.get(obj, 'length')+1);\n  },\n  \n  toArray: function(obj) {\n    return obj.toArray ? obj.toArray() : obj.slice();\n  }\n  \n}).run();\n\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/and_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar MyApp, set = SC.set, get = SC.get;\n\nmodule('binding/and', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: false,\n      bar: false,\n      bazBinding: SC.Binding.and('foo', 'bar')\n    });\n  },\n  \n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntest('should return second item when both are truthy', function() {\n  set(MyApp, 'foo', true);\n  set(MyApp, 'bar', 'BAR');\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 'BAR', 'should be false');\n});\n\ntest('should return false first item', function() {\n  set(MyApp, 'foo', 0);\n  set(MyApp, 'bar', true);\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 0, 'should be false');\n});\n\ntest('should return false second item', function() {\n  set(MyApp, 'foo', true);\n  set(MyApp, 'bar', 0);\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 0, 'should be false');\n});\n\ntest('should return first item when both are false', function() {\n  set(MyApp, 'foo', 0);\n  set(MyApp, 'bar', null);\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 0, 'should be false');\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/bool_not_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals MyApp */\n\n\nfunction testBool(val, expected) {\n  test('Forces '+Object.prototype.toString.call(val)+' value to '+expected, function() {\n    SC.set(MyApp.foo, 'value', val);\n    SC.run.sync();\n    equals(SC.get(MyApp.bar, 'value'), expected);\n  });\n}\n\nmodule('system/binding/bool', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: SC.Object.create({ value: 'FOO' }),\n      bar: SC.Object.create({ value: 'BAR' })\n    });\n    \n    SC.bind(MyApp, 'bar.value', 'foo.value').bool();\n  },\n\n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntestBool(true, true);\ntestBool('STRING', true);\ntestBool(23, true);\ntestBool({ object: 123 }, true);\ntestBool([1,2,3], true);\ntestBool([], true);\n\ntestBool(false, false);\ntestBool(null, false);\ntestBool(undefined, false);\ntestBool(0, false);\ntestBool('', false);\n\n\nmodule('system/binding/not', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: SC.Object.create({ value: 'FOO' }),\n      bar: SC.Object.create({ value: 'BAR' })\n    });\n    \n    SC.bind(MyApp, 'bar.value', 'foo.value').not();\n  },\n\n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntestBool(true, false);\ntestBool('STRING', false);\ntestBool(23, false);\ntestBool({ object: 123 }, false);\ntestBool([1,2,3], false);\ntestBool([], false);\n\ntestBool(false, true);\ntestBool(null, true);\ntestBool(undefined, true);\ntestBool(0, true);\ntestBool('', true);\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/connect_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals GlobalA GlobalB testBoth */\n\n\nrequire('sproutcore-runtime/~tests/props_helper');\n\nmodule('system/mixin/binding/connect_test');\n\nfunction performTest(binding, a, b, get, set, skipFirst) {\n  \n  if (!skipFirst) {\n    SC.run.sync();\n    equals(get(a, 'foo'), 'FOO', 'a should not have changed');\n    equals(get(b, 'bar'), 'BAR', 'b should not have changed');\n  }\n\n  binding.connect(a);\n  equals(get(a, 'foo'), 'FOO', 'a should not have changed before sync');\n  equals(get(b, 'bar'), 'BAR', 'b should not have changed before sync');\n  \n  SC.run.sync();\n  equals(get(a, 'foo'), 'BAR', 'a should have changed');\n  equals(get(b, 'bar'), 'BAR', 'b should have changed');\n  // \n  // make sure changes sync both ways\n  set(b, 'bar', 'BAZZ');\n  SC.run.sync();\n  equals(get(a, 'foo'), 'BAZZ', 'a should have changed');\n  \n  set(a, 'foo', 'BARF');\n  SC.run.sync();\n  equals(get(b, 'bar'), 'BARF', 'a should have changed');\n}\n\ntestBoth('Connecting a binding between two properties', function(get, set) {\n  var a = SC.Object.create({ foo: 'FOO', bar: 'BAR' });\n  \n  // a.bar -> a.foo\n  var binding = new SC.Binding('foo', 'bar');\n\n  performTest(binding, a, a, get, set);\n});\n\ntestBoth('Connecting a binding between two objects', function(get, set) {\n  var b = SC.Object.create({ bar: 'BAR' });\n  var a = SC.Object.create({ foo: 'FOO', b: b });\n  \n  // b.bar -> a.foo\n  var binding = new SC.Binding('foo', 'b.bar');\n\n  performTest(binding, a, b, get, set);\n});\n\ntestBoth('Connecting a binding to path', function(get, set) {\n  var a = SC.Object.create({ foo: 'FOO' });\n  GlobalB = SC.Object.create({\n    b: SC.Object.create({ bar: 'BAR' })\n  }) ;\n  \n  var b = get(GlobalB, 'b');\n  \n  // globalB.b.bar -> a.foo\n  var binding = new SC.Binding('foo', 'GlobalB.b.bar');\n  \n  performTest(binding, a, b, get, set);\n\n  // make sure modifications update\n  b = SC.Object.create({ bar: 'BIFF' });\n  set(GlobalB, 'b', b);\n  SC.run.sync();\n  equals(get(a, 'foo'), 'BIFF', 'a should have changed');\n  \n});\n\ntestBoth('Calling connect more than once', function(get, set) {\n  var b = SC.Object.create({ bar: 'BAR' });\n  var a = SC.Object.create({ foo: 'FOO', b: b });\n  \n  // b.bar -> a.foo\n  var binding = new SC.Binding('foo', 'b.bar');\n  binding.connect(a);\n\n  performTest(binding, a, b, get, set, true);\n});\n\ntestBoth('Bindings should be inherited', function(get, set) {\n\n  var a = { foo: 'FOO', b: { bar: 'BAR' } };\n  var binding = new SC.Binding('foo', 'b.bar');\n  binding.connect(a);\n  \n  var a2 = SC.create(a);\n  SC.run.sync();\n  equals(get(a2, 'foo'), \"BAR\", \"Should have synced binding on child\");\n  equals(get(a,  'foo'), \"BAR\", \"Should NOT have synced binding on parent\");\n\n  set(a2, 'b', { bar: 'BAZZ' });\n  SC.run.sync();\n  \n  equals(get(a2, 'foo'), \"BAZZ\", \"Should have synced binding on child\");\n  equals(get(a,  'foo'), \"BAR\", \"Should NOT have synced binding on parent\");\n\n});\n\ntest('inherited bindings should sync on create', function() {\n\n  var A = SC.Object.extend({\n    fooBinding: 'bar.baz'\n  });\n  \n  var a = A.create({\n    bar: SC.Object.create({ baz: 'BAZ' })\n  });\n  \n  SC.run.sync();\n  equals(SC.get(a, 'foo'), 'BAZ', 'should have synced binding on new obj');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/multiple_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals MyApp */\n\n\nmodule('system/binding/multiple', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: SC.Object.create({ value: 'FOO' }),\n      bar: SC.Object.create({ value: 'BAR' })\n    });\n  },\n\n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntest('forces binding values to be multiple', function() {\n  var binding = SC.bind(MyApp, 'bar.value', 'foo.value').multiple();\n\n  SC.run.sync();\n  same(SC.getPath('MyApp.bar.value'), ['FOO'], '1 MyApp.bar.value');\n  \n  SC.setPath('MyApp.foo.value', ['BAR']);\n  SC.run.sync();\n  same(SC.getPath('MyApp.foo.value'), ['BAR'], '2 MyApp.foo.value');\n  same(SC.getPath('MyApp.bar.value'), ['BAR'], '2 MyApp.bar.value');\n\n  SC.setPath('MyApp.foo.value', ['BAR', 'BAZ']);\n  SC.run.sync();\n  same(SC.getPath('MyApp.foo.value'), ['BAR', 'BAZ'], '3 MyApp.foo.value');\n  same(SC.getPath('MyApp.bar.value'), ['BAR', 'BAZ'], '3 MyApp.bar.value');\n\n  SC.setPath('MyApp.foo.value', null);\n  SC.run.sync();\n  same(SC.getPath('MyApp.bar.value'), [], '4 MyApp.bar.value');\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/notEmpty_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals MyApp */\n\n\nmodule('system/binding/notEmpty', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: SC.Object.create({ value: 'FOO' }),\n      bar: SC.Object.create({ value: 'BAR' })\n    });\n  },\n\n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntest('forces binding values to be notEmpty if enumerable', function() {\n  \n  var binding = SC.bind(MyApp, 'bar.value', 'foo.value').notEmpty('(EMPTY)');\n\n  SC.run.sync();\n  same(SC.getPath('MyApp.bar.value'), 'FOO', '1 MyApp.bar.value');\n\n  SC.setPath('MyApp.foo.value', ['FOO']);\n  SC.run.sync();\n  same(SC.getPath('MyApp.bar.value'), ['FOO'], '2 Array passes through');\n\n  SC.setPath('MyApp.foo.value', []);\n  SC.run.sync();\n  same(SC.getPath('MyApp.bar.value'), '(EMPTY)', '3 uses empty placeholder');\n\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/oneWay_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals MyApp */\n\n\nmodule('system/mixin/binding/oneWay_test', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: SC.Object.create({ value: 'FOO' }),\n      bar: SC.Object.create({ value: 'BAR' })\n    });\n  },\n  \n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntest('oneWay(true) should only sync one way', function() {\n  var binding = SC.oneWay(MyApp, 'bar.value', 'foo.value');\n  SC.run.sync();\n  \n  equals(SC.getPath('MyApp.foo.value'), 'FOO', 'foo synced');\n  equals(SC.getPath('MyApp.bar.value'), 'FOO', 'bar synced');\n\n  SC.setPath('MyApp.bar.value', 'BAZ');\n  SC.run.sync();\n  equals(SC.getPath('MyApp.foo.value'), 'FOO', 'foo synced');\n  equals(SC.getPath('MyApp.bar.value'), 'BAZ', 'bar not synced');\n\n  SC.setPath('MyApp.foo.value', 'BIFF');\n  SC.run.sync();\n  equals(SC.getPath('MyApp.foo.value'), 'BIFF', 'foo synced');\n  equals(SC.getPath('MyApp.bar.value'), 'BIFF', 'foo synced');\n\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/or_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar MyApp, set = SC.set, get = SC.get;\n\nmodule('binding/or', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: false,\n      bar: false,\n      bazBinding: SC.Binding.or('foo', 'bar')\n    });\n  },\n  \n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntest('should return first item when both are truthy', function() {\n  set(MyApp, 'foo', 'FOO');\n  set(MyApp, 'bar', 'BAR');\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 'FOO', 'should be false');\n});\n\ntest('should return true first item', function() {\n  set(MyApp, 'foo', 1);\n  set(MyApp, 'bar', false);\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 1, 'should be false');\n});\n\ntest('should return true second item', function() {\n  set(MyApp, 'foo', false);\n  set(MyApp, 'bar', 10);\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 10, 'should be false');\n});\n\ntest('should return second item when both are false', function() {\n  set(MyApp, 'foo', null);\n  set(MyApp, 'bar', 0);\n  SC.run.sync();\n  equals(get(MyApp, 'baz'), 0, 'should be false');\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/single_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals MyApp */\n\n\nmodule('system/binding/single', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: SC.Object.create({ value: 'FOO' }),\n      bar: SC.Object.create({ value: 'BAR' })\n    });\n  },\n\n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntest('forces binding values to be single', function() {\n  var binding = SC.bind(MyApp, 'bar.value', 'foo.value').single();\n\n  SC.run.sync();\n  equals(SC.getPath('MyApp.bar.value'), 'FOO', 'passes single object');\n\n  SC.setPath('MyApp.foo.value', ['BAR']);\n  SC.run.sync();\n  equals(SC.getPath('MyApp.bar.value'), 'BAR', 'passes single object');\n\n  SC.setPath('MyApp.foo.value', ['BAR', 'BAZ']);\n  SC.run.sync();\n  equals(SC.getPath('MyApp.bar.value'), SC.MULTIPLE_PLACEHOLDER, 'converts to placeholder');\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/sync_test", "(function(require, exports, __module, ARGV, ENV, __filename){module(\"system/binding/sync_test.js\");\n\ntestBoth(\"bindings should not try to sync destroyed objects\", function(get, set) {\n  var a, b;\n\n  SC.run(function() {\n    a = SC.Object.create({\n      foo: 'trololol'\n    });\n\n    b = SC.Object.create({\n      a: a,\n      fooBinding: 'a.foo'\n    });\n  });\n\n  SC.run(function() {\n    set(a, 'foo', 'trollface');\n    b.destroy();\n    // should not raise\n  });\n\n  SC.run(function() {\n    a = SC.Object.create({\n      foo: 'trololol'\n    });\n\n    b = SC.Object.create({\n      a: a,\n      fooBinding: 'a.foo'\n    });\n  });\n\n  SC.run(function() {\n    set(b, 'foo', 'trollface');\n    a.destroy();\n    // should not raise\n  });\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/binding/transform_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals MyApp */\n\n\nvar foo, bar, binding, set = SC.set, get = SC.get, setPath = SC.setPath;\n\nvar CountObject = SC.Object.extend({\n  value: null,\n\n  _count: 0,\n\n  reset: function() {  \n    this._count = 0;\n    return this;\n  },\n  \n  valueDidChange: function() {\n    this._count++;\n  }.observes('value')\n});\n\nmodule('system/mixin/binding/transform_test', {\n  setup: function() {\n    MyApp = SC.Object.create({\n      foo: CountObject.create({ value: 'FOO' }),\n      bar: CountObject.create({ value: 'BAR' })\n    });\n    \n    foo = SC.getPath('MyApp.foo');\n    bar = SC.getPath('MyApp.bar');\n  },\n  \n  teardown: function() {\n    binding.disconnect(MyApp);\n    MyApp = null;\n  }\n});\n\ntest('returns this', function() {\n  binding = new SC.Binding('foo.value', 'bar.value');\n\n  var ret = binding.transform({ from: function() {}, to: function() {} });\n  equals(ret, binding);\n});\n\ntest('transform function should be invoked on fwd change', function() {\n  \n  binding = SC.bind(MyApp, 'foo.value', 'bar.value');\n  binding.transform({ to: function(value) { return 'TRANSFORMED'; }});\n  SC.run.sync();\n  \n  // should have transformed...\n  equals(SC.getPath('MyApp.foo.value'), 'TRANSFORMED', 'should transform');\n  equals(SC.getPath('MyApp.bar.value'), 'BAR', 'should stay original');  \n});\n\ntest('two-way transforms work', function() {\n  SC.run(function() {\n    binding = SC.bind(MyApp, 'foo.value', 'bar.value');\n    binding.transform({\n      to: function(string) {\n        return parseInt(string) || null;\n      },\n      from: function(integer) {\n        return String(integer);\n      }\n    });\n  });\n\n  SC.run(function() {\n    setPath(MyApp, 'bar.value', \"1\");\n  });\n\n  equals(SC.getPath('MyApp.foo.value'), 1, \"sets the value to a number\");\n\n  setPath(MyApp, 'foo.value', 1);\n  equals(SC.getPath('MyApp.bar.value'), \"1\", \"sets the value to a string\");\n});\n\ntest('transform function should NOT be invoked on fwd change', function() {\n  \n  var count = 0;\n  binding = SC.bind(MyApp, 'foo.value', 'bar.value');\n  var lastSeenValue;\n  binding.transform({\n    to: function(value) {\n      if (value !== lastSeenValue) count++; // transform must be consistent\n      lastSeenValue = value;\n      return 'TRANSFORMED '+count;\n    }\n  });\n\n  SC.run.sync();\n\n  // should have transformed...\n  foo.reset();\n  bar.reset();\n  \n  SC.setPath('MyApp.bar.value', 'FOOBAR');\n  SC.run.sync();\n\n  equals(SC.getPath('MyApp.foo.value'), 'TRANSFORMED 2', 'should transform');\n  equals(SC.getPath('MyApp.bar.value'), 'FOOBAR', 'should stay original');  \n  \n  equals(foo._count, 1, 'observer should have fired on set');\n  equals(bar._count, 1, 'observer should have fired on set');\n});\n\ntest('transforms should chain', function() {\n  binding = SC.bind(MyApp, 'foo.value', 'bar.value');\n  binding.transform({\n    to: function(value) { return value+' T1'; }\n  });\n  binding.transform({\n    to: function(value) { return value+' T2'; }\n  });\n  SC.run.sync();\n\n  // should have transformed...\n  equals(SC.getPath('MyApp.foo.value'), 'BAR T1 T2', 'should transform');\n  equals(SC.getPath('MyApp.bar.value'), 'BAR', 'should stay original');  \n});\n\ntest('resetTransforms() should clear', function() {\n  binding = SC.bind(MyApp, 'foo.value', 'bar.value');\n  binding.transform({\n    to: function(value) { return value+' T1'; }\n  });\n  binding.resetTransforms();\n  binding.transform({\n    to: function(value) { return value+' T2'; }\n  });\n  SC.run.sync();\n\n  // should have transformed...\n  equals(SC.getPath('MyApp.foo.value'), 'BAR T2', 'should transform');\n  equals(SC.getPath('MyApp.bar.value'), 'BAR', 'should stay original');  \n});\n\n\n});");spade.register("sproutcore-runtime/~tests/system/namespace/base_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.Namepsace');\n\ntest('SC.Namespace should be a subclass of SC.Object', function() {\n  ok(SC.Object.detect(SC.Namespace));\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/native_array/copyable_suite_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n// ..........................................................\n// COPYABLE TESTS\n// \nSC.CopyableTests.extend({\n  name: 'NativeArray Copyable',\n  \n  newObject: function() {\n    return [SC.generateGuid()];\n  },\n  \n  isEqual: function(a,b) {\n    if (!(a instanceof Array)) return false;\n    if (!(b instanceof Array)) return false;\n    if (a.length !== b.length) return false;\n    return a[0]===b[0];\n  },\n  \n  shouldBeFreezable: false\n}).run();\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/native_array/suite_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nSC.MutableArrayTests.extend({\n  \n  name: 'Native Array',\n  \n  newObject: function(ary) {\n    return ary ? ary.slice() : this.newFixture(3);\n  },\n\n  mutate: function(obj) {\n    obj.pushObject(obj.length+1);\n  },\n  \n  toArray: function(obj) {\n    return obj.slice(); // make a copy.\n  }\n  \n}).run();\n\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/object/computed_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth */\n\n\nrequire('sproutcore-runtime/~tests/props_helper');\n\nmodule('SC.Object computed property');\n\ntestBoth('computed property on instance', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    foo: SC.computed(function() { return 'FOO'; }).cacheable()\n  });\n  \n  equals(get(new MyClass(), 'foo'), 'FOO');\n  \n});\n\n\ntestBoth('computed property on subclass', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    foo: SC.computed(function() { return 'FOO'; }).cacheable()\n  });\n  \n  var Subclass = MyClass.extend({\n    foo: SC.computed(function() { return 'BAR'; }).cacheable()\n  });\n  \n  equals(get(new Subclass(), 'foo'), 'BAR');\n  \n});\n\n\ntestBoth('replacing computed property with regular val', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    foo: SC.computed(function() { return 'FOO'; }).cacheable()\n  });\n  \n  var Subclass = MyClass.extend({\n    foo: 'BAR'\n  });\n  \n  equals(get(new Subclass(), 'foo'), 'BAR');\n  \n});\n\ntestBoth('complex depndent keys', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    \n    init: function() {\n      this._super();\n      set(this, 'bar', { baz: 'BIFF' });\n    },\n\n    count: 0, \n    \n    foo: SC.computed(function() { \n      set(this, 'count', get(this, 'count')+1);\n      return get(get(this, 'bar'), 'baz') + ' ' + get(this, 'count'); \n    }).property('bar.baz').cacheable()\n\n  });\n  \n  var Subclass = MyClass.extend({\n    count: 20\n  });\n\n  var obj1 = new MyClass(),\n      obj2 = new Subclass();\n      \n  equals(get(obj1, 'foo'), 'BIFF 1');\n  equals(get(obj2, 'foo'), 'BIFF 21');\n\n  set(get(obj1, 'bar'), 'baz', 'BLARG');\n  \n  equals(get(obj1, 'foo'), 'BLARG 2');\n  equals(get(obj2, 'foo'), 'BIFF 21');\n\n  set(get(obj2, 'bar'), 'baz', 'BOOM');\n\n  equals(get(obj1, 'foo'), 'BLARG 2');\n  equals(get(obj2, 'foo'), 'BOOM 22');\n});\n\ntestBoth('complex depndent keys changing complex dependent keys', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    \n    init: function() {\n      this._super();\n      set(this, 'bar', { baz: 'BIFF' });\n    },\n\n    count: 0, \n    \n    foo: SC.computed(function() { \n      set(this, 'count', get(this, 'count')+1);\n      return get(get(this, 'bar'), 'baz') + ' ' + get(this, 'count'); \n    }).property('bar.baz').cacheable()\n\n  });\n  \n  var Subclass = MyClass.extend({\n    \n    init: function() {\n      this._super();\n      set(this, 'bar2', { baz: 'BIFF2' });\n    },\n    \n    count: 0,\n    \n    foo: SC.computed(function() {\n      set(this, 'count', get(this, 'count')+1);\n      return get(get(this, 'bar2'), 'baz') + ' ' + get(this, 'count');\n    }).property('bar2.baz').cacheable()\n  });\n\n  var obj2 = new Subclass();\n      \n  equals(get(obj2, 'foo'), 'BIFF2 1');\n\n  set(get(obj2, 'bar'), 'baz', 'BLARG');\n  equals(get(obj2, 'foo'), 'BIFF2 1', 'should not invalidate property');\n\n  set(get(obj2, 'bar2'), 'baz', 'BLARG');\n  equals(get(obj2, 'foo'), 'BLARG 2', 'should invalidate property');\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/object/create_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals raises TestObject */\n\n\nmodule('SC.Object.create');\n\ntest(\"Creates a new object that contains passed properties\", function() {\n  \n  var called = false;\n  var obj = SC.Object.create({ \n    prop: 'FOO', \n    method: function() { called=true; }\n  });\n\n  //console.log(Ct.dump(obj));\n  equals(SC.get(obj, 'prop'), 'FOO', 'obj.prop');\n  obj.method();\n  ok(called, 'method executed');\n\n});\n\n// ..........................................................\n// WORKING WITH MIXINS\n// \n\ntest(\"Creates a new object that includes mixins and properties\", function() {\n  \n  var MixinA = SC.Mixin.create({ mixinA: 'A' });\n  var obj = SC.Object.create(MixinA, { prop: 'FOO' });\n\n  equals(SC.get(obj, 'mixinA'), 'A', 'obj.mixinA');\n  equals(SC.get(obj, 'prop'), 'FOO', 'obj.prop');\n});\n\n// ..........................................................\n// LIFECYCLE\n// \n\ntest(\"Configures _super() on methods with override\", function() {\n  var completed = false;\n  var MixinA = SC.Mixin.create({ method: function() {} });\n  var obj = SC.Object.create(MixinA, {\n    method: function() {\n      this._super();\n      completed = true;\n    }\n  });\n  \n  obj.method();\n  ok(completed, 'should have run method without error');\n});\n\ntest(\"Calls init if defined\", function() {\n  var completed = false;\n  var obj = SC.Object.create({\n    init: function() {\n      this._super();\n      completed = true;\n    }\n  });\n  \n  ok(completed, 'should have run init without error');\n});\n\ntest(\"Calls all mixin inits if defined\", function() {\n  var completed = 0;\n  var Mixin1 = SC.Mixin.create({ \n    init: function() { this._super(); completed++; } \n  });\n  \n  var Mixin2 = SC.Mixin.create({ \n    init: function() { this._super(); completed++; } \n  });\n  \n  SC.Object.create(Mixin1, Mixin2);\n  equals(completed, 2, 'should have called init for both mixins.');\n});\n\ntest('creating an object with required properties', function() {\n  var ClassA = SC.Object.extend({\n    foo: SC.required()\n  });\n  \n  var obj = ClassA.create({ foo: 'FOO' }); // should not throw\n  equals(SC.get(obj,'foo'), 'FOO');\n});\n\n\n// ..........................................................\n// BUGS\n// \n\ntest('create should not break observed values', function() {\n  \n  var CountObject = SC.Object.extend({\n    value: null,\n\n    _count: 0,\n\n    reset: function() {  \n      this._count = 0;\n      return this;\n    },\n\n    valueDidChange: SC.observer(function() {\n      this._count++;\n    }, 'value')\n  });\n  \n  var obj = CountObject.create({ value: 'foo' });\n  equals(obj._count, 0, 'should not fire yet');\n  \n  SC.set(obj, 'value', 'BAR');\n  equals(obj._count, 1, 'should fire');\n});\n\ntest('bindings on a class should only sync on instances', function() {\n  TestObject = SC.Object.create({\n    foo: 'FOO'\n  });\n\n  var Class, inst;\n  \n  SC.run(function() {\n    Class = SC.Object.extend({\n      fooBinding: 'TestObject.foo'\n    });\n\n    inst = Class.create();\n  });\n  \n  equals(SC.get(Class.prototype, 'foo'), undefined, 'should not sync binding');\n  equals(SC.get(inst, 'foo'), 'FOO', 'should sync binding');\n\n});\n\n\ntest('inherited bindings should only sync on instances', function() {\n  TestObject = SC.Object.create({\n    foo: 'FOO'\n  });\n\n  var Class, Subclass, inst;\n\n  SC.run(function() {\n    Class = SC.Object.extend({\n      fooBinding: 'TestObject.foo'\n    });\n  });\n  \n  SC.run(function() {\n    Subclass = Class.extend();\n    inst = Subclass.create();\n  });\n  \n  equals(SC.get(Class.prototype, 'foo'), undefined, 'should not sync binding on Class');\n  equals(SC.get(Subclass.prototype, 'foo'), undefined, 'should not sync binding on Subclass');\n  equals(SC.get(inst, 'foo'), 'FOO', 'should sync binding on inst');\n  \n  SC.run(function() {\n    SC.set(TestObject, 'foo', 'BAR');\n  });\n  \n  equals(SC.get(Class.prototype, 'foo'), undefined, 'should not sync binding on Class');\n  equals(SC.get(Subclass.prototype, 'foo'), undefined, 'should not sync binding on Subclass');\n  equals(SC.get(inst, 'foo'), 'BAR', 'should sync binding on inst');\n  \n});\n\ntest(\"created objects should not share a guid with their superclass\", function() {\n  ok(SC.guidFor(SC.Object), \"SC.Object has a guid\");\n\n  var objA = SC.Object.create(),\n      objB = SC.Object.create();\n\n  ok(SC.guidFor(objA) !== SC.guidFor(objB), \"two instances do not share a guid\");\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/object/destroy_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals raises TestObject */\n\n\nmodule('sproutcore-runtime/system/object/destroy_test');\n\ntest(\"should schedule objects to be destroyed at the end of the run loop\", function() {\n  var obj = SC.Object.create();\n\n  SC.run(function() {\n    var meta;\n    obj.destroy();\n    meta = SC.meta(obj);\n    ok(meta, \"object is not destroyed immediately\");\n  });\n\n  ok(obj.get('isDestroyed'), \"object is destroyed after run loop finishes\");\n});\n\ntest(\"should raise an exception when modifying watched properties on a destroyed object\", function() {\n  if (SC.platform.hasAccessors) {\n    var obj = SC.Object.create({\n      foo: \"bar\",\n      fooDidChange: SC.observer(function() { }, 'foo')\n    });\n\n    SC.run(function() {\n      obj.destroy();\n    });\n\n    raises(function() {\n      SC.set(obj, 'foo', 'baz');\n    }, Error, \"raises an exception\");\n  }\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/object/extend_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.Object.extend');\n\ntest('Basic extend', function() {\n  var SomeClass = SC.Object.extend({ foo: 'BAR' });\n  ok(SomeClass.isClass, \"A class has isClass of true\");\n  var obj = new SomeClass();\n  equals(obj.foo, 'BAR');\n  ok(obj.isInstance, \"An instance of a class has isInstance of true\");\n});\n\ntest('Sub-subclass', function() {\n  var SomeClass = SC.Object.extend({ foo: 'BAR' });\n  var AnotherClass = SomeClass.extend({ bar: 'FOO' });\n  var obj = new AnotherClass();\n  equals(obj.foo, 'BAR');\n  equals(obj.bar, 'FOO');\n});\n\ntest('Overriding a method several layers deep', function() {\n  var SomeClass = SC.Object.extend({\n    fooCnt: 0,\n    foo: function() { this.fooCnt++; },\n\n    barCnt: 0,\n    bar: function() { this.barCnt++; }\n  });\n\n  var AnotherClass = SomeClass.extend({\n    barCnt: 0,\n    bar: function() { this.barCnt++; this._super(); }\n  });\n\n  var FinalClass = AnotherClass.extend({\n    fooCnt: 0,\n    foo: function() { this.fooCnt++; this._super(); }\n  });\n  \n  var obj = new FinalClass();\n  obj.foo();\n  obj.bar();\n  equals(obj.fooCnt, 2, 'should invoke both');\n  equals(obj.barCnt, 2, 'should invoke both');\n\n  // Try overriding on create also\n  obj = FinalClass.create({\n    foo: function() { this.fooCnt++; this._super(); }\n  });\n\n  obj.foo();\n  obj.bar();\n  equals(obj.fooCnt, 3, 'should invoke final as well');\n  equals(obj.barCnt, 2, 'should invoke both');\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/object/observer_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n/*globals testBoth */\n\n\nrequire('sproutcore-runtime/~tests/props_helper');\n\nmodule('SC.Object observer');\n\ntestBoth('observer on class', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    \n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var obj = new MyClass();\n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equals(get(obj, 'count'), 1, 'should invoke observer after change');\n\n});\n\ntestBoth('observer on subclass', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    \n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var Subclass = MyClass.extend({\n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'baz')\n  });\n  \n  var obj = new Subclass();\n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equals(get(obj, 'count'), 0, 'should not invoke observer after change');\n\n  set(obj, 'baz', \"BAZ\");\n  equals(get(obj, 'count'), 1, 'should not invoke observer after change');\n\n});\n\ntestBoth('observer on instance', function(get, set) {\n\n  var obj = SC.Object.create({\n    \n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equals(get(obj, 'count'), 1, 'should invoke observer after change');\n\n});\n\ntestBoth('observer on instance overridding class', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    \n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var obj = MyClass.create({\n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'baz') // <-- change property we observe\n  });\n  \n  equals(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equals(get(obj, 'count'), 0, 'should not invoke observer after change');\n\n  set(obj, 'baz', \"BAZ\");\n  equals(get(obj, 'count'), 1, 'should not invoke observer after change');\n\n});\n\ntestBoth('observer should not fire after being destroyed', function(get, set) {\n\n  var obj = SC.Object.create({\n    count: 0,\n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n  });\n\n  equals(get(obj, 'count'), 0, 'precond - should not invoke observer immediately');\n\n  SC.run(function() { obj.destroy(); });\n\n  if (SC.platform.hasPropertyAccessors) {\n    raises(function() {\n      set(obj, 'bar', \"BAZ\");\n    }, Error, \"raises error when setting a property\");\n  } else {\n    set(obj, 'bar', \"BAZ\");\n  }\n\n  equals(get(obj, 'count'), 0, 'should not invoke observer after change');\n});\n// ..........................................................\n// COMPLEX PROPERTIES\n// \n\n\ntestBoth('chain observer on class', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n  \n  var obj1 = MyClass.create({\n    bar: { baz: 'biff' }\n  });\n  \n  var obj2 = MyClass.create({\n    bar: { baz: 'biff2' }\n  });\n  \n  equals(get(obj1, 'count'), 0, 'should not invoke yet');\n  equals(get(obj2, 'count'), 0, 'should not invoke yet');\n  \n  set(get(obj1, 'bar'), 'baz', 'BIFF1');\n  equals(get(obj1, 'count'), 1, 'should invoke observer on obj1');\n  equals(get(obj2, 'count'), 0, 'should not invoke yet');\n\n  set(get(obj2, 'bar'), 'baz', 'BIFF2');\n  equals(get(obj1, 'count'), 1, 'should not invoke again');\n  equals(get(obj2, 'count'), 1, 'should invoke observer on obj2');  \n});\n\n\ntestBoth('chain observer on class', function(get, set) {\n\n  var MyClass = SC.Object.extend({\n    count: 0,\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n  \n  var obj1 = MyClass.create({\n    bar: { baz: 'biff' }\n  });\n  \n  var obj2 = MyClass.create({\n    bar: { baz: 'biff2' },\n    bar2: { baz: 'biff3' },\n    \n    foo: SC.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar2.baz')\n  });\n  \n  equals(get(obj1, 'count'), 0, 'should not invoke yet');\n  equals(get(obj2, 'count'), 0, 'should not invoke yet');\n  \n  set(get(obj1, 'bar'), 'baz', 'BIFF1');\n  equals(get(obj1, 'count'), 1, 'should invoke observer on obj1');\n  equals(get(obj2, 'count'), 0, 'should not invoke yet');\n\n  set(get(obj2, 'bar'), 'baz', 'BIFF2');\n  equals(get(obj1, 'count'), 1, 'should not invoke again');\n  equals(get(obj2, 'count'), 0, 'should not invoke yet');  \n\n  set(get(obj2, 'bar2'), 'baz', 'BIFF3');\n  equals(get(obj1, 'count'), 1, 'should not invoke again');\n  equals(get(obj2, 'count'), 1, 'should invoke observer on obj2');  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/object/reopenClass_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/object/reopenClass');\n\ntest('adds new properties to subclass', function() {\n  \n  var Subclass = SC.Object.extend();\n  Subclass.reopenClass({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n  \n  equals(Subclass.foo(), 'FOO', 'Adds method');\n  equals(SC.get(Subclass, 'bar'), 'BAR', 'Adds property');\n});\n\ntest('class properties inherited by subclasses', function() {\n  \n  var Subclass = SC.Object.extend();\n  Subclass.reopenClass({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n\n  var SubSub = Subclass.extend();\n  \n  equals(SubSub.foo(), 'FOO', 'Adds method');\n  equals(SC.get(SubSub, 'bar'), 'BAR', 'Adds property');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/system/object/reopen_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/core_object/reopenClass');\n\ntest('adds new properties to subclass instance', function() {\n  \n  var Subclass = SC.Object.extend();\n  Subclass.reopen({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n  \n  equals( new Subclass().foo(), 'FOO', 'Adds method');\n  equals(SC.get(new Subclass(), 'bar'), 'BAR', 'Adds property');\n});\n\ntest('reopened properties inherited by subclasses', function() {\n  \n  var Subclass = SC.Object.extend();\n  var SubSub = Subclass.extend();\n\n  Subclass.reopen({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n\n  \n  equals( new SubSub().foo(), 'FOO', 'Adds method');\n  equals(SC.get(new SubSub(), 'bar'), 'BAR', 'Adds property');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/system/object/subclasses_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/object/subclasses');\n\ntest('SC.Object should have a subclass set', function() {\n  ok(SC.Object.subclasses instanceof SC.Set);\n});\n\ntest('defining a new subclass should add it to set of parent', function() {\n  var Subclass = SC.Object.extend();\n  ok(SC.Object.subclasses.contains(Subclass));\n});\n\ntest('defining sub-sub class should only go to parent', function() {\n  var Sub = SC.Object.extend();\n  var SubSub = Sub.extend();\n  \n  ok(SC.Object.subclasses.contains(Sub), 'SC.Object contains Sub');\n  ok(Sub.subclasses.contains(SubSub), 'Sub contains SubSub');\n});\n\n\n});");spade.register("sproutcore-runtime/~tests/system/run_loop/later_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/run_loop/later_test');\n\ntest('should invoke after specified period of time - function only', function() {\n\n  var invoked = false;\n  \n  SC.run.later(function() { invoked = true; }, 100);\n  stop();\n  \n  setTimeout(function() {\n    start();\n    equals(invoked, true, 'should have invoked later item');\n  }, 150);\n  \n});\n\n\ntest('should invoke after specified period of time - target/method', function() {\n\n  var obj = { invoked: false } ;\n  \n  SC.run.later(obj, function() { this.invoked = true; }, 100);\n  stop();\n  \n  setTimeout(function() {\n    start();\n    equals(obj.invoked, true, 'should have invoked later item');\n  }, 150);\n  \n});\n\n\ntest('should invoke after specified period of time - target/method/args', function() {\n\n  var obj = { invoked: 0 } ;\n  \n  SC.run.later(obj, function(amt) { this.invoked += amt; }, 10, 100);\n  stop();\n  \n  setTimeout(function() {\n    start();\n    equals(obj.invoked, 10, 'should have invoked later item');\n  }, 150);\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/run_loop/next_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/run_loop/next_test');\n\ntest('should invoke immediately on next timeout', function() {\n\n  var invoked = false;\n  \n  stop();\n  \n  SC.run(function() {\n    SC.run.next(function() { invoked = true; });\n  });\n\n  equals(invoked, false, 'should not have invoked yet');\n  \n  \n  setTimeout(function() {\n    start();\n    equals(invoked, true, 'should have invoked later item');\n  }, 20);\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/run_loop/once_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/run_loop/once_test');\n\ntest('calling invokeOnce more than once invokes only once', function() {\n\n  var count = 0;\n  SC.run(function() {\n    var F = function() { count++; };\n    SC.run.once(F);\n    SC.run.once(F);\n    SC.run.once(F);\n  });\n  \n  equals(count, 1, 'should have invoked once');\n});\n\ntest('should differentiate based on target', function() {\n\n  var A = { count: 0 }, B = { count: 0 };\n  SC.run(function() {\n    var F = function() { this.count++; };\n    SC.run.once(A, F);\n    SC.run.once(B, F);\n    SC.run.once(A, F);\n    SC.run.once(B, F);\n  });\n  \n  equals(A.count, 1, 'should have invoked once on A');\n  equals(B.count, 1, 'should have invoked once on B');\n});\n\n\ntest('should ignore other arguments - replacing previous ones', function() {\n\n  var A = { count: 0 }, B = { count: 0 };\n  SC.run(function() {\n    var F = function(amt) { this.count += amt; };\n    SC.run.once(A, F, 10);\n    SC.run.once(B, F, 20);\n    SC.run.once(A, F, 30);\n    SC.run.once(B, F, 40);\n  });\n  \n  equals(A.count, 30, 'should have invoked once on A');\n  equals(B.count, 40, 'should have invoked once on B');\n});\n\ntest('should be inside of a runloop when running', function() {\n\n  SC.run(function() {\n    SC.run.once(function() {\n      ok(!!SC.run.currentRunLoop, 'should have a runloop');\n    });\n  });\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/run_loop/run_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/run_loop/run_test');\n\ntest('SC.run invokes passed function, returning value', function() {\n  var obj = {\n    foo: function() { return [this.bar, 'FOO']; },\n    bar: 'BAR',\n    checkArgs: function(arg1, arg2) { return [ arg1, this.bar, arg2 ]; }\n  };\n\n  equals(SC.run(function() { return 'FOO'; }), 'FOO', 'pass function only');\n  same(SC.run(obj, obj.foo), ['BAR', 'FOO'], 'pass obj and obj.method');\n  same(SC.run(obj, 'foo'), ['BAR', 'FOO'], 'pass obj and \"method\"');\n  same(SC.run(obj, obj.checkArgs, 'hello', 'world'), ['hello', 'BAR', 'world'], 'pass obj, obj.method, and extra arguments');\n});\n\n});");spade.register("sproutcore-runtime/~tests/system/run_loop/schedule_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/run_loop/schedule_test');\n\ntest('scheduling item in queue should defer until finished', function() {\n  var cnt = 0;\n  \n  SC.run(function() {\n    SC.run.schedule('actions', function() { cnt++; });\n    SC.run.schedule('actions', function() { cnt++; });\n    equals(cnt, 0, 'should not run action yet') ;\n  });\n  \n  equals(cnt, 2, 'should flush actions now');\n  \n});\n\ntest('nested runs should queue each phase independently', function() {\n  var cnt = 0;\n  \n  SC.run(function() {\n    SC.run.schedule('actions', function() { cnt++; });\n    equals(cnt, 0, 'should not run action yet') ;\n    \n    SC.run(function() {\n      SC.run.schedule('actions', function() { cnt++; });\n    });\n    equals(cnt, 1, 'should not run action yet') ;\n\n  });\n  \n  equals(cnt, 2, 'should flush actions now');\n  \n});\n\n});");spade.register("sproutcore-runtime/~tests/system/run_loop/sync_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('system/run_loop/schedule_test');\n\ntest('sync() will immediately flush the sync queue only', function() {\n  var cnt = 0;\n  \n  SC.run(function() {\n\n    function cntup() { cnt++; }\n    \n    function syncfunc() {\n      if (++cnt<5) SC.run.schedule('sync', syncfunc);\n      SC.run.schedule('actions', cntup);\n    }\n    \n    syncfunc();\n\n    equals(cnt, 1, 'should not run action yet') ;\n    SC.run.sync();\n    \n    equals(cnt, 5, 'should have run sync queue continuously');\n  });\n  \n  equals(cnt, 10, 'should flush actions now too');\n  \n});\n\n\ntest('sync() works outside of runloop (by fixing runloop)', function() {\n  var cnt = 0;\n  \n  function cntup() { cnt++; }\n  \n  function syncfunc() {\n    if (++cnt<5) SC.run.schedule('sync', syncfunc);\n    SC.run.schedule('actions', cntup);\n  }\n    \n  syncfunc();\n\n  equals(cnt, 1, 'should not run action yet') ;\n  SC.run.sync();\n    \n  equals(cnt, 5, 'should have run sync queue continuously');\n  \n});\n\n\n});");spade.register("sproutcore-runtime/~tests/system/set/copyable_suite_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n// ..........................................................\n// COPYABLE TESTS\n// \nSC.CopyableTests.extend({\n  name: 'SC.Set Copyable',\n  \n  newObject: function() {\n    var set = new SC.Set();\n    set.addObject(SC.generateGuid());\n    return set;\n  },\n  \n  isEqual: function(a,b) {\n    if (!(a instanceof SC.Set)) return false;\n    if (!(b instanceof SC.Set)) return false;\n    return SC.get(a, 'firstObject') === SC.get(b, 'firstObject');\n  },\n  \n  shouldBeFreezable: true\n}).run();\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/set/enumerable_suite_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n// ..........................................................\n// MUTABLE ENUMERABLE TESTS\n// \nSC.MutableEnumerableTests.extend({\n  \n  name: 'SC.Set',\n  \n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    var ret = new SC.Set();\n    ret.addObjects(ary);\n    return ret;\n  },\n\n  mutate: function(obj) {\n    obj.addObject(SC.get(obj, 'length')+1);\n  },\n  \n  toArray: function(obj) {\n    return obj.toArray ? obj.toArray() : obj.slice(); // make a copy.\n  }\n  \n}).run();\n\n});");spade.register("sproutcore-runtime/~tests/system/set/extra_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\n// ..........................................................\n// SC.Set.init\n// \n\nmodule('SC.Set.init');\n\ntest('passing an array to new SC.Set() should instantiate w/ items', function() {\n\n  var get = SC.get;\n  var ary  = [1,2,3];\n  var aSet = new SC.Set(ary);\n  var count = 0;\n  \n  equals(get(aSet, 'length'), 3, 'should have three items');\n  aSet.forEach(function(x) {\n    ok(ary.indexOf(x)>=0, 'should find passed item in array');\n    count++;\n  });\n  equals(count, 3, 'iterating should have returned three objects');\n});\n\n\n// ..........................................................\n// SC.Set.clear\n// \n\nmodule('SC.Set.clear');\n\ntest('should clear a set of its content', function() {\n\n  var get = SC.get, set = SC.set;\n  var aSet = new SC.Set([1,2,3]);\n  var count = 0;\n  \n  equals(get(aSet, 'length'), 3, 'should have three items');\n  ok(get(aSet, 'firstObject'), 'firstObject should return an object');\n  ok(get(aSet, 'lastObject'), 'lastObject should return an object');\n  SC.addObserver(aSet, '[]', function() { count++; });\n\n  aSet.clear();\n  equals(get(aSet, 'length'), 0, 'should have 0 items');\n  equals(count, 1, 'should have notified of content change');\n  equals(get(aSet, 'firstObject'), null, 'firstObject should return nothing');\n  equals(get(aSet, 'lastObject'), null, 'lastObject should return nothing');\n  \n  count = 0;\n  aSet.forEach(function() { count++; });\n  equals(count, 0, 'iterating over items should not invoke callback');\n  \n});\n\n// ..........................................................\n// SC.Set.pop\n// \n\nmodule('SC.Set.pop');\n\ntest('calling pop should return an object and remove it', function() {\n\n  var aSet = new SC.Set([1,2,3]);\n  var count = 0, obj;\n  while(count<10 && (obj = aSet.pop())) { \n    equals(aSet.contains(obj), false, 'set should no longer contain object');\n    count++;\n    equals(SC.get(aSet, 'length'), 3-count, 'length should be shorter');\n  }\n  \n  equals(count, 3, 'should only pop 3 objects');\n  equals(SC.get(aSet, 'length'), 0, 'final length should be zero');\n  equals(aSet.pop(), null, 'extra pops should do nothing');\n});\n\n// ..........................................................\n// SC.Set.aliases\n// \n\nmodule('SC.Set aliases');\n\ntest('method aliases', function() {\n  var aSet = new SC.Set();\n  equals(aSet.add, aSet.addObject, 'add -> addObject');\n  equals(aSet.remove, aSet.removeObject, 'remove -> removeObject');\n  equals(aSet.addEach, aSet.addObjects, 'addEach -> addObjects');\n  equals(aSet.removeEach, aSet.removeObjects, 'removeEach -> removeObjects');\n\n  equals(aSet.push, aSet.addObject, 'push -> addObject');\n  equals(aSet.unshift, aSet.addObject, 'unshift -> addObject');\n  equals(aSet.shift, aSet.pop, 'shift -> pop');\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/string/fmt_string", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.String.fmt');\n\ntest(\"'Hello %@ %@'.fmt('John', 'Doe') => 'Hello John Doe'\", function() {\n  equals(SC.String.fmt('Hello %@ %@', ['John', 'Doe']), 'Hello John Doe');\n  if (SC.EXTEND_PROTOTYPES) {\n    equals('Hello %@ %@'.fmt('John', 'Doe'), 'Hello John Doe');\n  }\n});\n\ntest(\"'Hello %@2 %@1'.fmt('John', 'Doe') => 'Hello Doe John'\", function() {\n  equals(SC.String.fmt('Hello %@2 %@1', ['John', 'Doe']), 'Hello Doe John');\n  if (SC.EXTEND_PROTOTYPES) {\n    equals('Hello %@2 %@1'.fmt('John', 'Doe'), 'Hello Doe John');\n  }\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/string/loc_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nvar oldString;\n\nmodule('SC.String.loc', {\n  setup: function() {\n    oldString = SC.STRINGS;\n    SC.STRINGS = {\n      '_Hello World': 'Bonjour le monde',\n      '_Hello %@ %@': 'Bonjour %@ %@',\n      '_Hello %@# %@#': 'Bonjour %@2 %@1'\n    };\n  },\n  \n  teardown: function() {\n    SC.STRINGS = oldString;\n  }\n});\n\ntest(\"'_Hello World'.loc() => 'Bonjour le monde'\", function() {\n  equals(SC.String.loc('_Hello World'), 'Bonjour le monde');\n  if (SC.EXTEND_PROTOTYPES) {\n    equals('_Hello World'.loc(), 'Bonjour le monde');\n  }\n});\n\ntest(\"'_Hello %@ %@'.loc('John', 'Doe') => 'Bonjour John Doe'\", function() {\n  equals(SC.String.loc('_Hello %@ %@', ['John', 'Doe']), 'Bonjour John Doe');\n  if (SC.EXTEND_PROTOTYPES) {\n    equals('_Hello %@ %@'.loc('John', 'Doe'), 'Bonjour John Doe');\n  }\n});\n\ntest(\"'_Hello %@# %@#'.loc('John', 'Doe') => 'Bonjour Doe John'\", function() {\n  equals(SC.String.loc('_Hello %@# %@#', ['John', 'Doe']), 'Bonjour Doe John');\n  if (SC.EXTEND_PROTOTYPES) {\n    equals('_Hello %@# %@#'.loc('John', 'Doe'), 'Bonjour Doe John');\n  }\n});\n\ntest(\"'_Not In Strings'.loc() => '_Not In Strings'\", function() {\n  equals(SC.String.loc('_Not In Strings'), '_Not In Strings');\n  if (SC.EXTEND_PROTOTYPES) {\n    equals('_Not In Strings'.loc(), '_Not In Strings');\n  }\n});\n\n\n\n});");spade.register("sproutcore-runtime/~tests/system/string/w_test", "(function(require, exports, __module, ARGV, ENV, __filename){// ==========================================================================\n// Project:  SproutCore Runtime\n// Copyright: ©2006-2011 Strobe Inc. and contributors.\n//            ©2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('SC.String.w');\n\ntest(\"'one two three'.w() => ['one','two','three']\", function() {\n  same(SC.String.w('one two three'), ['one','two','three']);\n  if (SC.EXTEND_PROTOTYPES) {\n    same('one two three'.w(), ['one','two','three']);\n  }\n});\n\ntest(\"'one    two    three'.w() with extra spaces between words => ['one','two','three']\", function() {\n  same(SC.String.w('one   two  three'), ['one','two','three']);\n  if (SC.EXTEND_PROTOTYPES) {\n    same('one   two  three'.w(), ['one','two','three']);\n  }\n});\n\ntest(\"'one two three'.w() with tabs\", function() {\n  same(SC.String.w('one\\ttwo  three'), ['one','two','three']);\n  if (SC.EXTEND_PROTOTYPES) {\n    same('one\\ttwo  three'.w(), ['one','two','three']);\n  }\n});\n\n\n\n});");